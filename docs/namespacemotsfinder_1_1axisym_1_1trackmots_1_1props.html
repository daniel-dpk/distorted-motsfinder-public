<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: motsfinder.axisym.trackmots.props Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   &#160;<span id="projectnumber">v1.4-3-g4c3aa7c</span>
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">motsfinder.axisym.trackmots.props Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to compute and store physical properties of MOTS curves.  
<a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1props_1_1__PropResult.html">_PropResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple storage class to help return results of computations.  <a href="classmotsfinder_1_1axisym_1_1trackmots_1_1props_1_1__PropResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1props_1_1AuxResultMissing.html">AuxResultMissing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised when a result is missing required for computing a property.  <a href="classmotsfinder_1_1axisym_1_1trackmots_1_1props_1_1AuxResultMissing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a21f8b604915b93a35bb43250aaedb657"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a21f8b604915b93a35bb43250aaedb657">compute_props</a> (hname, c, props, area_rtol=1e-6, min_stability_values=30, m_terminate_index=30, max_multipole_n=10, stability_convergence_factors=(0.2, 0.4, 0.6, 0.8, 0.9, 1.1), verbosity=True, MOTS_map=None, fname=None, remove_invalid=True, update_file=False)</td></tr>
<tr class="memdesc:a21f8b604915b93a35bb43250aaedb657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute properties and store them in the curve object.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a21f8b604915b93a35bb43250aaedb657">More...</a><br /></td></tr>
<tr class="separator:a21f8b604915b93a35bb43250aaedb657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5549743263a79a1f99b3c18193c322"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#aed5549743263a79a1f99b3c18193c322">_area</a> (c, v=None, **kw)</td></tr>
<tr class="memdesc:aed5549743263a79a1f99b3c18193c322"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area for the curve.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#aed5549743263a79a1f99b3c18193c322">More...</a><br /></td></tr>
<tr class="separator:aed5549743263a79a1f99b3c18193c322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02432e6538cf5e0db3bcd83f2cd5678"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ad02432e6538cf5e0db3bcd83f2cd5678">_area_parts_individual</a> (c, out_dir, other_run, other_hname, v=None, **kw)</td></tr>
<tr class="memdesc:ad02432e6538cf5e0db3bcd83f2cd5678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area of different parts of an individual MOTS.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ad02432e6538cf5e0db3bcd83f2cd5678">More...</a><br /></td></tr>
<tr class="separator:ad02432e6538cf5e0db3bcd83f2cd5678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b41123f3953afd9c6ed77ee93e391a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a59b41123f3953afd9c6ed77ee93e391a">_area_parts_inner</a> (c, out_dir, top_run, bot_run, v=None, **kw)</td></tr>
<tr class="memdesc:a59b41123f3953afd9c6ed77ee93e391a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute areas of different parts of the inner common MOTS.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a59b41123f3953afd9c6ed77ee93e391a">More...</a><br /></td></tr>
<tr class="separator:a59b41123f3953afd9c6ed77ee93e391a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed24f2d19ec7f7c15fd9c9aa0a3fce5"><td class="memItemLeft" align="right" valign="top"><a id="a6ed24f2d19ec7f7c15fd9c9aa0a3fce5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a6ed24f2d19ec7f7c15fd9c9aa0a3fce5">_data_is_valid</a> (prop, value, args, hname)</td></tr>
<tr class="memdesc:a6ed24f2d19ec7f7c15fd9c9aa0a3fce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the current data is valid or should be removed. <br /></td></tr>
<tr class="separator:a6ed24f2d19ec7f7c15fd9c9aa0a3fce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebaf0d92180e9060f6d9533925a29c5e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#aebaf0d92180e9060f6d9533925a29c5e">_multipoles</a> (c, max_n, v=None)</td></tr>
<tr class="memdesc:aebaf0d92180e9060f6d9533925a29c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first multipoles for the given curve.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#aebaf0d92180e9060f6d9533925a29c5e">More...</a><br /></td></tr>
<tr class="separator:aebaf0d92180e9060f6d9533925a29c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc65b9f082355ce19bf49dbec0dc958"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a7cc65b9f082355ce19bf49dbec0dc958">_stability</a> (c, min_num, method, m_terminate_index, slice_normal, v=None)</td></tr>
<tr class="memdesc:a7cc65b9f082355ce19bf49dbec0dc958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability spectrum for the curve.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a7cc65b9f082355ce19bf49dbec0dc958">More...</a><br /></td></tr>
<tr class="separator:a7cc65b9f082355ce19bf49dbec0dc958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1468ca1202bd38b0fbcd91cff006e86c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a1468ca1202bd38b0fbcd91cff006e86c">_stability_convergence</a> (c, min_num, convergence_factors, method, slice_normal, verbose=False, v=None)</td></tr>
<tr class="memdesc:a1468ca1202bd38b0fbcd91cff006e86c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability spectrum at different resolutions.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a1468ca1202bd38b0fbcd91cff006e86c">More...</a><br /></td></tr>
<tr class="separator:a1468ca1202bd38b0fbcd91cff006e86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786a583f55e60e3ac7be8a654c8ad6fe"><td class="memItemLeft" align="right" valign="top"><a id="a786a583f55e60e3ac7be8a654c8ad6fe"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a786a583f55e60e3ac7be8a654c8ad6fe">_ricci</a> (c, Ns, eps, xatol)</td></tr>
<tr class="memdesc:a786a583f55e60e3ac7be8a654c8ad6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Ricci scalar and its maximum along the curve. <br /></td></tr>
<tr class="separator:a786a583f55e60e3ac7be8a654c8ad6fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58cd470293c935225d29d426479a0bab"><td class="memItemLeft" align="right" valign="top"><a id="a58cd470293c935225d29d426479a0bab"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a58cd470293c935225d29d426479a0bab">_mean_curv</a> (c, Ns, eps, xatol)</td></tr>
<tr class="memdesc:a58cd470293c935225d29d426479a0bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean curvature and its maximum along the curve. <br /></td></tr>
<tr class="separator:a58cd470293c935225d29d426479a0bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fb2bcfec8852831d72a5205d6cf61e"><td class="memItemLeft" align="right" valign="top"><a id="ab8fb2bcfec8852831d72a5205d6cf61e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ab8fb2bcfec8852831d72a5205d6cf61e">_curv_squared</a> (c, Ns, eps, xatol)</td></tr>
<tr class="memdesc:ab8fb2bcfec8852831d72a5205d6cf61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curvature square and its maximum along the curve. <br /></td></tr>
<tr class="separator:ab8fb2bcfec8852831d72a5205d6cf61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503259e9c3fe7f9f56b443b6dd34347a"><td class="memItemLeft" align="right" valign="top"><a id="a503259e9c3fe7f9f56b443b6dd34347a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a503259e9c3fe7f9f56b443b6dd34347a">_sample_and_extremum</a> (c, func, Ns, eps, xatol)</td></tr>
<tr class="memdesc:a503259e9c3fe7f9f56b443b6dd34347a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a property along the curve and find its maximum. <br /></td></tr>
<tr class="separator:a503259e9c3fe7f9f56b443b6dd34347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f66354690e83c8806a106a80e82f29f"><td class="memItemLeft" align="right" valign="top"><a id="a1f66354690e83c8806a106a80e82f29f"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>_find_extremum</b> (func, pts, eps, xatol, fx=None, domain=(0, np.pi))</td></tr>
<tr class="separator:a1f66354690e83c8806a106a80e82f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e84b1d34b0dc3a05c7f65184979f2b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a75e84b1d34b0dc3a05c7f65184979f2b">_shear</a> (c, num, eps, xatol, v=None)</td></tr>
<tr class="memdesc:a75e84b1d34b0dc3a05c7f65184979f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shear and shear-square at Chebyshev collocation points.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a75e84b1d34b0dc3a05c7f65184979f2b">More...</a><br /></td></tr>
<tr class="separator:a75e84b1d34b0dc3a05c7f65184979f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4431460d78b76725a832663c3f196e3"><td class="memItemLeft" align="right" valign="top"><a id="ad4431460d78b76725a832663c3f196e3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ad4431460d78b76725a832663c3f196e3">_shear2_integral</a> (c, n)</td></tr>
<tr class="memdesc:ad4431460d78b76725a832663c3f196e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate the shear^2 over the MOTS. <br /></td></tr>
<tr class="separator:ad4431460d78b76725a832663c3f196e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d467c9051c1f651e7cc69e9e4bf545"><td class="memItemLeft" align="right" valign="top"><a id="ac5d467c9051c1f651e7cc69e9e4bf545"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ac5d467c9051c1f651e7cc69e9e4bf545">_shear_scalar</a> (c, lmax)</td></tr>
<tr class="memdesc:ac5d467c9051c1f651e7cc69e9e4bf545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the shear scalar into spin weighted spherical harmonics. <br /></td></tr>
<tr class="separator:ac5d467c9051c1f651e7cc69e9e4bf545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9264fc162e55b84a129f6a1a55ae008"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008">compute_xi_vector</a> (curve, curves, steps=3, num=None, eps=1e-6, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:ae9264fc162e55b84a129f6a1a55ae008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the xi vector.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008">More...</a><br /></td></tr>
<tr class="separator:ae9264fc162e55b84a129f6a1a55ae008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ab14427a974e47152e3a11866c1fa0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a99ab14427a974e47152e3a11866c1fa0">compute_xi2_integral</a> (curve, curves, steps=3, n=&quot;auto&quot;, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a99ab14427a974e47152e3a11866c1fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate xi^2 over the MOTS.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a99ab14427a974e47152e3a11866c1fa0">More...</a><br /></td></tr>
<tr class="separator:a99ab14427a974e47152e3a11866c1fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031246bb126719783a4d07046679b4f8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a031246bb126719783a4d07046679b4f8">compute_xi_scalar</a> (curve, curves, steps=3, lmax=&quot;auto&quot;, min_lmax=64, max_lmax=512, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a031246bb126719783a4d07046679b4f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand xi_(ell) into spin weighted spherical harmonics.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a031246bb126719783a4d07046679b4f8">More...</a><br /></td></tr>
<tr class="separator:a031246bb126719783a4d07046679b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c0f4ca7685eb1ff753605bd57f648"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a327c0f4ca7685eb1ff753605bd57f648">compute_surface_gravity</a> (curve, curves, steps=3, num=None, eps=1e-6, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a327c0f4ca7685eb1ff753605bd57f648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the surface gravity at a set of points on a MOTS.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a327c0f4ca7685eb1ff753605bd57f648">More...</a><br /></td></tr>
<tr class="separator:a327c0f4ca7685eb1ff753605bd57f648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a480e2cc7d21fb81a2c23a66c30f4d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#af6a480e2cc7d21fb81a2c23a66c30f4d">compute_surface_gravity_tev</a> (curve, curves, steps=3, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:af6a480e2cc7d21fb81a2c23a66c30f4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the surface gravity with respect to the time evolution vector.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#af6a480e2cc7d21fb81a2c23a66c30f4d">More...</a><br /></td></tr>
<tr class="separator:af6a480e2cc7d21fb81a2c23a66c30f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad4ae9b8a355a4e7b5a881be7861865"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a8ad4ae9b8a355a4e7b5a881be7861865">compute_timescale_tau2</a> (curve, curves, steps=3, use_user_data=True, recompute=False, full_output=False, update_file=False, option=0)</td></tr>
<tr class="memdesc:a8ad4ae9b8a355a4e7b5a881be7861865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of the timescale <code>tau</code>.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a8ad4ae9b8a355a4e7b5a881be7861865">More...</a><br /></td></tr>
<tr class="separator:a8ad4ae9b8a355a4e7b5a881be7861865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56ae96c78c2ad46e8da35f7a3fae52c"><td class="memItemLeft" align="right" valign="top"><a id="aa56ae96c78c2ad46e8da35f7a3fae52c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#aa56ae96c78c2ad46e8da35f7a3fae52c">compute_timescale_tau2_option01</a> (*args, **kwargs)</td></tr>
<tr class="memdesc:aa56ae96c78c2ad46e8da35f7a3fae52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute option 1 in .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd" title="Compute the square of the timescale tau.">curve.expcurve.ExpansionCurve.timescale_tau2()</a>. <br /></td></tr>
<tr class="separator:aa56ae96c78c2ad46e8da35f7a3fae52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca93a043e3c87ba6479f256e25723f7"><td class="memItemLeft" align="right" valign="top"><a id="adca93a043e3c87ba6479f256e25723f7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#adca93a043e3c87ba6479f256e25723f7">compute_timescale_tau2_option02</a> (*args, **kwargs)</td></tr>
<tr class="memdesc:adca93a043e3c87ba6479f256e25723f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute option 2 in .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd" title="Compute the square of the timescale tau.">curve.expcurve.ExpansionCurve.timescale_tau2()</a>. <br /></td></tr>
<tr class="separator:adca93a043e3c87ba6479f256e25723f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e15904bd9d5e9fa909daeb9a608ca9"><td class="memItemLeft" align="right" valign="top"><a id="ad9e15904bd9d5e9fa909daeb9a608ca9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ad9e15904bd9d5e9fa909daeb9a608ca9">compute_timescale_tau2_option03</a> (*args, **kwargs)</td></tr>
<tr class="memdesc:ad9e15904bd9d5e9fa909daeb9a608ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute option 3 in .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd" title="Compute the square of the timescale tau.">curve.expcurve.ExpansionCurve.timescale_tau2()</a>. <br /></td></tr>
<tr class="separator:ad9e15904bd9d5e9fa909daeb9a608ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a767a71dd1777c1a1f120d2e755ef3afc"><td class="memItemLeft" align="right" valign="top"><a id="a767a71dd1777c1a1f120d2e755ef3afc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a767a71dd1777c1a1f120d2e755ef3afc">compute_timescale_tau2_option04</a> (*args, **kwargs)</td></tr>
<tr class="memdesc:a767a71dd1777c1a1f120d2e755ef3afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute option 4 in .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd" title="Compute the square of the timescale tau.">curve.expcurve.ExpansionCurve.timescale_tau2()</a>. <br /></td></tr>
<tr class="separator:a767a71dd1777c1a1f120d2e755ef3afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722645d144ac06d6d6fb9b4cd2ca018f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a722645d144ac06d6d6fb9b4cd2ca018f">compute_timescale_T2</a> (curve, curves, steps=3, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a722645d144ac06d6d6fb9b4cd2ca018f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of the timescale <code>T</code>.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a722645d144ac06d6d6fb9b4cd2ca018f">More...</a><br /></td></tr>
<tr class="separator:a722645d144ac06d6d6fb9b4cd2ca018f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9900481e2bab00284b7226a40b0586ff"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a9900481e2bab00284b7226a40b0586ff">compute_extremality_parameter</a> (curve, curves, steps=3, n=&quot;auto&quot;, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a9900481e2bab00284b7226a40b0586ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extremality parameter.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a9900481e2bab00284b7226a40b0586ff">More...</a><br /></td></tr>
<tr class="separator:a9900481e2bab00284b7226a40b0586ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac575b93d62c7da2923b165881c81004f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ac575b93d62c7da2923b165881c81004f">_compute_tube_property</a> (func, kwargs, curve, curves, steps, prop, use_user_data, recompute, version, full_output, update_file)</td></tr>
<tr class="memdesc:ac575b93d62c7da2923b165881c81004f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a property along a MOTT.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ac575b93d62c7da2923b165881c81004f">More...</a><br /></td></tr>
<tr class="separator:ac575b93d62c7da2923b165881c81004f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb6f1c03373951d1dee0f2888970b9a"><td class="memItemLeft" align="right" valign="top"><a id="a1eb6f1c03373951d1dee0f2888970b9a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a1eb6f1c03373951d1dee0f2888970b9a">_zeta</a> (c, num)</td></tr>
<tr class="memdesc:a1eb6f1c03373951d1dee0f2888970b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the invariant angle zeta. <br /></td></tr>
<tr class="separator:a1eb6f1c03373951d1dee0f2888970b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9faeb6d140c4abe5ce48a0da8bed987"><td class="memItemLeft" align="right" valign="top"><a id="aa9faeb6d140c4abe5ce48a0da8bed987"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#aa9faeb6d140c4abe5ce48a0da8bed987">_length_maps</a> (c, num, accurate)</td></tr>
<tr class="memdesc:aa9faeb6d140c4abe5ce48a0da8bed987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conversion mappings from parameterization to proper length. <br /></td></tr>
<tr class="separator:aa9faeb6d140c4abe5ce48a0da8bed987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6379b181fe80bd6d2887d1dae5f42d7"><td class="memItemLeft" align="right" valign="top"><a id="ab6379b181fe80bd6d2887d1dae5f42d7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ab6379b181fe80bd6d2887d1dae5f42d7">_constraints</a> (c, num, fd_order)</td></tr>
<tr class="memdesc:ab6379b181fe80bd6d2887d1dae5f42d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the constraints close to the curve. <br /></td></tr>
<tr class="separator:ab6379b181fe80bd6d2887d1dae5f42d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8a04b50b21e04b3730ddfca633a88"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a05a8a04b50b21e04b3730ddfca633a88">max_constraint_along_curve</a> (curve, points=None, x_padding=1, fd_order=None, full_output=False)</td></tr>
<tr class="memdesc:a05a8a04b50b21e04b3730ddfca633a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the maximum violation of the Hamiltonian constraint.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a05a8a04b50b21e04b3730ddfca633a88">More...</a><br /></td></tr>
<tr class="separator:a05a8a04b50b21e04b3730ddfca633a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05aad050e43c97977f34ad44ac8857ca"><td class="memItemLeft" align="right" valign="top"><a id="a05aad050e43c97977f34ad44ac8857ca"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a05aad050e43c97977f34ad44ac8857ca">_ingoing_exp</a> (c, Ns, eps)</td></tr>
<tr class="memdesc:a05aad050e43c97977f34ad44ac8857ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ingoing expansion along the curve. <br /></td></tr>
<tr class="separator:a05aad050e43c97977f34ad44ac8857ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834e3c1db1d33cc83d50fd35cbb99317"><td class="memItemLeft" align="right" valign="top"><a id="a834e3c1db1d33cc83d50fd35cbb99317"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a834e3c1db1d33cc83d50fd35cbb99317">_avg_ingoing_exp</a> (c, epsabs, limit)</td></tr>
<tr class="memdesc:a834e3c1db1d33cc83d50fd35cbb99317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average ingoing expansion across the MOTS. <br /></td></tr>
<tr class="separator:a834e3c1db1d33cc83d50fd35cbb99317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4200c9f92db01adec6dcf86bdbb6557d"><td class="memItemLeft" align="right" valign="top"><a id="a4200c9f92db01adec6dcf86bdbb6557d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a4200c9f92db01adec6dcf86bdbb6557d">_point_dists</a> (c)</td></tr>
<tr class="memdesc:a4200c9f92db01adec6dcf86bdbb6557d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinate distances of all collocation points. <br /></td></tr>
<tr class="separator:a4200c9f92db01adec6dcf86bdbb6557d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7025dc0ad6edb150bf3818b6ad98a1"><td class="memItemLeft" align="right" valign="top"><a id="a6c7025dc0ad6edb150bf3818b6ad98a1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a6c7025dc0ad6edb150bf3818b6ad98a1">_neck</a> (c, xtol, epsrel)</td></tr>
<tr class="memdesc:a6c7025dc0ad6edb150bf3818b6ad98a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and compute various neck properties for the inner common MOTS. <br /></td></tr>
<tr class="separator:a6c7025dc0ad6edb150bf3818b6ad98a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186e8ce85c75aa9740f4d2c02fc938aa"><td class="memItemLeft" align="right" valign="top"><a id="a186e8ce85c75aa9740f4d2c02fc938aa"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a186e8ce85c75aa9740f4d2c02fc938aa">_dist_top_bot</a> (c, rtol, allow_intersection, other_run, other_hname, out_dir)</td></tr>
<tr class="memdesc:a186e8ce85c75aa9740f4d2c02fc938aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the proper distance of the two individual MOTSs. <br /></td></tr>
<tr class="separator:a186e8ce85c75aa9740f4d2c02fc938aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15164ad058244ec01bb39a9b4f19cf5d"><td class="memItemLeft" align="right" valign="top"><a id="a15164ad058244ec01bb39a9b4f19cf5d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a15164ad058244ec01bb39a9b4f19cf5d">_z_dist_to_inner</a> (c, rtol, where, other_run, other_hname, out_dir)</td></tr>
<tr class="memdesc:a15164ad058244ec01bb39a9b4f19cf5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the proper distance of inner and individual MOTSs. <br /></td></tr>
<tr class="separator:a15164ad058244ec01bb39a9b4f19cf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ae418538b7d52243951aa9c759433"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a6c6ae418538b7d52243951aa9c759433">compute_tube_signature</a> (curve, curves, num=None, eps=1e-6, proper=True, steps=3, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a6c6ae418538b7d52243951aa9c759433"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signature of the world tube traced out by MOTSs.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a6c6ae418538b7d52243951aa9c759433">More...</a><br /></td></tr>
<tr class="separator:a6c6ae418538b7d52243951aa9c759433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5441666840b34d500baef6db36c79297"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a5441666840b34d500baef6db36c79297">compute_time_evolution_vector</a> (curve, curves, num=None, eps=1e-6, proper=True, steps=3, integral=True, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a5441666840b34d500baef6db36c79297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the time evolution vector along the world tube of MOTSs.  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a5441666840b34d500baef6db36c79297">More...</a><br /></td></tr>
<tr class="separator:a5441666840b34d500baef6db36c79297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037e55f31e65ac9ceb3751ce66a9a141"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a037e55f31e65ac9ceb3751ce66a9a141">compute_tev_divergence</a> (curve, curves, n=&quot;auto&quot;, steps=3, use_user_data=True, recompute=False, full_output=False, update_file=False)</td></tr>
<tr class="memdesc:a037e55f31e65ac9ceb3751ce66a9a141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate the divergence of the time evolution vector (TEV).  <a href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a037e55f31e65ac9ceb3751ce66a9a141">More...</a><br /></td></tr>
<tr class="separator:a037e55f31e65ac9ceb3751ce66a9a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af891ea19c7dca18dd7a1cef8458d6446"><td class="memItemLeft" align="right" valign="top"><a id="af891ea19c7dca18dd7a1cef8458d6446"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#af891ea19c7dca18dd7a1cef8458d6446">_get_aux_curve</a> (out_dir, hname, it, disp=True, verbose=False)</td></tr>
<tr class="memdesc:af891ea19c7dca18dd7a1cef8458d6446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an auxiliary curve for the given iteration. <br /></td></tr>
<tr class="separator:af891ea19c7dca18dd7a1cef8458d6446"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad57ec603e95646f3d911043d416b5739"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><b>ALL_PROPS</b></td></tr>
<tr class="separator:ad57ec603e95646f3d911043d416b5739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a223ca8475801a004b8ea0e2f49e38"><td class="memItemLeft" align="right" valign="top"><a id="a89a223ca8475801a004b8ea0e2f49e38"></a>
tuple&#160;</td><td class="memItemRight" valign="bottom"><b>NEED_ACTIVATION_PROPS</b> = ('stability_convergence', 'stability_convergence_null')</td></tr>
<tr class="separator:a89a223ca8475801a004b8ea0e2f49e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to compute and store physical properties of MOTS curves. </p>
<p>The functions in this module can be used to compute various properties of MOTSs like their area, signature, stability spectrum, etc. The actual calculation happens inside the curve classes themselves, but the methods here also store and update the stored results inside the curves' <code>user_data</code> dictionary. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aed5549743263a79a1f99b3c18193c322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5549743263a79a1f99b3c18193c322">&#9670;&nbsp;</a></span>_area()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._area </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the area for the curve. </p>
<p>The parameter <code>v</code> is ignored here and can be used to force recomputation of the area for curves already containing an area result. </p>

</div>
</div>
<a id="ad02432e6538cf5e0db3bcd83f2cd5678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad02432e6538cf5e0db3bcd83f2cd5678">&#9670;&nbsp;</a></span>_area_parts_individual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._area_parts_individual </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the area of different parts of an individual MOTS. </p>
<p>If the other individual MOTS does not intersect this MOTS, nothing is done and <code>None</code> is returned. If it does intersect, computes the area of the exterior and interior parts separately and returns an <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results.">numutils.IntegrationResults</a> object. The returned object's <code>info</code> dictionary contains an <code>intersection</code> key with the curve paramters of this (first) and the other (second) curve at which they intersect. </p>

</div>
</div>
<a id="a59b41123f3953afd9c6ed77ee93e391a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b41123f3953afd9c6ed77ee93e391a">&#9670;&nbsp;</a></span>_area_parts_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._area_parts_inner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bot_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute areas of different parts of the inner common MOTS. </p>
<p>Note that a precondition for this function is computation of the 'neck'. If a neck was actually found, computes the area of the upper and lower parts separately. The result is an <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results.">numutils.IntegrationResults</a> object with the two values and a <code>info</code> dictionary containing the used <code>neck</code> location.</p>
<p>If, in addition to a neck, the MOTS self-intersects, then it will also intersect the two individual MOTSs. The four intersection points (two parameters for the self-intersection, plus two for the intersection with the other MOTSs) together with the neck partition the curve into six sections, of which the area is computed separately. The resulting <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results.">numutils.IntegrationResults</a> object's <code>info</code> dictionary contains the location of all detected intersections. For the individual MOTSs, the second parameter in the values refers to the parameter of the individual MOTS at which this intersection happens. </p>

</div>
</div>
<a id="ac575b93d62c7da2923b165881c81004f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac575b93d62c7da2923b165881c81004f">&#9670;&nbsp;</a></span>_compute_tube_property()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._compute_tube_property </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a property along a MOTT. </p>
<p>The given <code>func</code> should be a callable that computes the property and returns e.g. a dictionary with the results. It is called as </p><pre class="fragment">result = func(curve, curves, **kwargs)
</pre><p> and the result is stored in the given <code>prop</code> property of the <code>curve.user_data</code> dictionary. The arguments in <code>kwargs</code> are also stored in the key <code>*_args</code>, where <code>*</code> is replaced with the property name. Note that we will add the following items to the stored arguments:</p><ul>
<li><code>steps</code>: the steps parameter</li>
<li><code>version</code>: the given version, used just to reject deprecated results</li>
<li><code>iterations</code>: slice numbers of MOTSs used to interpolate the tube</li>
</ul>
<p>The remaining parameters are explained in e.g. <a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008" title="Compute the xi vector.">compute_xi_vector()</a>. </p>

</div>
</div>
<a id="aebaf0d92180e9060f6d9533925a29c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebaf0d92180e9060f6d9533925a29c5e">&#9670;&nbsp;</a></span>_multipoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._multipoles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the first multipoles for the given curve. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results.">numutils.IntegrationResults</a> object containing the results with estimates of their accuracy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Curve representing the horizon. </td></tr>
    <tr><td class="paramname">max_n</td><td>Highest multipole to compute. It will compute the elements <code>0, 1, 2, ..., max_n</code> (i.e. <code>max_n+1</code> elements). </td></tr>
    <tr><td class="paramname">v</td><td>"Version". Can be used to force recomputation from the <code>do_prop()</code> call and determines if previous results are re-used.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>The strategy for computation is to first try to compute using the estimated curve's residual expansion as absolute tolerance. If this fails or produces integration warnings, the tolerance is successively increased and computation is retried. This is done separately for each multipole moment.</p>
<p>Previously computed multipole moments stored under the <code>'multipoles'</code> key in <code>c.user_data</code> will be re-used in case their version parameter equals the value of <code>v</code>. </p>

</div>
</div>
<a id="a75e84b1d34b0dc3a05c7f65184979f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e84b1d34b0dc3a05c7f65184979f2b">&#9670;&nbsp;</a></span>_shear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._shear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xatol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the shear and shear-square at Chebyshev collocation points. </p>
<p>The parameter <code>v</code> is ignored here and can be used to force recomputation of this property in case the code has changed. </p>

</div>
</div>
<a id="a7cc65b9f082355ce19bf49dbec0dc958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc65b9f082355ce19bf49dbec0dc958">&#9670;&nbsp;</a></span>_stability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._stability </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_terminate_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the stability spectrum for the curve. </p>
<p>The parameter <code>v</code> is ignored here and can be used to force recomputation of this property in case the code has changed. </p>

</div>
</div>
<a id="a1468ca1202bd38b0fbcd91cff006e86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1468ca1202bd38b0fbcd91cff006e86c">&#9670;&nbsp;</a></span>_stability_convergence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props._stability_convergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convergence_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the stability spectrum at different resolutions. </p>
<p>The parameter <code>v</code> can be used to force recomputation of this property in case the code has changed. Note that results from the <code>"stability"</code> property are reused only if the <code>v</code> parameters match. </p>

</div>
</div>
<a id="a9900481e2bab00284b7226a40b0586ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9900481e2bab00284b7226a40b0586ff">&#9670;&nbsp;</a></span>compute_extremality_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_extremality_parameter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the extremality parameter. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a19bd95251b6fa5eba926e9007588f961" title="Compute the extremality parameter.">curve.expcurve.ExpansionCurve.extremality_parameter()</a> for details.</p>
<p>The <code>n</code> parameter defines the fixed quadrature resolution for integrating. </p>

</div>
</div>
<a id="a21f8b604915b93a35bb43250aaedb657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f8b604915b93a35bb43250aaedb657">&#9670;&nbsp;</a></span>compute_props()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_props </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area_rtol</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_stability_values</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_terminate_index</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_multipole_n</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stability_convergence_factors</em> = <code>(0.2,&#160;0.4,&#160;0.6,&#160;0.8,&#160;0.9,&#160;1.1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>MOTS_map</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remove_invalid</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute properties and store them in the curve object. </p>
<p>All computed properties will be stored under the property's name in the curve's <code>user_data</code> dictionary. The arguments used for this computation are additionally stored under the key <code>prop_args</code>, where <code>prop</code> is the property name. Some properties produce extra output. This is then stored under <code>prop_extras</code>.</p>
<p>The properties that can be computed here are:</p><ul>
<li><b>length_maps</b>: Mappings from current parameterization to proper-length based parameterizations (see ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aa295e91e8fec272ea965605cd3a9ff69" title="Generate functions to map between curve parameter and proper length.">curve.basecurve.BaseCurve.proper_length_map()</a>). The value will be a dictionary with elements <code>length_map</code>, <code>inv_map</code>, <code>proper_length</code>, where the latter is the length of the curve in curved space. Note that the two functions will actually be NumericExpression objects (<a class="el" href="classmotsfinder_1_1exprs_1_1numexpr_1_1NumericExpression.html" title="Parent class for numeric expressions.">motsfinder.exprs.numexpr.NumericExpression</a>), so that <code>evaluator()</code> needs to be called to get actual callables.</li>
<li><b>constraints</b>: Compute the Hamiltonian (scalar) and momentum (vector) constraints on grid points close to the curve. The stored value will have the structure <code>dict(near_curve=dict(std=[x, ham, mom], proper=[x, ham, mom]))</code>. Here, <code>x</code> is the set of parameter values of the curve close to which the values are computed, <code>ham</code> are the Hamiltonian constraint values and <code>mom</code> the momentum ones. The difference between <code>std</code> and <code>proper</code> is that for <code>std</code>, the parameters are equidistant in curve parameter <code>lambda</code>, while for <code>proper</code> they are equidistant in the curve's proper length parameterization, though the stored <code>x</code> values are in the curve's current parameterization. This way, you can plot in the curve's proper length parameterization by taking the <code>x</code> values of <code>std</code> and values of <code>proper</code>.</li>
<li><b>ingoing_exp</b>: Expansion of the ingoing null normals. This is computed on a grid of points (in curve parameter space) the density of which is determined by the curve's resolution.</li>
<li><b>avg_ingoing_exp</b>: Average ingoing expansion, averaged over the MOTSs surface area.</li>
<li><b>area</b>: Surface area of the MOTS. This produces extra data (as explained above) containing information about the convergence of the integral.</li>
<li><b>ricci</b>: Ricci scalar computed on a grid of points with density dependent on the curve resolution. Additionally, the maximum absolute value of the Ricci scalar along the curve is found and stored. Inspect the actual data (dictionary) for details.</li>
<li><b>mean_curv</b>: Similar to <code>ricci</code>, but compute the trace of the extrinsic curvature of the MOTS in the slice instead.</li>
<li><b>curv2</b>: Similar to <code>mean_curv</code>, but compute the "square" \(k_{AB}k^{AB}\) of the MOTS's extrinsic curvature.</li>
<li><b>shear</b>: Compute the shear \(\sigma_{AB}\) and \(|\sigma|^2\). See also ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a92b72eda23af6809e3e8fe0efc629bea" title="Compute the shear of the MOTS at a point.">curve.expcurve.ExpansionCurve.shear()</a>. We compute the tensor and the square at a set of Gauss-Chebyshev collocation points. We use two times the curve's resolution as number of points. The result is that the minimum point density is slightly higher than the curve's collocation points (which are equidistant in lambda). The result is hence suitable to accurately expand the quantities into a Chebyshev series expression. Note that the collocation points are reversed in order to be increasing from 0 to pi. To create a Chebyshev series, use e.g.: <div class="fragment"><div class="line">shear2_values = curve.user_data[<span class="stringliteral">&#39;shear&#39;</span>][<span class="stringliteral">&#39;shear2&#39;</span>]</div>
<div class="line">f = Cheby([], domain=(0, np.pi))</div>
<div class="line">f.set_coefficients(shear2_values[::-1], lobatto=<span class="keyword">False</span>,</div>
<div class="line">                   physical_space=<span class="keyword">True</span>)</div>
</div><!-- fragment --></li>
<li><b>shear2_integral</b>: Compute the integral of the shear squared \(\sigma_{AB}\sigma^{AB}\) over the MOTS. See also ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a380a3fc19ab9398c2ac5a30068553444" title="Compute the integral of the shear squared.">curve.expcurve.ExpansionCurve.shear_square_integral()</a>.</li>
<li><b>shear_scalar</b>: Expand the complex shear scalar into spin 2 weighted spherical harmonics. For this, the MOTS is parameterized using the invariant angle <code>zeta</code>. For more information, see ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a2bebdf970199a51b83307470facf265c" title="Expand the shear scalar into spin 2 weighted spherical harmonics.">curve.expcurve.ExpansionCurve.expand_shear_scalar()</a>.</li>
<li><b>stability</b>, <b>stability_null</b>: Compute the spectrum of the stability operator. The number of eigenvalues returned depends on the curve's resolution, but at least 30 eigenvalues (by default) are computed. See also the <code>min_stability_values</code> parameter and the following property. The stored value is a tuple <code>principal, spectrum0</code>, where <code>principal</code> is the principal eigenvalue and <code>spectrum0</code> is the spectrum of the <code>m=0</code> angular mode. The full computed spectrum including higher modes is stored in the <code>stability_extras</code> dictionary under the <code>spectrum</code> key. Use <code>m_terminate_index</code> to control how many angular modes to consider. The <em><b>_null</b></em> variant of this property computes the spectrum w.r.t. the past outward null normal \(-k^\mu\) instead of the outward normal in the spatial slice.</li>
<li><b>stability_convergence</b>, <b>stability_convergence_null</b>: In addition to computing the stability spectrum above, recompute it at (by default) <code>0.2, 0.4, 0.6, 0.8, 0.9, 1.1</code> times the resolution used for the <code>"stability"</code> property. This allows analyzing convergence of the individual eigenvalues. As above, the <em><b>_null</b></em> variant is for the past outward null normal \(-k^\mu\).</li>
<li><b>neck</b>: Find the neck based on various criteria and compute various properties at this point, like proper circumference or proper distance to the z-axis. Only computed for a MOTS with <code>hname="inner"</code>.</li>
<li><b>dist_top_bot</b>: Proper distance (along the z-axis) of the two individual MOTSs. Only computed for a MOTS with <code>hname="bot"</code>.</li>
<li><b>z_dist_top_inner</b>: Proper distance of the highest point on the z-axis of the inner common MOTS and the top individual MOTS. Only compute for a MOTS with <code>hname="inner"</code>.</li>
<li><b>z_dist_bot_inner</b>: Proper distance of the lowest point on the z-axis of the inner common MOTS and the bottom individual MOTS. Only compute for a MOTS with <code>hname="inner"</code>.</li>
<li><b>point_dists</b>: Coordinate distances of the collocation points along the curve. May be useful to compare against the spatial coordinate resolution of the numerical grid.</li>
<li><b>area_parts</b>: In case <code>hname="bot"</code> or <code>"top"</code> and the top and bottom MOTSs intersect, compute separately the area of the non-intersecting part and the part lying inside the other MOTS. For <code>hname="inner"</code>, compute the parts before and after the <em>neck</em> separately. In case it self-intersects, find all the intersection points of the MOTS with itself and the top and bottom MOTSs and compute the area of each section, including splitting at the neck. If a result is found (i.e. the property's value is not <code>None</code>), the stored value will be a <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results.">numutils.IntegrationResults</a> object. Its <code>info</code> dictionary contains all splitting points. Sorting these gives you all the intervals of which the areas were computed.</li>
<li><b>multipoles</b>: Compute the first 10 multipole moments of the MOTS. The first and second moments are computed numerically even though these have analytically known values of <code>sqrt(pi)</code> and <code>0</code>, respectively. This allows comparison of the integration results with known values.</li>
<li><b>zeta</b>: Compute the invariant angle zeta. See ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a9f22b1b99aaf1965a8acee1648a16499" title="Numerically compute the invariant angle zeta.">curve.expcurve.ExpansionCurve.compute_zeta()</a>.</li>
</ul>
<p>Some properties are only computed for certain horizons. The horizon specific properties are:</p><ul>
<li>for <code>"top"</code>: <code>area_parts</code></li>
<li>for <code>"bot"</code>: <code>dist_top_bot</code>, <code>area_parts</code></li>
<li>for <code>"inner"</code>: <code>neck</code>, <code>z_dist_top_inner</code>, <code>z_dist_bot_inner</code>, <code>area_parts</code></li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hname</td><td>Name of horizon. Determines which kinds of properties are being computed (see above). </td></tr>
    <tr><td class="paramname">c</td><td>Curve representing the MOTS in axisymmetry. </td></tr>
    <tr><td class="paramname">props</td><td>Sequence of properties to compute (see above for the possible values). Use the string <code>"all"</code> to compute all possible properties. </td></tr>
    <tr><td class="paramname">area_rtol</td><td>Relative tolerance for the area integral. Setting this too low will result in integration warnings being produced and possibly underestimated residual errors. </td></tr>
    <tr><td class="paramname">min_stability_values</td><td>Minimum number of MOTS-stability eigenvalues to compute. The default is <code>30</code>. </td></tr>
    <tr><td class="paramname">m_terminate_index</td><td>Index of the eigenvalue of the <code>m=0</code> mode to use to as stopping criterion for the angular mode. Default is <code>30</code>. See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ae0b1390f65a098858013ad5ec3d755e7" title="Compute the stability parameter.">curve.expcurve.ExpansionCurve.stability_parameter()</a> for details. </td></tr>
    <tr><td class="paramname">stability_convergence_factors</td><td>Factors by which to multiply the resolution used for computing the stability spectrum. Each of the resulting lower or higher resolutions is used to compute the same spectrum, so that convergence of the individual eigenvalues can be examined. Defaults to <code>(0.2, 0.4, 0.6, 0.8, 0.9, 1.1)</code>. </td></tr>
    <tr><td class="paramname">verbosity</td><td>Whether to print progress information. </td></tr>
    <tr><td class="paramname">MOTS_map</td><td>Dictionary indicating from which runs auxiliary MOTSs should be loaded (used e.g. for the various distances). </td></tr>
    <tr><td class="paramname">fname</td><td>File name under which the MOTS is stored. This is used to infer the run name for finding auxiliary MOTSs (in case there is no entry in the <code>MOTS_map</code>) and for writing the file if <code>update_file=True</code>. </td></tr>
    <tr><td class="paramname">remove_invalid</td><td>Whether to check for and remove invalid data prior to recomputing it. This only affects data that is specified to being computed. This may be useful for updating data for which updated methods have been developed and a check for validity can be done. Default is <code>True</code>. </td></tr>
    <tr><td class="paramname">update_file</td><td>Whether to immediately write any computed results into the curve's data file (in case <code>use_user_data==True</code>). This is done in a way safe for being used when different processes work on different properties simultaneously, even across nodes in a compute cluster accessing the same file via a network file system. Note that the data in the supplied curve object will not reflect updates performed by other processes in the meantime. The file, however, will contain this data. You should hence not save the given curve to the file after calling this function, since you would potentially overwrite the updates of other processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a327c0f4ca7685eb1ff753605bd57f648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327c0f4ca7685eb1ff753605bd57f648">&#9670;&nbsp;</a></span>compute_surface_gravity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_surface_gravity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the surface gravity at a set of points on a MOTS. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adf576f119b60fc790caa871324a88dca" title="Compute a (slicing dependent) surface gravity.">curve.expcurve.ExpansionCurve.surface_gravity()</a> for details and the meaning of the first few parameters. The remaining parameters have the same meaning as in <a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008" title="Compute the xi vector.">compute_xi_vector()</a>. </p>

</div>
</div>
<a id="af6a480e2cc7d21fb81a2c23a66c30f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a480e2cc7d21fb81a2c23a66c30f4d">&#9670;&nbsp;</a></span>compute_surface_gravity_tev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_surface_gravity_tev </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the surface gravity with respect to the time evolution vector. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adf576f119b60fc790caa871324a88dca" title="Compute a (slicing dependent) surface gravity.">curve.expcurve.ExpansionCurve.surface_gravity()</a> for details and the meaning of the first few parameters. This uses the option <code>wrt="tev"</code>. The remaining parameters have the same meaning as in <a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008" title="Compute the xi vector.">compute_xi_vector()</a>.</p>
<p>The following properties are prerequisites for computing this one:</p><ul>
<li><code>length_maps</code></li>
<li><code>tev_divergence</code> </li>
</ul>

</div>
</div>
<a id="a037e55f31e65ac9ceb3751ce66a9a141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037e55f31e65ac9ceb3751ce66a9a141">&#9670;&nbsp;</a></span>compute_tev_divergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_tev_divergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate the divergence of the time evolution vector (TEV). </p>
<p>This is similar to the <code>"integral"</code> key of the results produced by <a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#a5441666840b34d500baef6db36c79297" title="Compute the time evolution vector along the world tube of MOTSs.">compute_time_evolution_vector()</a>. The main differences are:</p>
<ul>
<li>We use the TEV scaled with unity time component (see [1]).</li>
<li>We only compute the integral, not the vectors at another set of points.</li>
</ul>
<p>The result dictionary will have the form: </p><pre class="fragment">result = dict(integral=..., vectors=...)
</pre><p> The <code>vectors</code> key contains a list of TEV objects at the Gaussian quadrature points in intrinsic curve parameter space. From these, you can extract the coefficients <code>b</code> and <code>c</code> for the decomposition into the ingoing and outgoing null normals (scaled to have product -1). This allows the values to be re-used for other quantities and even integrals without recomputing all the vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>Curve representing the MOTS at the time slice we should compute at. </td></tr>
    <tr><td class="paramname">curves</td><td>All known curves before and after <code>curve</code> in the simulation. These are interpolated in time to find the evolution vector. May optionally contain <code>curve</code> (has no effect) and does not need to be sorted. </td></tr>
    <tr><td class="paramname">n</td><td>Order of the fixed quadrature integration (equal to the number of points at which the integrand is evaluated). The default <code>"auto"</code> will use twice the current curve's resolution, but at least 30 points. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves before and after this current curve to consider for interpolation. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">use_user_data</td><td>Whether to store the results in the curve's <code>user_data</code> dictionary and retrieve it from there instead of recomputing on subsequent calls. If the curve is saved afterwards, this data will persist. </td></tr>
    <tr><td class="paramname">recompute</td><td>Whether compute even if <code>use_user_data=True</code> and the data is already stored in <code>user_data</code>. This can be used to force an update of previously computed result. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the result dictionary and a boolean indicating whether computation was done (<code>True</code>) or data was taken from <code>user_data</code> (<code>False</code>). Default is <code>False</code>, i.e. only the result dictionary is returned. </td></tr>
    <tr><td class="paramname">update_file</td><td>Whether to immediately write any computed results into the curve's data file (in case <code>use_user_data==True</code>). This is done in a way safe for being used when different processes work on different properties simultaneously, even across nodes in a compute cluster accessing the same file via a network file system. Note that the data in the supplied curve object will not reflect updates performed by other processes in the meantime. The file, however, will contain this data. You should hence not save the given curve to the file after calling this function, since you would potentially overwrite the updates of other processes.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Booth, Ivan, and Stephen Fairhurst. "Extremality conditions for
     isolated and dynamical horizons." Physical review D 77.8 (2008): 084005. </p>

</div>
</div>
<a id="a5441666840b34d500baef6db36c79297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5441666840b34d500baef6db36c79297">&#9670;&nbsp;</a></span>compute_time_evolution_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_time_evolution_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>integral</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the time evolution vector along the world tube of MOTSs. </p>
<p>This function can compute the time evolution vectors at a grid of points along the MOTS. By default, it also integrates the divergence of the time evolution vector field over the MOTS. The result is returned as a dictionary with the following structure: </p><pre class="fragment">result = dict(
    vectors=...,
    pts=...,
    integral=dict(value=..., vectors=...),
)
</pre><p> Here, the two <code>vectors</code> keys contain lists of objects of type ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1TimeVectorData.html" title="MOTT time evolution vector.">curve.expcurve.TimeVectorData</a>. The <code>pts</code> key contains the proper length values at which the <code>vectors</code> are computed by default. If <code>proper=False</code>, then <code>pts</code> contains the parameter positions of the <code>vectors</code> instead. Both kinds of information in <code>pts</code> can be reconstructed easily from the TimeVectorData objects and the length maps (see ..curve.expcurve.ExpansionCurve.proper_length_map()), since the former contain their curve parameter value as an attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>Curve representing the MOTS at the time slice we should compute at. </td></tr>
    <tr><td class="paramname">curves</td><td>All known curves before and after <code>curve</code> in the simulation. These are interpolated in time to find the evolution vector. May optionally contain <code>curve</code> (has no effect) and does not need to be sorted. </td></tr>
    <tr><td class="paramname">num</td><td>Number of points to compute the vector at. Default is to use the curve's resolution but at least <code>200</code>. </td></tr>
    <tr><td class="paramname">eps</td><td>How close to approach the poles. Default is <code>1e-6</code>. </td></tr>
    <tr><td class="paramname">proper</td><td>Whether to distribute the points using the curve's proper length or its current parameterization. Default is <code>True</code>. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves before and after this current curve to consider for interpolation. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">integral</td><td>Compute the integral of the divergence of the time evolution vector over the MOTS. If <code>True</code> (default), this will add an <code>"integral"</code> key to the result dictionary containing a dictionary with the <code>value</code> of the integral and the <code>vectors</code> created during evaluation of the integrand (a list of ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1TimeVectorData.html" title="MOTT time evolution vector.">curve.expcurve.TimeVectorData</a> objects). Note that <code>num</code> has no effect on the computation of the integral. </td></tr>
    <tr><td class="paramname">use_user_data</td><td>Whether to store the results in the curve's <code>user_data</code> dictionary and retrieve it from there instead of recomputing on subsequent calls. If the curve is saved afterwards, this data will persist. </td></tr>
    <tr><td class="paramname">recompute</td><td>Whether compute even if <code>use_user_data=True</code> and the data is already stored in <code>user_data</code>. This can be used to force an update of previously computed result. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the result dictionary and a boolean indicating whether computation was done (<code>True</code>) or data was taken from <code>user_data</code> (<code>False</code>). Default is <code>False</code>, i.e. only the result dictionary is returned. </td></tr>
    <tr><td class="paramname">update_file</td><td>Whether to immediately write any computed results into the curve's data file (in case <code>use_user_data==True</code>). This is done in a way safe for being used when different processes work on different properties simultaneously, even across nodes in a compute cluster accessing the same file via a network file system. Note that the data in the supplied curve object will not reflect updates performed by other processes in the meantime. The file, however, will contain this data. You should hence not save the given curve to the file after calling this function, since you would potentially overwrite the updates of other processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a722645d144ac06d6d6fb9b4cd2ca018f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722645d144ac06d6d6fb9b4cd2ca018f">&#9670;&nbsp;</a></span>compute_timescale_T2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_timescale_T2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square of the timescale <code>T</code>. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a40079c05732aedfe1bc8544e7a5d2014" title="Compute the square of the timescale T.">curve.expcurve.ExpansionCurve.timescale_T2()</a> for details and the meaning of the first few parameters. The remaining parameters have the same meaning as in <a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008" title="Compute the xi vector.">compute_xi_vector()</a>.</p>
<p>The following properties are prerequisites for computing this one:</p><ul>
<li><code>length_maps</code></li>
<li><code>tev_divergence</code> </li>
</ul>

</div>
</div>
<a id="a8ad4ae9b8a355a4e7b5a881be7861865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad4ae9b8a355a4e7b5a881be7861865">&#9670;&nbsp;</a></span>compute_timescale_tau2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_timescale_tau2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>option</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square of the timescale <code>tau</code>. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd" title="Compute the square of the timescale tau.">curve.expcurve.ExpansionCurve.timescale_tau2()</a> for details and the meaning of the first few parameters. The remaining parameters have the same meaning as in <a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html#ae9264fc162e55b84a129f6a1a55ae008" title="Compute the xi vector.">compute_xi_vector()</a>.</p>
<p>The following properties are prerequisites for computing this one:</p><ul>
<li><code>length_maps</code></li>
<li><code>tev_divergence</code></li>
<li><code>surface_gravity_tev</code></li>
</ul>
<p>Note that for <code>option=4</code>, all curves in <code>curves</code> are also required to have data for the <code>tev_divergence</code> property. </p>

</div>
</div>
<a id="a6c6ae418538b7d52243951aa9c759433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ae418538b7d52243951aa9c759433">&#9670;&nbsp;</a></span>compute_tube_signature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_tube_signature </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signature of the world tube traced out by MOTSs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>The curve representing the MOTS at the time slice the signature of the MOTT should be computed. </td></tr>
    <tr><td class="paramname">curves</td><td>All known curves before and after <code>curve</code> in the simulation. These are interpolated to obtain the tangent of the coordinate along the tube. May optionally contain <code>curve</code> (has no effect) and does not need to be sorted. </td></tr>
    <tr><td class="paramname">num</td><td>Number of points to compute the signature at. Default is to use the curve's resolution but at least <code>200</code>. </td></tr>
    <tr><td class="paramname">eps</td><td>How close to approach the poles. Default is <code>1e-6</code>. </td></tr>
    <tr><td class="paramname">proper</td><td>Whether to distribute the points using the curve's proper length or its current parameterization. This will also be used to interpret the other <code>curves</code> of the tube, which is why setting this to <code>True</code> (default) is highly recommended. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves before and after this current curve to consider for interpolation. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">use_user_data</td><td>Whether to store the results in the curve's <code>user_data</code> dictionary and retrieve it from there instead of recomputing on subsequent calls. If the curve is saved afterwards, this data will persist. </td></tr>
    <tr><td class="paramname">recompute</td><td>Whether to recompute the signature even if <code>use_user_data=True</code> and the signature data is already there. This can be used to force an update of the stored signature data. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the result dictionary and a boolean indicating whether computation was done (<code>True</code>) or data was taken from <code>user_data</code> (<code>False</code>). Default is <code>False</code>, i.e. only the result dictionary is returned. </td></tr>
    <tr><td class="paramname">update_file</td><td>Whether to immediately write any computed results into the curve's data file (in case <code>use_user_data==True</code>). This is done in a way safe for being used when different processes work on different properties simultaneously, even across nodes in a compute cluster accessing the same file via a network file system. Note that the data in the supplied curve object will not reflect updates performed by other processes in the meantime. The file, however, will contain this data. You should hence not save the given curve to the file after calling this function, since you would potentially overwrite the updates of other processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99ab14427a974e47152e3a11866c1fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ab14427a974e47152e3a11866c1fa0">&#9670;&nbsp;</a></span>compute_xi2_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_xi2_integral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate xi^2 over the MOTS. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4e1dca9e2b825bc59677a54a64a07b7c" title="Compute the integral of the square of the xi vector.">curve.expcurve.ExpansionCurve.xi_square_integral()</a> for details.</p>
<p>The <code>n</code> parameter defines the fixed quadrature resolution for integrating. </p>

</div>
</div>
<a id="a031246bb126719783a4d07046679b4f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031246bb126719783a4d07046679b4f8">&#9670;&nbsp;</a></span>compute_xi_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_xi_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmax</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_lmax</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_lmax</em> = <code>512</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand xi_(ell) into spin weighted spherical harmonics. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adcf7be95664f324c9e9a2505b8b82a0a" title="Expand the xi vector into spin weighted spherical harmonics.">curve.expcurve.ExpansionCurve.expand_xi_scalar()</a> for details and the meaning of the parameters. </p>

</div>
</div>
<a id="ae9264fc162e55b84a129f6a1a55ae008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9264fc162e55b84a129f6a1a55ae008">&#9670;&nbsp;</a></span>compute_xi_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.compute_xi_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_user_data</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recompute</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>update_file</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the xi vector. </p>
<p>See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a83b04c959af2ec911236de04aab2bc6e" title="Compute the xi vector.">curve.expcurve.ExpansionCurve.xi_vector()</a> for details. We store all four quantities in the returned dictionary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>MOTS along which to compute the xi vector. </td></tr>
    <tr><td class="paramname">curves</td><td>Curves defining the MOTT. </td></tr>
    <tr><td class="paramname">steps</td><td>Number of surrounding MOTSs used for interpolating the tube. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">num</td><td>Number of equidistant points at which to compute the xi vector quantities along the MOTS. Note that the points will be equidistant in proper length. </td></tr>
    <tr><td class="paramname">eps</td><td>Distance to stay away from the domain boundaries 0 and pi (in scaled proper length coordinate). Default is <code>1e-6</code>. </td></tr>
    <tr><td class="paramname">use_user_data</td><td>Whether to store the results in the curve's <code>user_data</code> dictionary and retrieve it from there instead of recomputing on subsequent calls. If the curve is saved afterwards, this data will persist. </td></tr>
    <tr><td class="paramname">recompute</td><td>Whether compute even if <code>use_user_data=True</code> and the data is already stored in <code>user_data</code>. This can be used to force an update of previously computed result. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the result dictionary and a boolean indicating whether computation was done (<code>True</code>) or data was taken from <code>user_data</code> (<code>False</code>). Default is <code>False</code>, i.e. only the result dictionary is returned. </td></tr>
    <tr><td class="paramname">update_file</td><td>Whether to immediately write any computed results into the curve's data file (in case <code>use_user_data==True</code>). This is done in a way safe for being used when different processes work on different properties simultaneously, even across nodes in a compute cluster accessing the same file via a network file system. Note that the data in the supplied curve object will not reflect updates performed by other processes in the meantime. The file, however, will contain this data. You should hence not save the given curve to the file after calling this function, since you would potentially overwrite the updates of other processes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a8a04b50b21e04b3730ddfca633a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8a04b50b21e04b3730ddfca633a88">&#9670;&nbsp;</a></span>max_constraint_along_curve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.props.max_constraint_along_curve </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x_padding</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fd_order</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the maximum violation of the Hamiltonian constraint. </p>
<p>This computes the constraints on a set of grid points close to the given curve and returns the maximum value of the Hamiltonian constraint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>The curve along which to sample the constraint. </td></tr>
    <tr><td class="paramname">points</td><td>Number of points to sample at along the curve. If not specified, uses either the curve's <em>accurate</em> residual measuring points or (if these are not available) twice the resolution of the curve. May also be a list or tuple of parameter values in the range <code>[0,pi]</code>. </td></tr>
    <tr><td class="paramname">x_padding</td><td>How many grid points to stay away from the z-axis. Default is 1. </td></tr>
    <tr><td class="paramname">fd_order</td><td>Finite difference convergence order for computing derivatives at grid points. Default is to use the current stencil. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the evaluated constraints along with the maximum violation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad57ec603e95646f3d911043d416b5739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57ec603e95646f3d911043d416b5739">&#9670;&nbsp;</a></span>ALL_PROPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple ALL_PROPS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  (<span class="keywordtype">None</span>, <span class="stringliteral">&#39;none&#39;</span>, <span class="stringliteral">&#39;all&#39;</span>, <span class="stringliteral">&#39;length_maps&#39;</span>, <span class="stringliteral">&#39;constraints&#39;</span>, <span class="stringliteral">&#39;ingoing_exp&#39;</span>,</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;             <span class="stringliteral">&#39;avg_ingoing_exp&#39;</span>, <span class="stringliteral">&#39;area&#39;</span>, <span class="stringliteral">&#39;ricci&#39;</span>, <span class="stringliteral">&#39;mean_curv&#39;</span>, <span class="stringliteral">&#39;curv2&#39;</span>,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;             <span class="stringliteral">&#39;shear&#39;</span>, <span class="stringliteral">&#39;shear2_integral&#39;</span>, <span class="stringliteral">&#39;shear_scalar&#39;</span>, <span class="stringliteral">&#39;stability&#39;</span>,</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;             <span class="stringliteral">&#39;stability_null&#39;</span>, <span class="stringliteral">&#39;stability_convergence&#39;</span>,</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;             <span class="stringliteral">&#39;stability_convergence_null&#39;</span>, <span class="stringliteral">&#39;neck&#39;</span>, <span class="stringliteral">&#39;dist_top_bot&#39;</span>,</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;             <span class="stringliteral">&#39;z_dist_top_inner&#39;</span>, <span class="stringliteral">&#39;z_dist_bot_inner&#39;</span>, <span class="stringliteral">&#39;point_dists&#39;</span>,</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;             <span class="stringliteral">&#39;area_parts&#39;</span>, <span class="stringliteral">&#39;multipoles&#39;</span>, <span class="stringliteral">&#39;zeta&#39;</span>)</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym.html">axisym</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html">trackmots</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html">props</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
