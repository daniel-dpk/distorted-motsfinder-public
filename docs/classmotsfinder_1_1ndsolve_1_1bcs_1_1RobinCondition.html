<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: RobinCondition Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   &#160;<span id="projectnumber">v1.4-3-g4c3aa7c</span>
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RobinCondition Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>General Robin-type boundary condition.  
 <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for RobinCondition:</div>
<div class="dyncontent">
<div class="center"><img src="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition__inherit__graph.png" border="0" usemap="#aRobinCondition_inherit__map" alt="Inheritance graph"/></div>
<map name="aRobinCondition_inherit__map" id="aRobinCondition_inherit__map">
<area shape="rect" title="General Robin&#45;type boundary condition." alt="" coords="97,80,218,107"/>
<area shape="rect" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1DirichletCondition.html" title="A Dirichlet boundary condition." alt="" coords="5,155,144,181"/>
<area shape="rect" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1NeumannCondition.html" title="A Neumann boundary condition." alt="" coords="168,155,315,181"/>
<area shape="rect" title=" " alt="" coords="126,5,189,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a33686019eec5ce71f61842f59109191d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a33686019eec5ce71f61842f59109191d">__init__</a> (self, x, alpha, beta, value, corners=True, add_rows=False)</td></tr>
<tr class="memdesc:a33686019eec5ce71f61842f59109191d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define the boundary condition.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a33686019eec5ce71f61842f59109191d">More...</a><br /></td></tr>
<tr class="separator:a33686019eec5ce71f61842f59109191d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4311119d69a74e5bdc98549e345210d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a4311119d69a74e5bdc98549e345210d6">impose</a> (self, basis, L, f, blocked_indices, L_done=False, f_done=False, use_mp=False)</td></tr>
<tr class="memdesc:a4311119d69a74e5bdc98549e345210d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impose the condition by modifying the operator and inhomogeneity.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a4311119d69a74e5bdc98549e345210d6">More...</a><br /></td></tr>
<tr class="separator:a4311119d69a74e5bdc98549e345210d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a796ce5ef31ccb5c060b346dd9d47fa11"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a796ce5ef31ccb5c060b346dd9d47fa11">_replace_row</a> (self, ctx, mat, n, row)</td></tr>
<tr class="memdesc:a796ce5ef31ccb5c060b346dd9d47fa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a row of a matrix by a different row.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a796ce5ef31ccb5c060b346dd9d47fa11">More...</a><br /></td></tr>
<tr class="separator:a796ce5ef31ccb5c060b346dd9d47fa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecd6bdf94830ea45d2db59a60350a8a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a4ecd6bdf94830ea45d2db59a60350a8a">_append_rows</a> (self, mat, rows)</td></tr>
<tr class="memdesc:a4ecd6bdf94830ea45d2db59a60350a8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add rows to a NumPy or mpmath matrix.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a4ecd6bdf94830ea45d2db59a60350a8a">More...</a><br /></td></tr>
<tr class="separator:a4ecd6bdf94830ea45d2db59a60350a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e45b35d66777a24f720e25a760f3f78"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a9e45b35d66777a24f720e25a760f3f78">_find_free_index</a> (self, i, max_i, blocked)</td></tr>
<tr class="memdesc:a9e45b35d66777a24f720e25a760f3f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an index of a row we should replace next.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a9e45b35d66777a24f720e25a760f3f78">More...</a><br /></td></tr>
<tr class="separator:a9e45b35d66777a24f720e25a760f3f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588eef5d81689308aec67d8691e1956c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a588eef5d81689308aec67d8691e1956c">_transform</a> (self, x, basis)</td></tr>
<tr class="memdesc:a588eef5d81689308aec67d8691e1956c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a point from window to domain space.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a588eef5d81689308aec67d8691e1956c">More...</a><br /></td></tr>
<tr class="separator:a588eef5d81689308aec67d8691e1956c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c661162bf7bc2f98edbc31bc505e216"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a6c661162bf7bc2f98edbc31bc505e216">_filter_corners</a> (self, pts, basis)</td></tr>
<tr class="memdesc:a6c661162bf7bc2f98edbc31bc505e216"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generator to return only those points not on corner positions.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a6c661162bf7bc2f98edbc31bc505e216">More...</a><br /></td></tr>
<tr class="separator:a6c661162bf7bc2f98edbc31bc505e216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9173ecb42a0ee7af824a71f9180b12"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a7a9173ecb42a0ee7af824a71f9180b12">_get_points</a> (self, basis)</td></tr>
<tr class="memdesc:a7a9173ecb42a0ee7af824a71f9180b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the row indices and points to impose the condition at.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a7a9173ecb42a0ee7af824a71f9180b12">More...</a><br /></td></tr>
<tr class="separator:a7a9173ecb42a0ee7af824a71f9180b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b205ef1af22716eaa291b0a5c2340d6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a5b205ef1af22716eaa291b0a5c2340d6">_get_point_candidates</a> (self, basis)</td></tr>
<tr class="memdesc:a5b205ef1af22716eaa291b0a5c2340d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a list of all points at which to impose the condition.  <a href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a5b205ef1af22716eaa291b0a5c2340d6">More...</a><br /></td></tr>
<tr class="separator:a5b205ef1af22716eaa291b0a5c2340d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae893537683b47115916233eb7a2fe63e"><td class="memItemLeft" align="right" valign="top"><a id="ae893537683b47115916233eb7a2fe63e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#ae893537683b47115916233eb7a2fe63e">_x</a></td></tr>
<tr class="memdesc:ae893537683b47115916233eb7a2fe63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where to impose the condition. <br /></td></tr>
<tr class="separator:ae893537683b47115916233eb7a2fe63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae850f5bd9d70de384c0a06b2169921e4"><td class="memItemLeft" align="right" valign="top"><a id="ae850f5bd9d70de384c0a06b2169921e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#ae850f5bd9d70de384c0a06b2169921e4">_alpha</a></td></tr>
<tr class="memdesc:ae850f5bd9d70de384c0a06b2169921e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable or value multiplying the function. <br /></td></tr>
<tr class="separator:ae850f5bd9d70de384c0a06b2169921e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a3e9d160ea64b352edecf742dadf8"><td class="memItemLeft" align="right" valign="top"><a id="a351a3e9d160ea64b352edecf742dadf8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a351a3e9d160ea64b352edecf742dadf8">_beta</a></td></tr>
<tr class="memdesc:a351a3e9d160ea64b352edecf742dadf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable or value multiplying the function's first derivative. <br /></td></tr>
<tr class="separator:a351a3e9d160ea64b352edecf742dadf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1f97bce4940e05fc20e6f5fbc35934"><td class="memItemLeft" align="right" valign="top"><a id="a5f1f97bce4940e05fc20e6f5fbc35934"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a5f1f97bce4940e05fc20e6f5fbc35934">_value</a></td></tr>
<tr class="memdesc:a5f1f97bce4940e05fc20e6f5fbc35934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callable or value the function + derivative (as specified by <code>alpha</code> and <code>beta</code>) should attain. <br /></td></tr>
<tr class="separator:a5f1f97bce4940e05fc20e6f5fbc35934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba4ab3c11c846b9fa519f0778896d08"><td class="memItemLeft" align="right" valign="top"><a id="a7ba4ab3c11c846b9fa519f0778896d08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a7ba4ab3c11c846b9fa519f0778896d08">_corners</a></td></tr>
<tr class="memdesc:a7ba4ab3c11c846b9fa519f0778896d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to include the corners/ends for the 2D case. <br /></td></tr>
<tr class="separator:a7ba4ab3c11c846b9fa519f0778896d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab33e7c9974bd0d6b65a7a0add602b3"><td class="memItemLeft" align="right" valign="top"><a id="a7ab33e7c9974bd0d6b65a7a0add602b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a7ab33e7c9974bd0d6b65a7a0add602b3">_add_rows</a></td></tr>
<tr class="memdesc:a7ab33e7c9974bd0d6b65a7a0add602b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to add more equations or replace existing ones. <br /></td></tr>
<tr class="separator:a7ab33e7c9974bd0d6b65a7a0add602b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9b365a416c89920c0197140548bee0"><td class="memItemLeft" align="right" valign="top"><a id="acd9b365a416c89920c0197140548bee0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#acd9b365a416c89920c0197140548bee0">_dim</a></td></tr>
<tr class="memdesc:acd9b365a416c89920c0197140548bee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-determined dimension of the problem. <br /></td></tr>
<tr class="separator:acd9b365a416c89920c0197140548bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3d6dc5fa1be743fa8e1bf843f1c601"><td class="memItemLeft" align="right" valign="top"><a id="adf3d6dc5fa1be743fa8e1bf843f1c601"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#adf3d6dc5fa1be743fa8e1bf843f1c601">_idx</a></td></tr>
<tr class="memdesc:adf3d6dc5fa1be743fa8e1bf843f1c601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Axis along which to impose the condition. <br /></td></tr>
<tr class="separator:adf3d6dc5fa1be743fa8e1bf843f1c601"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>General Robin-type boundary condition. </p>
<p>This class represents general Dirichlet, Neumann, or mixed (Robin) type boundary conditions suitable for 1D and 2D problems.</p>
<p>After you have constructed such a condition object, it is used as an argument for the spectral solver (ndsolve() or NDSolver) in order to be imposed in the resulting matrix equation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a33686019eec5ce71f61842f59109191d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33686019eec5ce71f61842f59109191d">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>corners</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>add_rows</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define the boundary condition. </p>
<pre class="fragment">   The general form of this boundary condition is \f[
       \alpha(x) u(x) + \beta(x) \partial_\nu u(x) = g(x),
   \f]
   where \f$ x \f$ is specified by the `x` argument (see below) and
   \f$ g(x) \f$ is given by `value`. The derivative of `u` is taken to be
   perpendicular to the direction of the line specified by `x`, i.e. it
   will be the outward pointing normal at the upper boundary and inward
   pointing normal at the lower boundary of the respective dimension.

   In 1D, we simply have \f$ \partial_\nu u(x) = u'(x) \f$.

   For a pure Dirichlet condition, set ``alpha=1, beta=0`` and for a pure
   Neumann condition ``alpha=0, beta=1``.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>(float or tuple/list) Value at which to impose the condition. For 1D problems, this should simply be the <code>x</code>-value at which to impose the condition. For 2D problems, it should be a tuple/list specifying the <code>x=const</code> or <code>y=const</code> line to impose the condition at. For example, to define the line <code>x=5</code>, this argument should be set to <code>x=(5.0, None)</code>. </td></tr>
    <tr><td class="paramname">alpha</td><td>(float or callable) Coefficient of the 'Dirichlet' part of the condition (see above). </td></tr>
    <tr><td class="paramname">beta</td><td>(float or callable) Coefficient of the 'Neumann' part of the condition (see above). </td></tr>
    <tr><td class="paramname">value</td><td>(float or callable) Value of the condition (see above). </td></tr>
    <tr><td class="paramname">corners</td><td>(boolean, optional) Only relevant in 2D. If <code>True</code> (default), apply the condition at all collocation points along the specified axis including the boundary ones. If <code>False</code>, the boundary points are excluded. This may be important to make the resulting matrix equation a full-rank equation, since imposing multiple conditions at the same points (e.g. the corners) may make the matrix singular. </td></tr>
    <tr><td class="paramname">add_rows</td><td>(boolean, optional) Whether to add or replace rows in the matrix and the inhomogeneity vector to impose the condition. Adding rows will create a non-square matrix, i.e. the system may become overdetermined and must be solved using e.g. a least squares method such as <code>scipy.lstsq</code>. Default is <code>False</code>, i.e. to replace rows, which is what you should do to get a determined system of equations. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4ecd6bdf94830ea45d2db59a60350a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ecd6bdf94830ea45d2db59a60350a8a">&#9670;&nbsp;</a></span>_append_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _append_rows </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add rows to a NumPy or mpmath matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>NumPy or mpmath matrix to add the rows to. </td></tr>
    <tr><td class="paramname">rows</td><td>List of rows, each being an iterable containing the respective row's values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c661162bf7bc2f98edbc31bc505e216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c661162bf7bc2f98edbc31bc505e216">&#9670;&nbsp;</a></span>_filter_corners()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _filter_corners </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generator to return only those points not on corner positions. </p>
<p>Does nothing (i.e. no filtering) in the 1D case. </p>

</div>
</div>
<a id="a9e45b35d66777a24f720e25a760f3f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e45b35d66777a24f720e25a760f3f78">&#9670;&nbsp;</a></span>_find_free_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _find_free_index </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an index of a row we should replace next. </p>
<pre class="fragment">   This is called after the row to replace has been determined. It is
   responsible for checking that we don't replace a blocked row, i.e. one
   that already has a condition imposed.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>Desired row that should be replaced if it is free. </td></tr>
    <tr><td class="paramname">max_i</td><td>Maximum valid row index (total number of rows minus 1). </td></tr>
    <tr><td class="paramname">blocked</td><td>List of row indices that are blocked and cannot replaced. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b205ef1af22716eaa291b0a5c2340d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b205ef1af22716eaa291b0a5c2340d6">&#9670;&nbsp;</a></span>_get_point_candidates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _get_point_candidates </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collect a list of all points at which to impose the condition. </p>
<p>Note that this will include the corners irrespective of the <code>corner</code> setting. The caller has to filter the corners out if desired.</p>
<p>The result will be a list of 2-tuples containing the optimal row index (as detailed below) and exact point to impose a condition at. In the 1D case, this list will only have one element (we want to impose the condition at one point only), whereas in the 2D case, we want to impose the condition along one axis, i.e. there will be multiple points.</p>
<p>The points are chosen in the following way:</p><ul>
<li>In the 1D case, we search for the collocation point closest to the point we want to impose the condition at and use that point's index (which will also be the row index in the operator matrix at which the equation has been evaluated for that collocation point). The point will be the one to impose the condition at, i.e. not necessarily the collocation point but it should be close to it.</li>
<li>In the 2D case, we first find the closest collocation point of the 1D basis for the fixed axis and then combine the fixed axis' value with all collocation points of the free axis to get a "line" of points to impose the condition at.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>A list of 2-tuples, each containing one index and one 1D or 2D point. The index will indicate the row in the matrix to replace with the condition evaluated at the returned point. The points will be returned in the native domain of the basis. </dd></dl>

</div>
</div>
<a id="a7a9173ecb42a0ee7af824a71f9180b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9173ecb42a0ee7af824a71f9180b12">&#9670;&nbsp;</a></span>_get_points()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _get_points </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the row indices and points to impose the condition at. </p>
<p>See <a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html#a5b205ef1af22716eaa291b0a5c2340d6" title="Collect a list of all points at which to impose the condition.">_get_point_candidates()</a> for more details. </p>

</div>
</div>
<a id="a796ce5ef31ccb5c060b346dd9d47fa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a796ce5ef31ccb5c060b346dd9d47fa11">&#9670;&nbsp;</a></span>_replace_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _replace_row </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace a row of a matrix by a different row. </p>
<pre class="fragment">   This is a convenience function that handles the case of a NumPy matrix
   and that of an `mpmath` matrix.
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td><code>mp</code> or <code>fp</code>, the mpmath context to use if not a NumPy matrix. </td></tr>
    <tr><td class="paramname">mat</td><td>The NumPy or mpmath matrix to replace a row in. </td></tr>
    <tr><td class="paramname">n</td><td>The row index of the row to replace. </td></tr>
    <tr><td class="paramname">row</td><td>The new data to write into the row. May be a <code>list</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a588eef5d81689308aec67d8691e1956c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a588eef5d81689308aec67d8691e1956c">&#9670;&nbsp;</a></span>_transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _transform </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transform a point from window to domain space. </p>
<p>For multi-dimensional points, only the active dimension is returned, that is, this method always returns a floating type. </p>

</div>
</div>
<a id="a4311119d69a74e5bdc98549e345210d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4311119d69a74e5bdc98549e345210d6">&#9670;&nbsp;</a></span>impose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def impose </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>blocked_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>L_done</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f_done</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_mp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Impose the condition by modifying the operator and inhomogeneity. </p>
<pre class="fragment">   This should be called only during the solving process when the
   operator matrix `L` and inhomogeneity vector `f` have been built. The
   caller should supply the indices of rows (via `blocked_indices`) on
   which previous conditions have been placed to avoid overwriting them
   with the new conditions. The indices used here will be added to this
   list (i.e. the caller only needs to repeatedly supply this list,
   starting with an empty one).
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">basis</td><td>Spectral basis used during solving. </td></tr>
    <tr><td class="paramname">L</td><td>Fully populated operator matrix. </td></tr>
    <tr><td class="paramname">f</td><td>Inhomogeneity vector. </td></tr>
    <tr><td class="paramname">blocked_indices</td><td>List which is updated by this method to store which equations have been replaced (in order not to replace a condition in later calls). </td></tr>
    <tr><td class="paramname">L_done</td><td>Whether the operator matrix <code>L</code> has already been processed and should be left untouched. May be useful if caching of matrices with conditions already imposed is done, which may speed up computation significantly. </td></tr>
    <tr><td class="paramname">f_done</td><td>Whether the inhomogeneity has already been processed and should be left untouched. Might be useful when re-using the same inhomogeneity (and same basis) to solve the same equation with different boundary conditions. </td></tr>
    <tr><td class="paramname">use_mp</td><td>Whether to use arbitrary precision math operations (<code>True</code>) or faster floating point precision operations (<code>False</code>, default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>motsfinder/ndsolve/bcs.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1ndsolve.html">ndsolve</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1ndsolve_1_1bcs.html">bcs</a></li><li class="navelem"><a class="el" href="classmotsfinder_1_1ndsolve_1_1bcs_1_1RobinCondition.html">RobinCondition</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
