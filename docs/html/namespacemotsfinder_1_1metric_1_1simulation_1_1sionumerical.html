<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: motsfinder.metric.simulation.sionumerical Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">motsfinder.metric.simulation.sionumerical Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Numerical helper functions for interpolation and differentiation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1metric_1_1simulation_1_1sionumerical_1_1SioConstraintAnalyzer.html">SioConstraintAnalyzer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aacd55fd277e945072b2ba6a7a10e52b2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#aacd55fd277e945072b2ba6a7a10e52b2">interpolate</a> (mat, coords, linear=False)</td></tr>
<tr class="memdesc:aacd55fd277e945072b2ba6a7a10e52b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a (small) matrix patch, interpolate a value between grid points.  <a href="#aacd55fd277e945072b2ba6a7a10e52b2">More...</a><br /></td></tr>
<tr class="separator:aacd55fd277e945072b2ba6a7a10e52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5ff7dd9c6f2ba277689842a903e24d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#a2d5ff7dd9c6f2ba277689842a903e24d">_interp1d</a> (arr, coord, linear)</td></tr>
<tr class="memdesc:a2d5ff7dd9c6f2ba277689842a903e24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform 1-D interpolation of a sequence of values.  <a href="#a2d5ff7dd9c6f2ba277689842a903e24d">More...</a><br /></td></tr>
<tr class="separator:a2d5ff7dd9c6f2ba277689842a903e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86cd442ce3fac2c3917ee117586e032"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#ae86cd442ce3fac2c3917ee117586e032">_diff_4th_order_xz</a> (mat, region, dx, dz, diff=1)</td></tr>
<tr class="memdesc:ae86cd442ce3fac2c3917ee117586e032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform 4th order accurate FD differentiation on specified grid points.  <a href="#ae86cd442ce3fac2c3917ee117586e032">More...</a><br /></td></tr>
<tr class="separator:ae86cd442ce3fac2c3917ee117586e032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324d1c2d18016fe6c9e9ef54e0ad343f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#a324d1c2d18016fe6c9e9ef54e0ad343f">eval_sym_axisym_matrix</a> (comp_funcs, lower_orders, point, interp=True, diff=0)</td></tr>
<tr class="memdesc:a324d1c2d18016fe6c9e9ef54e0ad343f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate (derivatives of) a symmetric tensor field at a point.  <a href="#a324d1c2d18016fe6c9e9ef54e0ad343f">More...</a><br /></td></tr>
<tr class="separator:a324d1c2d18016fe6c9e9ef54e0ad343f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19876bd9dc0593e3bbb9c0f671fd33db"><td class="memItemLeft" align="right" valign="top"><a id="a19876bd9dc0593e3bbb9c0f671fd33db"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#a19876bd9dc0593e3bbb9c0f671fd33db">_sym3x3</a> (T)</td></tr>
<tr class="memdesc:a19876bd9dc0593e3bbb9c0f671fd33db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a 3x3 matrix by replacing the lower-left three components. <br /></td></tr>
<tr class="separator:a19876bd9dc0593e3bbb9c0f671fd33db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab6c543453bdda66a48760da444fc7d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#a9ab6c543453bdda66a48760da444fc7d">lrange</a> (args)</td></tr>
<tr class="memdesc:a9ab6c543453bdda66a48760da444fc7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper to call <code>list(range(...))</code>.  <a href="#a9ab6c543453bdda66a48760da444fc7d">More...</a><br /></td></tr>
<tr class="separator:a9ab6c543453bdda66a48760da444fc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Numerical helper functions for interpolation and differentiation. </p>
<p>See package docstring of <code>motsfinder/metric/simulation/__init__.py</code> for more general information and examples. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ae86cd442ce3fac2c3917ee117586e032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86cd442ce3fac2c3917ee117586e032">&#9670;&nbsp;</a></span>_diff_4th_order_xz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.simulation.sionumerical._diff_4th_order_xz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diff</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform 4th order accurate FD differentiation on specified grid points. </p>
<p>Given a matrix <code>mat</code> containing values on a grid, this performs first or second order finite difference (FD) differentiation for each grid point in the given <code>region</code> using 5-point stencils.</p>
<p>Note that only <code>x</code> and <code>z</code> (and possibly mixed) derivatives are computed, even though <code>mat</code> needs to have three axes.</p>
<dl class="section return"><dt>Returns</dt><dd>For <code>diff=1</code>, two matrices of the shape of the given region, the first containing the x-derivatives and the second the z-derivatives. For <code>diff=2</code>, three matrices containing the <code>xx</code>, <code>zz</code> and <code>xz</code> partial derivatives of the <code>region</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix with the values to use. Must have at least 2 additional points in the first and third axes on the borders of the given <code>region</code>. </td></tr>
    <tr><td class="paramname">region</td><td>Region of grid points at which to compute the derivatives. Should consist of three iterables of indices, the tensor product of which defines the actual set of indices in the region. </td></tr>
    <tr><td class="paramname">dx</td><td>Physical distance of grid points in coordinate space along first axis. </td></tr>
    <tr><td class="paramname">dz</td><td>Physical distance of grid points in coordinate space along third axis. </td></tr>
    <tr><td class="paramname">diff</td><td>Derivative order. Should be <code>1</code> or <code>2</code>. Default is <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d5ff7dd9c6f2ba277689842a903e24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5ff7dd9c6f2ba277689842a903e24d">&#9670;&nbsp;</a></span>_interp1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.simulation.sionumerical._interp1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform 1-D interpolation of a sequence of values. </p>
<p>This takes a 1-D sequence of values, <code>arr</code>, and interpolates a value in relative index space at <code>coord</code> as described in <a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html#aacd55fd277e945072b2ba6a7a10e52b2" title="Given a (small) matrix patch, interpolate a value between grid points. ">interpolate()</a>. The order of the interpolating polynomial is determined by the length of the sequence. The result is a floating point value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>1-D array-like with values. </td></tr>
    <tr><td class="paramname">coord</td><td>Float indicating the coordinate in relative index space at which to interpolate. </td></tr>
    <tr><td class="paramname">linear</td><td>If <code>True</code>, perform simple linear interpolation instead of Lagrange interpolation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a324d1c2d18016fe6c9e9ef54e0ad343f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324d1c2d18016fe6c9e9ef54e0ad343f">&#9670;&nbsp;</a></span>eval_sym_axisym_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.simulation.sionumerical.eval_sym_axisym_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lower_orders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>interp</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate (derivatives of) a symmetric tensor field at a point. </p>
<p>This takes the six independent component functions of the <code>xx</code>, <code>xy</code>, <code>xz</code>, <code>yy</code>, <code>yz</code>, and <code>zz</code> components (in that order) of a tensor field <code>T</code>. These should be SioDataPatch objects. It then computes the derivatives of the requested order <code>diff</code> in all three coordinate directions using the axisymmetry of the tensor to infer the y-derivatives from the x-derivative.</p>
<p>In order to compute derivatives, all lower order derivatives are required (including order 0). These have to be supplied as positional arguments after the list of component functions.</p>
<dl class="section return"><dt>Returns</dt><dd>For <code>diff=0</code>, returns the 3x3 matrix representing <code>T</code> interpolated at <code>point</code>, i.e. <img class="formulaInl" alt="$T_{ij}$" src="form_351.png"/>. If <code>diff=1</code>, returns <code>dT[i,j,k]</code>, where the indices mean <img class="formulaInl" alt="$\partial_i T_{jk}$" src="form_352.png"/> and if <code>diff=2</code>, returns <code>ddT[i,j,k,l]</code> with indices <img class="formulaInl" alt="$\partial_i\partial_j T_{kl}$" src="form_353.png"/>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp_funcs</td><td>An iterable of the six independent component functions (SioDataPatch) of the tensor field. </td></tr>
    <tr><td class="paramname">*lower_orders</td><td>Further positional arguments supplying the lower order derivatives. For <code>diff=0</code>, none should be supplied. For <code>diff=1</code>, one argument, <code>T</code> itself, should be given. For <code>diff=2</code>, <code>T</code> and <code>dT</code> should be given in that order. </td></tr>
    <tr><td class="paramname">point</td><td>The point at which to compute. </td></tr>
    <tr><td class="paramname">interp</td><td>If <code>False</code>, don't interpolate at all and instead snap <code>point</code> to the closest grid point and evaluate there. Default is <code>True</code>. </td></tr>
    <tr><td class="paramname">diff</td><td>Derivative order to compute. Default is <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>Based on the considerations in [1], the y-derivatives of tensor field components in the xz-plane can be computed by differentiating eq. (7) in [1] w.r.t. <code>y</code> and evaluating at <code>y=0</code>. The results are </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} (\partial_y T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} -2T_{xy} &amp; T_{xx}-T_{yy} &amp; -T_{yz} \\ T_{xx}-T_{yy} &amp; 2T_{xy} &amp; T_{xz} \\ -T_{yz} &amp; T_{xz} &amp; 0 \end{array}\right) \\ (\partial_x\partial_y T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} -2T_{xy,x} + \frac{2 T_{xy}}{x} &amp; T_{xx,x} - \frac{T_{xx}}{x} - T_{yy,x} + \frac{T_{yy}}{x} &amp; - T_{yz,x} + \frac{T_{yz}}{x} \\ T_{xx,x}-T_{yy,x}-\frac{T_{xx}}{x} + \frac{T_{yy}}{x} &amp; 2 T_{xy,x} - \frac{2 T_{xy}}{x} &amp; T_{xz,x} - \frac{T_{xz}}{x} \\ -T_{yz,x}+\frac{T_{yz}}{x} &amp; T_{xz,x} - \frac{T_{xz}}{x} &amp; 0 \end{array}\right) \\ (\partial_y\partial_y T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} T_{xx,x}-\frac{2 T_{xx}}{x} + \frac{2 T_{yy}}{x} &amp; T_{xy,x} - \frac{4 T_{xy}}{x} &amp; T_{xz,x} - \frac{T_{xz}}{x}\\ T_{xy,x}-\frac{4 T_{xy}}{x} &amp; \frac{2 T_{xx}}{x} + T_{yy,x} - \frac{2 T_{yy}}{x} &amp; T_{yz,x} - \frac{T_{yz}}{x}\\ T_{xz,x}-\frac{T_{xz}}{x} &amp; T_{yz,x} - \frac{T_{yz}}{x} &amp; T_{zz,x} \end{array}\right) \\ (\partial_y\partial_z T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} -2 T_{xy,z} &amp; T_{xx,z}-T_{yy,z} &amp; -T_{yz,z}\\ T_{xx,z}-T_{yy,z} &amp; 2 T_{xy,z} &amp; T_{xz,z}\\ -T_{yz,z} &amp; T_{xz,z} &amp; 0 \end{array}\right). \end{eqnarray*}" src="form_359.png"/>
</p>
<p> Note that since we don't transform the derivative but use eq. (7) as defining <code>T</code> for <code>y != 0</code>, the rotation matrices <code>R</code> have to be taken as dependent on <code>y</code> and not as rigid rotations.</p>
<p><b>References</b> </p>
<p>[1] Alcubierre, Miguel, et al. "Symmetry without symmetry: Numerical
     simulation of axisymmetric systems using Cartesian grids." International Journal of Modern Physics D 10.03 (2001): 273-289. </p>

</div>
</div>
<a id="aacd55fd277e945072b2ba6a7a10e52b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd55fd277e945072b2ba6a7a10e52b2">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.simulation.sionumerical.interpolate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a (small) matrix patch, interpolate a value between grid points. </p>
<p>This takes the whole matrix patch supplied, i.e. the order of the interpolating polynomial is determined by the size of the patch. For example, if <code>mat</code> is a 5x5x5 matrix, 5 point Lagrange interpolation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Patch to interpolate within. The size of the patch determines the order of the interpolating polynomials. </td></tr>
    <tr><td class="paramname">coords</td><td>Coordinates in relative index space at which to interpolate. Should be closest to the center grid point for best results. For example, if <code>mat</code> is a 5x5 matrix with indices <code>mat[i,j], i=0,...,4, j=0,...,4</code>, then possible <code>coords</code> are <code>coords = (1.8, 2.2)</code>. If the grid points correspond to physical coordinates, they should be translated into relative index space for this function. </td></tr>
    <tr><td class="paramname">linear</td><td>If <code>True</code>, ignore the patch size and do simple linear interpolation. Default is <code>False</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ab6c543453bdda66a48760da444fc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ab6c543453bdda66a48760da444fc7d">&#9670;&nbsp;</a></span>lrange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.simulation.sionumerical.lrange </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper to call <code>list(range(...))</code>. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1metric.html">metric</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation.html">simulation</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1metric_1_1simulation_1_1sionumerical.html">sionumerical</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
