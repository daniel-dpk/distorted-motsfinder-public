<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: MOTS Finder</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">MOTS Finder </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This project implements an algorithm for numerically finding MOTSs that are not star-shaped. The current implementation is limited to the axisymmetric case but the ideas it is based on easily generalize to the fully non-symmetrical case.</p>
<h2>Using this project</h2>
<p>Anyone is free and welcome to use the code provided in this project (see the <code>LICENSE.txt</code>). For any publications produced using this code, please cite:</p>
<blockquote class="doxtable">
<p>D. Pook-Kolb, O. Birnholtz, B. Krishnan and E. Schnetter, "The existence and
stability of marginally trapped surfaces." arXiv:1811.10405 [gr-qc] </p>
</blockquote>
<p>For any questions/comments/ideas, feel free to contact <code>daniel.pook.kolb at aei.mpg.de</code>.</p>
<h2>Prerequisites</h2>
<ul>
<li>Python 3</li>
<li>SciPy, NumPy, Jupyter, matplotlib</li>
</ul>
<p>To build the documentation:</p>
<ul>
<li>Doxygen, dot (e.g. via graphviz), LaTex (e.g. via texlive)</li>
<li>doxypypy (e.g. via <code>pip install doxypypy</code>)</li>
</ul>
<h2>Source Code Documentation</h2>
<p>The source code is documented in the Pythonic way using <code>docstrings</code> for (nearly) each public function/class/method. The html documentation can be generated using Doxygen in the root of the project:</p>
<div class="fragment"><div class="line">doxygen Doxyfile</div></div><!-- fragment --><p>A <code>virtualenv</code> environment can be used for the <code>doxypypy</code> call by copying <code>./config.cfg</code> to the untracked <code>config.mine.cfg</code>, where you can configure which python binary should be used for the unit tests and the Doxygen filtering.</p>
<p>An overview of how the project source is organized is also available in <a class="el" href="md_README_SRC.html">README_SRC.md</a>.</p>
<h2>Examples</h2>
<p>All the examples require the following <em>init cell</em> to work:</p>
<div class="fragment"><div class="line">%matplotlib inline</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> op</div><div class="line"></div><div class="line"><span class="comment"># Change the path to where the code is located.</span></div><div class="line">sys.path.append(op.expanduser(<span class="stringliteral">&#39;~/src/motsfinder&#39;</span>))</div><div class="line"></div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">from</span> <a class="code" href="namespacemotsfinder_1_1ipyutils.html">motsfinder.ipyutils</a> <span class="keyword">import</span> reload_all</div><div class="line">exec(reload_all())</div></div><!-- fragment --><p>Note that you can put the line <code>exec(reload_all())</code> at the beginning of any cell to immediately see the results of changed source files without restarting the notebook's kernel.</p>
<h3>Example 1 &ndash; Axisymmetric non-star-shaped</h3>
<p>Here, we consider a Brill-Lindquist two black hole metric with mass parameters <code>m1 = 0.2</code>, <code>m2 = 0.8</code>, and distance parameter <code>d = 0.5</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># This defines our setup of a mass-ratio 1:4 system with d = 0.5 M.</span></div><div class="line">cfg = BrillLindquistConfig(d=0.5, m1=0.2, m2=0.8)</div><div class="line"></div><div class="line"><span class="comment"># The initial guess dictates which MOTS is found. The first one finds the</span></div><div class="line"><span class="comment"># apparent horizon (AH) starting with a resolution of 50.</span></div><div class="line">initial_radius = (cfg.m1+cfg.m2)/2. + cfg.d/3.</div><div class="line">initial_origin = 0.0</div><div class="line">c_AH = find_mots(cfg, num=50, c_ref=(initial_radius, initial_origin),</div><div class="line">                 verbose=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># Plot the curve and how the coefficients converge.</span></div><div class="line">c_AH.plot()</div><div class="line">c_AH.plot_coeffs()</div><div class="line"></div><div class="line"><span class="comment"># We can also plot the expansion along the curve.</span></div><div class="line">c_AH.plot_expansion()</div></div><!-- fragment --><p>As a next step, we find the two individual horizons.</p>
<div class="fragment"><div class="line">initial_radius = min(cfg.m1/2., cfg.d/2.)</div><div class="line">initial_origin = cfg.d/2.</div><div class="line">c_smaller = find_mots(cfg, num=50, c_ref=(initial_radius, initial_origin),</div><div class="line">                      verbose=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">initial_radius = min(cfg.m2/2., cfg.d/2.)</div><div class="line">initial_origin = -cfg.d/2.</div><div class="line">c_larger = find_mots(cfg, num=50, c_ref=(initial_radius, initial_origin),</div><div class="line">                     verbose=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># Plot all three MOTSs together.</span></div><div class="line">BaseCurve.plot_curves(</div><div class="line">    (c_AH, <span class="stringliteral">&#39;AH&#39;</span>, <span class="stringliteral">&#39;-b&#39;</span>),</div><div class="line">    (c_smaller, <span class="stringliteral">&#39;smaller MOTS&#39;</span>, <span class="stringliteral">&#39;:m&#39;</span>),</div><div class="line">    (c_larger, <span class="stringliteral">&#39;larger MOTS&#39;</span>, <span class="stringliteral">&#39;--r&#39;</span>),</div><div class="line">)</div></div><!-- fragment --><p>Finding the inner common MOTS is easier at larger distances where it is much closer to the AH in shape. We can then vary the distance step by step and use the previous inner common MOTS as reference surface (and thus starting surface) for the search in the next step.</p>
<div class="fragment"><div class="line"><span class="comment"># First, find the AH at d=0.67. We&#39;ll use the previous AH as starting surface.</span></div><div class="line"><span class="comment"># Note that we downsample the reference curve significantly (using `ref_num`).</span></div><div class="line">c_AH_larger_d = find_mots(cfg, d=0.67, c_ref=c_AH, ref_num=10, verbose=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># Next we find the inner common MOTS by stepping inward a little.</span></div><div class="line"><span class="comment"># The `offset_coeffs` define the coefficients `a_n` of the function we add:</span></div><div class="line"><span class="comment">#     sum_n{a_n cos(n lambda)}</span></div><div class="line">c_inner_larger_d = find_mots(</div><div class="line">    cfg, num=200, d=0.67, c_ref=c_AH_larger_d, ref_num=10,</div><div class="line">    offset_coeffs=(-0.2, 0, 0.05),</div><div class="line">    verbose=<span class="keyword">True</span></div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># Now do a few steps in `d` to get to the desired value defined above.</span></div><div class="line"><span class="comment"># The argument `reparam=True` activates arc-length reparameterization of the</span></div><div class="line"><span class="comment"># reference curve to make sure the collocation points are evenly distributed.</span></div><div class="line">c_inner = c_inner_larger_d.copy()</div><div class="line"><span class="keywordflow">for</span> d <span class="keywordflow">in</span> np.linspace(0.67, cfg.d, num=5):</div><div class="line">    c_inner = find_mots(cfg, d=d, c_ref=c_inner, ref_num=25,</div><div class="line">                        reparam=<span class="keyword">True</span>, verbose=<span class="keyword">True</span>)</div><div class="line"></div><div class="line"><span class="comment"># Plot everything together.</span></div><div class="line">BaseCurve.plot_curves(</div><div class="line">    (c_AH, <span class="stringliteral">&#39;AH&#39;</span>, <span class="stringliteral">&#39;-b&#39;</span>),</div><div class="line">    (c_smaller, <span class="stringliteral">&#39;smaller MOTS&#39;</span>, <span class="stringliteral">&#39;:m&#39;</span>),</div><div class="line">    (c_larger, <span class="stringliteral">&#39;larger MOTS&#39;</span>, <span class="stringliteral">&#39;--r&#39;</span>),</div><div class="line">    (c_inner, <span class="stringliteral">&#39;inner common MOTS&#39;</span>, <span class="stringliteral">&#39;-g&#39;</span>),</div><div class="line">)</div></div><!-- fragment --><p>From here it is easy to reduce <code>d</code> step by step to get to the point where the inner common MOTS and the bottom MOTS disappear. This will require choosing smaller and smaller steps in <code>d</code> and also eventually allowing for a higher maximum spectral resolution.</p>
<h4>Physical quantities</h4>
<p>We can plot e.g. the ricci scalar of each curve like this:</p>
<div class="fragment"><div class="line">plot_1d(c_AH.ricci_scalar, points=100, domain=(0, np.pi), value_pad=1e-6,</div><div class="line">        title=<span class="stringliteral">r&quot;Ricci Scalar $\mathcal{R}$ of AH&quot;</span>)</div></div><!-- fragment --><p>Other quantities are computed simply via:</p>
<div class="fragment"><div class="line">print(<span class="stringliteral">&quot;Stability of larger MOTS:&quot;</span>, c_larger.stability_parameter())</div><div class="line">print(<span class="stringliteral">&quot;Area of inner MOTS:&quot;</span>, c_inner.area())</div><div class="line"></div><div class="line">_, eigenvalues = c_inner.stability_parameter(full_output=<span class="keyword">True</span>)</div><div class="line">s1, s2 = sorted(eigenvalues.real)[:2]</div><div class="line">print(<span class="stringliteral">&quot;Stability parameter of inner MOTS:&quot;</span>, s1)</div><div class="line">print(<span class="stringliteral">&quot;2nd stability eigenvalue of inner MOTS:&quot;</span>, s2)</div></div><!-- fragment --><h3>Example 2 &ndash; More manual control</h3>
<p>The first example used convenience contructs like the <code>BrillLindquistConfig</code> and the <code>find_mots()</code> function. These are just wrappers that internally construct the actual metric object and invoke the <code>newton_kantorovich()</code> function to solve for the MOTS.</p>
<p>This second example avoids these high-level constructs to demonstrate what actually happens.</p>
<p>We consider a Brill-Lindquist two black hole metric with mass parameters <code>m1 = 1</code>, <code>m2 = 1</code>, and distance parameter <code>d = 0.75</code>. The star-shaped approach seems to have problems finding the inner common MOTS as it is either not star-shaped or too close to not being star-shaped anymore.</p>
<p>We first find the outermost (i.e. apparent) horizon <code>AH</code> using the assumption that it is star-shaped. The inner individual MOTS are found the same way, by moving the origin of the finder around.</p>
<p>To then find the inner common MOTS, we first find an inner common MOTS for a larger distance of <code>d = 1.4</code> (where it is still star-shaped), very similar to the above example.</p>
<div class="fragment"><div class="line">d = 0.75</div><div class="line">d_start = 1.4</div><div class="line">num = 300 <span class="comment"># initial spectral resolution of inner common MOTS</span></div><div class="line"></div><div class="line"><span class="comment"># Construct the metric</span></div><div class="line">metric = BrillLindquistMetric(m1=1, m2=1, d=d, axis=<span class="stringliteral">&#39;z&#39;</span>)</div><div class="line"></div><div class="line"><span class="comment"># This is the metric for finding the starting shape of our</span></div><div class="line"><span class="comment"># inner horizon search.</span></div><div class="line">metric_start = BrillLindquistMetric(m1=1, m2=1, d=d_start, axis=<span class="stringliteral">&#39;z&#39;</span>)</div><div class="line"></div><div class="line">with timethis(<span class="stringliteral">&quot;Finding apparent horizon (AH)...&quot;</span>):</div><div class="line">    c_AH = newton_kantorovich(</div><div class="line">        StarShapedCurve.create_sphere(radius=2.0, num=50, metric=metric)</div><div class="line">    )</div><div class="line">with timethis(<span class="stringliteral">&quot;Finding individual horizons...&quot;</span>):</div><div class="line">    c_BH = newton_kantorovich(</div><div class="line">        StarShapedCurve.create_sphere(radius=d/2, num=50, metric=metric,</div><div class="line">                                      origin=(0, d/2)),</div><div class="line">    )</div><div class="line">with timethis(<span class="stringliteral">&quot;Finding star-shaped inner common horizon for d=%s...&quot;</span> % d_start):</div><div class="line">    c0 = c_AH.copy().resample(50)</div><div class="line">    c0.metric = metric_start</div><div class="line">    c_AH_start = newton_kantorovich(c0, steps=5, disp=<span class="keyword">False</span>,</div><div class="line">                                    auto_resolution=<span class="keyword">False</span>)</div><div class="line">    c0 = c_AH_start.copy()</div><div class="line">    c0.h.a_n[0] -= 0.25</div><div class="line">    c_inner_start = newton_kantorovich(</div><div class="line">        c0, steps=5, step_mult=0.2, disp=<span class="keyword">False</span>,</div><div class="line">        <span class="comment">#plot_steps=True, reference_curves=([(c_AH_start, &#39;AH start&#39;)]),</span></div><div class="line">        <span class="comment">#verbose=True</span></div><div class="line">    )</div><div class="line"></div><div class="line"><span class="comment"># Plot what we have so far.</span></div><div class="line">ax = c_AH.plot(l=<span class="stringliteral">&#39;-b&#39;</span>, figsize=(6, 6), label=<span class="stringliteral">&#39;AH&#39;</span>, show=<span class="keyword">False</span>)</div><div class="line">c_BH.plot(l=<span class="stringliteral">&#39;-r&#39;</span>, copy_y=<span class="keyword">True</span>, label=<span class="stringliteral">&#39;individual MOTS&#39;</span>, ax=ax, show=<span class="keyword">False</span>)</div><div class="line">c_inner_start.plot(l=<span class="stringliteral">&#39;--g&#39;</span>, label=<span class="stringliteral">&#39;starting surface&#39;</span>, ax=ax)</div><div class="line"></div><div class="line"><span class="comment"># Represent the starting surface in our new relative coordinates.</span></div><div class="line">c0 = RefParamCurve.from_star_shaped(c_inner_start, c_AH, num=num,</div><div class="line">                                    metric=metric)</div><div class="line"></div><div class="line"><span class="comment"># The next step may create many plots (if `plot_steps` is `True`), for which</span></div><div class="line"><span class="comment"># &#39;inline&#39; is better.</span></div><div class="line">%matplotlib inline</div><div class="line"></div><div class="line"><span class="comment"># Run the Newton search for the inner horizon.</span></div><div class="line">c_inner = newton_kantorovich(</div><div class="line">    c0, step_mult=0.2, linear_regime_threshold=0.3,</div><div class="line">    verbose=<span class="keyword">True</span>,</div><div class="line">    <span class="comment">#plot_steps=True, plot_deltas=True,</span></div><div class="line">    reference_curves=([</div><div class="line">        (c_AH, dict(l=<span class="stringliteral">&#39;-b&#39;</span>, label=<span class="stringliteral">&#39;AH&#39;</span>)),</div><div class="line">        (c_inner_start, dict(l=<span class="stringliteral">&#39;--g&#39;</span>, label=<span class="stringliteral">&#39;inner MOTS for $d=%s$&#39;</span> % d_start)),</div><div class="line">        (c_BH, dict(l=<span class="stringliteral">&#39;-r&#39;</span>, copy_y=<span class="keyword">True</span>, label=<span class="stringliteral">&#39;individual MOTS&#39;</span>)),</div><div class="line">    ]),</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># Plot the result.</span></div><div class="line">ax = c_AH.plot(l=<span class="stringliteral">&#39;-b&#39;</span>, figsize=(5, 5), label=<span class="stringliteral">&#39;AH&#39;</span>, show=<span class="keyword">False</span>)</div><div class="line">c_BH.plot(l=<span class="stringliteral">&#39;-r&#39;</span>, copy_y=<span class="keyword">True</span>, label=<span class="stringliteral">&#39;individual MOTS&#39;</span>, ax=ax, show=<span class="keyword">False</span>)</div><div class="line">c_inner.plot(l=<span class="stringliteral">&#39;-g&#39;</span>, points=c_inner.h.collocation_points(),</div><div class="line">             label=<span class="stringliteral">r&quot;common MOTS (non-star)&quot;</span>, ax=ax, legendargs=dict(loc=1))</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
