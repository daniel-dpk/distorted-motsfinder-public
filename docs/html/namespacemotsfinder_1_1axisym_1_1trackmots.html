<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: motsfinder.axisym.trackmots Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacemotsfinder_1_1axisym_1_1trackmots.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">motsfinder.axisym.trackmots Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Track a single MOTS through slices of a simulation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1__NeckInfo.html">_NeckInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collection of data about the <em>neck</em> of an inner common MOTS.  <a href="classmotsfinder_1_1axisym_1_1trackmots_1_1__NeckInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1__PropResult.html">_PropResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple storage class to help return results of computations.  <a href="classmotsfinder_1_1axisym_1_1trackmots_1_1__PropResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1AuxResultMissing.html">AuxResultMissing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised when a result is missing required for computing a property.  <a href="classmotsfinder_1_1axisym_1_1trackmots_1_1AuxResultMissing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1MOTSTracker.html">MOTSTracker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for coordinating tracking a MOTS through slices.  <a href="classmotsfinder_1_1axisym_1_1trackmots_1_1MOTSTracker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aac0233a9fd75b4d9b90478f0f9df1e9a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#aac0233a9fd75b4d9b90478f0f9df1e9a">track_mots</a> (hname, sim_dir, out_base_dir, folder, initial_guess, MOTS_map=None, kw)</td></tr>
<tr class="memdesc:aac0233a9fd75b4d9b90478f0f9df1e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Track one MOTS through slices of simulation data.  <a href="#aac0233a9fd75b4d9b90478f0f9df1e9a">More...</a><br /></td></tr>
<tr class="separator:aac0233a9fd75b4d9b90478f0f9df1e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dacd50e58eb901a813f4f5b241bd416"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a5dacd50e58eb901a813f4f5b241bd416">find_slices</a> (sim_dir, backwards=False, start_slice=None, end_slice=None, max_slices=None, backwards_skip_first=True, skip_checkpoints=True, disp=True)</td></tr>
<tr class="memdesc:a5dacd50e58eb901a813f4f5b241bd416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather all simulation data files.  <a href="#a5dacd50e58eb901a813f4f5b241bd416">More...</a><br /></td></tr>
<tr class="separator:a5dacd50e58eb901a813f4f5b241bd416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903d7f777ef6c0c60cc01eec5506547b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a903d7f777ef6c0c60cc01eec5506547b">compute_props</a> (hname, c, props, area_rtol=1e-6, min_stability_values=30, m_terminate_index=30, stability_convergence_factors=(0.2, 0.4, 0.6, 0.8, 0.9, 1.1), verbosity=True, MOTS_map=None, fname=None, c_past=None, c_future=None, remove_invalid=True)</td></tr>
<tr class="memdesc:a903d7f777ef6c0c60cc01eec5506547b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute properties and store them in the curve object.  <a href="#a903d7f777ef6c0c60cc01eec5506547b">More...</a><br /></td></tr>
<tr class="separator:a903d7f777ef6c0c60cc01eec5506547b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a21db5fdaf991e42b1f98c7980b6e6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a77a21db5fdaf991e42b1f98c7980b6e6">_area</a> (c, v=None, kw)</td></tr>
<tr class="memdesc:a77a21db5fdaf991e42b1f98c7980b6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area for the curve.  <a href="#a77a21db5fdaf991e42b1f98c7980b6e6">More...</a><br /></td></tr>
<tr class="separator:a77a21db5fdaf991e42b1f98c7980b6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15d8d218112053534e0b9ddf486debb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ae15d8d218112053534e0b9ddf486debb">_area_parts_individual</a> (c, out_dir, other_run, other_hname, v=None, kw)</td></tr>
<tr class="memdesc:ae15d8d218112053534e0b9ddf486debb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area of different parts of an individual MOTS.  <a href="#ae15d8d218112053534e0b9ddf486debb">More...</a><br /></td></tr>
<tr class="separator:ae15d8d218112053534e0b9ddf486debb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138c55df353d64c4795ae454567fd6d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a138c55df353d64c4795ae454567fd6d4">_area_parts_inner</a> (c, out_dir, top_run, bot_run, v=None, kw)</td></tr>
<tr class="memdesc:a138c55df353d64c4795ae454567fd6d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute areas of different parts of the inner common MOTS.  <a href="#a138c55df353d64c4795ae454567fd6d4">More...</a><br /></td></tr>
<tr class="separator:a138c55df353d64c4795ae454567fd6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7969921c4c5663c3131aa66b22c2b19a"><td class="memItemLeft" align="right" valign="top"><a id="a7969921c4c5663c3131aa66b22c2b19a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a7969921c4c5663c3131aa66b22c2b19a">_data_is_valid</a> (prop, value, args, hname)</td></tr>
<tr class="memdesc:a7969921c4c5663c3131aa66b22c2b19a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the current data is valid or should be removed. <br /></td></tr>
<tr class="separator:a7969921c4c5663c3131aa66b22c2b19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74dc8acdd8391930c6bf6bf0bf463738"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a74dc8acdd8391930c6bf6bf0bf463738">_multipoles</a> (c, max_n)</td></tr>
<tr class="memdesc:a74dc8acdd8391930c6bf6bf0bf463738"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the first multipoles for the given curve.  <a href="#a74dc8acdd8391930c6bf6bf0bf463738">More...</a><br /></td></tr>
<tr class="separator:a74dc8acdd8391930c6bf6bf0bf463738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0c726df052363f026f10ad34a48905"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#aaf0c726df052363f026f10ad34a48905">_stability</a> (c, min_num, method, m_terminate_index, slice_normal, v=None)</td></tr>
<tr class="memdesc:aaf0c726df052363f026f10ad34a48905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability spectrum for the curve.  <a href="#aaf0c726df052363f026f10ad34a48905">More...</a><br /></td></tr>
<tr class="separator:aaf0c726df052363f026f10ad34a48905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1689c2326a1a01c252932aca2fba9af"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ac1689c2326a1a01c252932aca2fba9af">_stability_convergence</a> (c, min_num, convergence_factors, method, slice_normal, verbose=False, v=None)</td></tr>
<tr class="memdesc:ac1689c2326a1a01c252932aca2fba9af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability spectrum at different resolutions.  <a href="#ac1689c2326a1a01c252932aca2fba9af">More...</a><br /></td></tr>
<tr class="separator:ac1689c2326a1a01c252932aca2fba9af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75204ddca479824b4e1fbff97e4371e"><td class="memItemLeft" align="right" valign="top"><a id="ad75204ddca479824b4e1fbff97e4371e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ad75204ddca479824b4e1fbff97e4371e">_ricci</a> (c, Ns, eps, xatol)</td></tr>
<tr class="memdesc:ad75204ddca479824b4e1fbff97e4371e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Ricci scalar and its maximum along the curve. <br /></td></tr>
<tr class="separator:ad75204ddca479824b4e1fbff97e4371e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f6cb86269adcd9545af40b14a3d9a4"><td class="memItemLeft" align="right" valign="top"><a id="a29f6cb86269adcd9545af40b14a3d9a4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a29f6cb86269adcd9545af40b14a3d9a4">_mean_curv</a> (c, Ns, eps, xatol)</td></tr>
<tr class="memdesc:a29f6cb86269adcd9545af40b14a3d9a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the mean curvature and its maximum along the curve. <br /></td></tr>
<tr class="separator:a29f6cb86269adcd9545af40b14a3d9a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b01649bf7fe310586e92afda62e548"><td class="memItemLeft" align="right" valign="top"><a id="ac0b01649bf7fe310586e92afda62e548"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ac0b01649bf7fe310586e92afda62e548">_curv_squared</a> (c, Ns, eps, xatol)</td></tr>
<tr class="memdesc:ac0b01649bf7fe310586e92afda62e548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curvature square and its maximum along the curve. <br /></td></tr>
<tr class="separator:ac0b01649bf7fe310586e92afda62e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab38bb8a1d45203f058296abf3423185"><td class="memItemLeft" align="right" valign="top"><a id="aab38bb8a1d45203f058296abf3423185"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#aab38bb8a1d45203f058296abf3423185">_sample_and_extremum</a> (c, func, Ns, eps, xatol)</td></tr>
<tr class="memdesc:aab38bb8a1d45203f058296abf3423185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample a property along the curve and find its maximum. <br /></td></tr>
<tr class="separator:aab38bb8a1d45203f058296abf3423185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3be94b670ee89639708f614ca14b5c"><td class="memItemLeft" align="right" valign="top"><a id="a3b3be94b670ee89639708f614ca14b5c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a3b3be94b670ee89639708f614ca14b5c">_length_maps</a> (c, num)</td></tr>
<tr class="memdesc:a3b3be94b670ee89639708f614ca14b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the conversion mappings from parameterization to proper length. <br /></td></tr>
<tr class="separator:a3b3be94b670ee89639708f614ca14b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace251cd96d0c40e564e4838d317f28d3"><td class="memItemLeft" align="right" valign="top"><a id="ace251cd96d0c40e564e4838d317f28d3"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ace251cd96d0c40e564e4838d317f28d3">_constraints</a> (c, num, fd_order)</td></tr>
<tr class="memdesc:ace251cd96d0c40e564e4838d317f28d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the constraints close to the curve. <br /></td></tr>
<tr class="separator:ace251cd96d0c40e564e4838d317f28d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbae4d351f62714e5d2cb32d0b51939c"><td class="memItemLeft" align="right" valign="top"><a id="acbae4d351f62714e5d2cb32d0b51939c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#acbae4d351f62714e5d2cb32d0b51939c">_ingoing_exp</a> (c, Ns, eps)</td></tr>
<tr class="memdesc:acbae4d351f62714e5d2cb32d0b51939c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the ingoing expansion along the curve. <br /></td></tr>
<tr class="separator:acbae4d351f62714e5d2cb32d0b51939c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1cc69004997ed0ff17e2731acf16bc7"><td class="memItemLeft" align="right" valign="top"><a id="aa1cc69004997ed0ff17e2731acf16bc7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#aa1cc69004997ed0ff17e2731acf16bc7">_avg_ingoing_exp</a> (c, epsabs, limit)</td></tr>
<tr class="memdesc:aa1cc69004997ed0ff17e2731acf16bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average ingoing expansion across the MOTS. <br /></td></tr>
<tr class="separator:aa1cc69004997ed0ff17e2731acf16bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69b760f1f48bd4d4dc563d1fe97195d"><td class="memItemLeft" align="right" valign="top"><a id="ab69b760f1f48bd4d4dc563d1fe97195d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ab69b760f1f48bd4d4dc563d1fe97195d">_point_dists</a> (c)</td></tr>
<tr class="memdesc:ab69b760f1f48bd4d4dc563d1fe97195d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the coordinate distances of all collocation points. <br /></td></tr>
<tr class="separator:ab69b760f1f48bd4d4dc563d1fe97195d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6bb5f0c1100c58b1bf6096ab1ec3217"><td class="memItemLeft" align="right" valign="top"><a id="af6bb5f0c1100c58b1bf6096ab1ec3217"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#af6bb5f0c1100c58b1bf6096ab1ec3217">_neck</a> (c, xtol, epsrel)</td></tr>
<tr class="memdesc:af6bb5f0c1100c58b1bf6096ab1ec3217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find and compute various neck properties for the inner common MOTS. <br /></td></tr>
<tr class="separator:af6bb5f0c1100c58b1bf6096ab1ec3217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec4af6f2ed778c88ccb9bb2c43bae8e"><td class="memItemLeft" align="right" valign="top"><a id="a4ec4af6f2ed778c88ccb9bb2c43bae8e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a4ec4af6f2ed778c88ccb9bb2c43bae8e">_dist_top_bot</a> (c, rtol, allow_intersection, other_run, other_hname, out_dir)</td></tr>
<tr class="memdesc:a4ec4af6f2ed778c88ccb9bb2c43bae8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the proper distance of the two individual MOTSs. <br /></td></tr>
<tr class="separator:a4ec4af6f2ed778c88ccb9bb2c43bae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f60f265c13b534167bfd7a56bea7dd5"><td class="memItemLeft" align="right" valign="top"><a id="a4f60f265c13b534167bfd7a56bea7dd5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a4f60f265c13b534167bfd7a56bea7dd5">_z_dist_to_inner</a> (c, rtol, where, other_run, other_hname, out_dir)</td></tr>
<tr class="memdesc:a4f60f265c13b534167bfd7a56bea7dd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the proper distance of inner and individual MOTSs. <br /></td></tr>
<tr class="separator:a4f60f265c13b534167bfd7a56bea7dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab195886dbf3de098b13ffb4f0db5338d"><td class="memItemLeft" align="right" valign="top"><a id="ab195886dbf3de098b13ffb4f0db5338d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ab195886dbf3de098b13ffb4f0db5338d">_signature</a> (c, N, eps, c_past, c_future, has_past, has_future)</td></tr>
<tr class="memdesc:ab195886dbf3de098b13ffb4f0db5338d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signature of the world tube traces out by MOTSs. <br /></td></tr>
<tr class="separator:ab195886dbf3de098b13ffb4f0db5338d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbc9a254d9c8b6cf279c1f7d2d894ce"><td class="memItemLeft" align="right" valign="top"><a id="aecbc9a254d9c8b6cf279c1f7d2d894ce"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#aecbc9a254d9c8b6cf279c1f7d2d894ce">_get_aux_curve</a> (out_dir, hname, it, disp=True, verbose=False)</td></tr>
<tr class="memdesc:aecbc9a254d9c8b6cf279c1f7d2d894ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an auxiliary curve for the given iteration. <br /></td></tr>
<tr class="separator:aecbc9a254d9c8b6cf279c1f7d2d894ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2670272f6854daf98f8a96767308fbec"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a2670272f6854daf98f8a96767308fbec">optimize_bipolar_scaling</a> (curve, initial_scale, move, factor=0.75, threshold_factor=5.0, res_decrease_factor=0.9, initial_smoothing=None, max_smoothing=0.1, verbose=True, recursions=1, max_shrinking=0.05)</td></tr>
<tr class="memdesc:a2670272f6854daf98f8a96767308fbec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform successive tests to try to find optimal bipolar scale parameter.  <a href="#a2670272f6854daf98f8a96767308fbec">More...</a><br /></td></tr>
<tr class="separator:a2670272f6854daf98f8a96767308fbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4469d37b05f6e9159cf6c3245059d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#ade4469d37b05f6e9159cf6c3245059d4">_optimize_curve_parameter</a> (curve, x0, set_value, factor, max_shrinking, max_value=None, threshold_factor=None, res_decrease_factor=None, verbose=True, recursions=1, num=None, full_output=False, _cache=None)</td></tr>
<tr class="memdesc:ade4469d37b05f6e9159cf6c3245059d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vary a parameter to minimize the required resolution.  <a href="#ade4469d37b05f6e9159cf6c3245059d4">More...</a><br /></td></tr>
<tr class="separator:ade4469d37b05f6e9159cf6c3245059d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a0c31f615a57056e8d15b6694573a8"><td class="memItemLeft" align="right" valign="top"><a id="a71a0c31f615a57056e8d15b6694573a8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html#a71a0c31f615a57056e8d15b6694573a8">_limit_factor_shrinking</a> (new_factor, factor, max_shrinking, verbose)</td></tr>
<tr class="memdesc:a71a0c31f615a57056e8d15b6694573a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the new factor is not too much closer to 1 than the old one. <br /></td></tr>
<tr class="separator:a71a0c31f615a57056e8d15b6694573a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad57ec603e95646f3d911043d416b5739"><td class="memItemLeft" align="right" valign="top">tuple&#160;</td><td class="memItemRight" valign="bottom"><b>ALL_PROPS</b></td></tr>
<tr class="separator:ad57ec603e95646f3d911043d416b5739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a223ca8475801a004b8ea0e2f49e38"><td class="memItemLeft" align="right" valign="top"><a id="a89a223ca8475801a004b8ea0e2f49e38"></a>
tuple&#160;</td><td class="memItemRight" valign="bottom"><b>NEED_ACTIVATION_PROPS</b> = ('stability_convergence', 'stability_convergence_null')</td></tr>
<tr class="separator:a89a223ca8475801a004b8ea0e2f49e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Track a single MOTS through slices of a simulation. </p>
<p><b>Examples</b> </p>
<div class="fragment"><div class="line"><span class="comment"># Example of a run finding the AH in a sequence of slices.</span></div><div class="line">track_mots(</div><div class="line">    hname=<span class="stringliteral">&#39;AH&#39;</span>,</div><div class="line">    sim_dir=<span class="stringliteral">&#39;data/simulation/brill-lindquist-res256&#39;</span>,</div><div class="line">    out_base_dir=<span class="stringliteral">&#39;results&#39;</span>,</div><div class="line">    folder=<span class="stringliteral">&#39;BL-res256/run1/AH&#39;</span>,</div><div class="line">    initial_guess=<span class="stringliteral">&#39;results/BL-res256/init/AH_discrete1_it0000000000.npy&#39;</span>,</div><div class="line">    compute=<span class="keyword">True</span>,</div><div class="line">    two_pass=<span class="keyword">False</span>,</div><div class="line">    props=[],</div><div class="line">    strategy=2,</div><div class="line">    verbosity=2,</div><div class="line">    timings=<span class="keyword">True</span>,</div><div class="line">)</div><div class="line"></div><div class="line"><span class="comment"># Example of a run for computing the properties in parallel.</span></div><div class="line">track_mots(</div><div class="line">    hname=<span class="stringliteral">&#39;AH&#39;</span>,</div><div class="line">    sim_dir=<span class="stringliteral">&#39;data/simulation/brill-lindquist-res256&#39;</span>,</div><div class="line">    out_base_dir=<span class="stringliteral">&#39;results&#39;</span>,</div><div class="line">    folder=<span class="stringliteral">&#39;BL-res256/run1/AH&#39;</span>,</div><div class="line">    initial_guess=<span class="keywordtype">None</span>,  <span class="comment"># not needed for a property run</span></div><div class="line">    compute=<span class="keyword">False</span>,</div><div class="line">    two_pass=<span class="keyword">False</span>,</div><div class="line">    props=[<span class="stringliteral">&#39;all&#39;</span>],</div><div class="line">    strategy=2,</div><div class="line">    verbosity=2,</div><div class="line">    timings=<span class="keyword">True</span>,</div><div class="line">    retry_after=180,  <span class="comment"># wait 3 minutes for new results and try again</span></div><div class="line">)</div></div><!-- fragment --><p>These examples assume the initial guess for the MOTS has been found e.g. using .<a class="el" href="classmotsfinder_1_1axisym_1_1initialguess_1_1InitHelper.html" title="Helper to find the initial MOTSs for a Brill-Lindquist-like metric. ">initialguess.InitHelper</a> and that the apparent horizon already exists in the first slice.</p>
<p>In case the initial guess for the AH is successful in, say, slice 2048, then we need to run two sets of the above trackers, one going forward in slices and one going backwards. This would be accomplished by adding the following arguments:</p>
<div class="fragment"><div class="line">initial_guess=<span class="stringliteral">&#39;results/BL-res256/init/AH_discrete1_it0000002048.npy&#39;</span>,</div><div class="line">start_slice=2048,</div><div class="line">backwards=<span class="keyword">False</span>,</div></div><!-- fragment --><p>And for the backwards direction:</p>
<div class="fragment"><div class="line">initial_guess=<span class="stringliteral">&#39;results/BL-res256/init/AH_discrete1_it0000002048.npy&#39;</span>,</div><div class="line">start_slice=2048,</div><div class="line">backwards=<span class="keyword">True</span>,</div></div><!-- fragment --> </div><h2 class="groupheader">Function Documentation</h2>
<a id="a77a21db5fdaf991e42b1f98c7980b6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a21db5fdaf991e42b1f98c7980b6e6">&#9670;&nbsp;</a></span>_area()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._area </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the area for the curve. </p>
<p>The parameter <code>v</code> is ignored here and can be used to force recomputation of the area for curves already containing an area result. </p>

</div>
</div>
<a id="ae15d8d218112053534e0b9ddf486debb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15d8d218112053534e0b9ddf486debb">&#9670;&nbsp;</a></span>_area_parts_individual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._area_parts_individual </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the area of different parts of an individual MOTS. </p>
<p>If the other individual MOTS does not intersect this MOTS, nothing is done and <code>None</code> is returned. If it does intersect, computes the area of the exterior and interior parts separately and returns an <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results. ">numutils.IntegrationResults</a> object. The returned object's <code>info</code> dictionary contains an <code>intersection</code> key with the curve paramters of this (first) and the other (second) curve at which they intersect. </p>

</div>
</div>
<a id="a138c55df353d64c4795ae454567fd6d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a138c55df353d64c4795ae454567fd6d4">&#9670;&nbsp;</a></span>_area_parts_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._area_parts_inner </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>top_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>bot_run</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute areas of different parts of the inner common MOTS. </p>
<p>Note that a precondition for this function is computation of the 'neck'. If a neck was actually found, computes the area of the upper and lower parts separately. The result is an <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results. ">numutils.IntegrationResults</a> object with the two values and a <code>info</code> dictionary containing the used <code>neck</code> location.</p>
<p>If, in addition to a neck, the MOTS self-intersects, then it will also intersect the two individual MOTSs. The four intersection points (two parameters for the self-intersection, plus two for the intersection with the other MOTSs) together with the neck partition the curve into six sections, of which the area is computed separately. The resulting <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results. ">numutils.IntegrationResults</a> object's <code>info</code> dictionary contains the location of all detected intersections. For the individual MOTSs, the second parameter in the values refers to the parameter of the individual MOTS at which this intersection happens. </p>

</div>
</div>
<a id="a74dc8acdd8391930c6bf6bf0bf463738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74dc8acdd8391930c6bf6bf0bf463738">&#9670;&nbsp;</a></span>_multipoles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._multipoles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the first multipoles for the given curve. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results. ">numutils.IntegrationResults</a> object containing the results with estimates of their accuracy.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Curve representing the horizon. </td></tr>
    <tr><td class="paramname">max_n</td><td>Highest multipole to compute. It will compute the elements <code>0, 1, 2, ..., max_n</code> (i.e. <code>max_n+1</code> elements).</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>The strategy for computation is to first try to compute using the estimated curve's residual expansion as absolute tolerance. If this fails or produces integration warnings, the tolerance is successively increased and computation is retried. </p>

</div>
</div>
<a id="ade4469d37b05f6e9159cf6c3245059d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade4469d37b05f6e9159cf6c3245059d4">&#9670;&nbsp;</a></span>_optimize_curve_parameter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._optimize_curve_parameter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>set_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_shrinking</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_value</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold_factor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>res_decrease_factor</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recursions</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_cache</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vary a parameter to minimize the required resolution. </p>
<p>This varies a parameter and repeatedly checks the residual expansion of the resulting curve to see at which value the residual has its minimal value. This should lead to a lower required resolution when using the found parameter value for reparametrizing the curve. </p>

</div>
</div>
<a id="aaf0c726df052363f026f10ad34a48905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0c726df052363f026f10ad34a48905">&#9670;&nbsp;</a></span>_stability()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._stability </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_terminate_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the stability spectrum for the curve. </p>
<p>The parameter <code>v</code> is ignored here and can be used to force recomputation of this property in case the code has changed. </p>

</div>
</div>
<a id="ac1689c2326a1a01c252932aca2fba9af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1689c2326a1a01c252932aca2fba9af">&#9670;&nbsp;</a></span>_stability_convergence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots._stability_convergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>convergence_factors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>v</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the stability spectrum at different resolutions. </p>
<p>The parameter <code>v</code> can be used to force recomputation of this property in case the code has changed. Note that results from the <code>"stability"</code> property are reused only if the <code>v</code> parameters match. </p>

</div>
</div>
<a id="a903d7f777ef6c0c60cc01eec5506547b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903d7f777ef6c0c60cc01eec5506547b">&#9670;&nbsp;</a></span>compute_props()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.compute_props </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>props</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area_rtol</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_stability_values</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_terminate_index</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stability_convergence_factors</em> = <code>(0.2,&#160;0.4,&#160;0.6,&#160;0.8,&#160;0.9,&#160;1.1)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>MOTS_map</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>fname</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c_past</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c_future</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>remove_invalid</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute properties and store them in the curve object. </p>
<p>All computed properties will be stored under the property's name in the curve's <code>user_data</code> dictionary. The arguments used for this computation are additionally stored under the key <code>prop_args</code>, where <code>prop</code> is the property name. Some properties produce extra output. This is then stored under <code>prop_extras</code>.</p>
<p>The properties that can be computed here are:</p><ul>
<li><b>length_maps</b>: Mappings from current parameterization to proper-length based parameterizations (see ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0947d643e386c5ab4ac57734fabfec58" title="Generate functions to map between curve parameter and proper length. ">curve.basecurve.BaseCurve.proper_length_map()</a>). The value will be a dictionary with elements <code>length_map</code>, <code>inv_map</code>, <code>proper_length</code>, where the latter is the length of the curve in curved space. Note that the two functions will actually be series objects (<a class="el" href="classmotsfinder_1_1exprs_1_1series_1_1SeriesExpression.html" title="Base class for truncated series expressions. ">motsfinder.exprs.series.SeriesExpression</a>), so that <code>evaluator()</code> needs to be called to get actual callables.</li>
<li><b>constraints</b>: Compute the Hamiltonian (scalar) and momentum (vector) constraints on grid points close to the curve. The stored value will have the structure <code>dict(near_curve=dict(std=[x, ham, mom], proper=[x, ham, mom]))</code>. Here, <code>x</code> is the set of parameter values of the curve close to which the values are computed, <code>ham</code> are the Hamiltonian constraint values and <code>mom</code> the momentum ones. The difference between <code>std</code> and <code>proper</code> is that for <code>std</code>, the parameters are equidistant in curve parameter <code>lambda</code>, while for <code>proper</code> they are equidistant in the curve's proper length parameterization, though the stored <code>x</code> values are in the curve's current parameterization. This way, you can plot in the curve's proper length parameterization by taking the <code>x</code> values of <code>std</code> and values of <code>proper</code>.</li>
<li><b>ingoing_exp</b>: Expansion of the ingoing null normals. This is computed on a grid of points (in curve parameter space) the density of which is determined by the curve's resolution.</li>
<li><b>avg_ingoing_exp</b>: Average ingoing expansion, averaged over the MOTSs surface area.</li>
<li><b>area</b>: Surface area of the MOTS. This produces extra data (as explained above) containing information about the convergence of the integral.</li>
<li><b>ricci</b>: Ricci scalar computed on a grid of points with density dependent on the curve resolution. Additionally, the maximum absolute value of the Ricci scalar along the curve is found and stored. Inspect the actual data (dictionary) for details.</li>
<li><b>mean_curv</b>: Similar to <code>ricci</code>, but compute the trace of the extrinsic curvature of the MOTS in the slice instead.</li>
<li><b>curv2</b>: Similar to <code>mean_curv</code>, but compute the "square" <img class="formulaInl" alt="$k_{AB}k^{AB}$" src="form_404.png"/> of the MOTS's extrinsic curvature.</li>
<li><b>stability</b>, <b>stability_null</b>: Compute the spectrum of the stability operator. The number of eigenvalues returned depends on the curve's resolution, but at least 30 eigenvalues (by default) are computed. See also the <code>min_stability_values</code> parameter and the following property. The stored value is a tuple <code>principal, spectrum0</code>, where <code>principal</code> is the principal eigenvalue and <code>spectrum0</code> is the spectrum of the <code>m=0</code> angular mode. The full computed spectrum including higher modes is stored in the <code>stability_extras</code> dictionary under the <code>spectrum</code> key. Use <code>m_terminate_index</code> to control how many angular modes to consider. The <em><b>_null</b></em> variant of this property computes the spectrum w.r.t. the past outward null normal <img class="formulaInl" alt="$-k^\mu$" src="form_447.png"/> instead of the outward normal in the spatial slice.</li>
<li><b>stability_convergence</b>, <b>stability_convergence_null</b>: In addition to computing the stability spectrum above, recompute it at (by default) <code>0.2, 0.4, 0.6, 0.8, 0.9, 1.1</code> times the resolution used for the <code>"stability"</code> property. This allows analyzing convergence of the individual eigenvalues. As above, the <em><b>_null</b></em> variant is for the past outward null normal <img class="formulaInl" alt="$-k^\mu$" src="form_447.png"/>.</li>
<li><b>neck</b>: Find the neck based on various criteria and compute various properties at this point, like proper circumference or proper distance to the z-axis. Only computed for a MOTS with <code>hname="inner"</code>.</li>
<li><b>dist_top_bot</b>: Proper distance (along the z-axis) of the two individual MOTSs. Only computed for a MOTS with <code>hname="bot"</code>.</li>
<li><b>z_dist_top_inner</b>: Proper distance of the highest point on the z-axis of the inner common MOTS and the top individual MOTS. Only compute for a MOTS with <code>hname="inner"</code>.</li>
<li><b>z_dist_bot_inner</b>: Proper distance of the lowest point on the z-axis of the inner common MOTS and the bottom individual MOTS. Only compute for a MOTS with <code>hname="inner"</code>.</li>
<li><b>signature</b>: Signature of the MOTT traced out by the series of MOTSs. The number of points at which the signature is computed depends on the curve's resolution</li>
<li><b>point_dists</b>: Coordinate distances of the collocation points along the curve. May be useful to compare against the spatial coordinate resolution of the numerical grid.</li>
<li><b>area_parts</b>: In case <code>hname="bot"</code> or <code>"top"</code> and the top and bottom MOTSs intersect, compute separately the area of the non-intersecting part and the part lying inside the other MOTS. For <code>hname="inner"</code>, compute the parts before and after the <em>neck</em> separately. In case it self-intersects, find all the intersection points of the MOTS with itself and the top and bottom MOTSs and compute the area of each section, including splitting at the neck. If a result is found (i.e. the property's value is not <code>None</code>), the stored value will be a <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results. ">numutils.IntegrationResults</a> object. Its <code>info</code> dictionary contains all splitting points. Sorting these gives you all the intervals of which the areas were computed.</li>
<li><b>multipoles</b>: Compute the first 10 multipole moments of the MOTS. The first and second moments are computed numerically even though these have analytically known values of <code>sqrt(pi)</code> and <code>0</code>, respectively. This allows comparison of the integration results with known values.</li>
</ul>
<p>Some properties are only computed for certain horizons. The horizon specific properties are:</p><ul>
<li>for <code>"top"</code>: <code>area_parts</code></li>
<li>for <code>"bot"</code>: <code>dist_top_bot</code>, <code>area_parts</code></li>
<li>for <code>"inner"</code>: <code>neck</code>, <code>z_dist_top_inner</code>, <code>z_dist_bot_inner</code>, <code>area_parts</code></li>
</ul>
<p>The <code>signature</code> is only computed if at least one of <code>c_past</code> or <code>c_future</code> is supplied.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hname</td><td>Name of horizon. Determines which kinds of properties are being computed (see above). </td></tr>
    <tr><td class="paramname">c</td><td>Curve representing the MOTS in axisymmetry. </td></tr>
    <tr><td class="paramname">props</td><td>Sequence of properties to compute (see above for the possible values). Use the string <code>"all"</code> to compute all possible properties. </td></tr>
    <tr><td class="paramname">area_rtol</td><td>Relative tolerance for the area integral. Setting this too low will result in integration warnings being produced and possibly underestimated residual errors. </td></tr>
    <tr><td class="paramname">min_stability_values</td><td>Minimum number of MOTS-stability eigenvalues to compute. The default is <code>30</code>. </td></tr>
    <tr><td class="paramname">m_terminate_index</td><td>Index of the eigenvalue of the <code>m=0</code> mode to use to as stopping criterion for the angular mode. Default is <code>30</code>. See .<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a261ec805e4184cc43bfc37a4f801c204" title="Compute the stability parameter. ">curve.expcurve.ExpansionCurve.stability_parameter()</a> for details. </td></tr>
    <tr><td class="paramname">stability_convergence_factors</td><td>Factors by which to multiply the resolution used for computing the stability spectrum. Each of the resulting lower or higher resolutions is used to compute the same spectrum, so that convergence of the individual eigenvalues can be examined. Defaults to <code>(0.2, 0.4, 0.6, 0.8, 0.9, 1.1)</code>. </td></tr>
    <tr><td class="paramname">verbosity</td><td>Whether to print progress information. </td></tr>
    <tr><td class="paramname">MOTS_map</td><td>Dictionary indicating from which runs auxiliary MOTSs should be loaded (used e.g. for the various distances). </td></tr>
    <tr><td class="paramname">fname</td><td>File name under which the MOTS is stored. This is currently just used to infer the run name for finding auxiliary MOTSs. </td></tr>
    <tr><td class="paramname">c_past,c_future</td><td>Optional MOTSs of the previous and next slices, respectively. These are used to compute the signature of the world tube traced out by the evolution of the MOTS. </td></tr>
    <tr><td class="paramname">remove_invalid</td><td>Whether to check for and remove invalid data prior to recomputing it. This only affects data that is specified to being computed. This may be useful for updating data for which updated methods have been developed and a check for validity can be done. Default is <code>True</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dacd50e58eb901a813f4f5b241bd416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dacd50e58eb901a813f4f5b241bd416">&#9670;&nbsp;</a></span>find_slices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.find_slices </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sim_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backwards</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>start_slice</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>end_slice</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_slices</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>backwards_skip_first</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>skip_checkpoints</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather all simulation data files. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sim_dir</td><td>Folder to start searching recursively for simulation data files. </td></tr>
    <tr><td class="paramname">backwards</td><td>Whether to reverse the order of the slices found. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">start_slice</td><td>First slice to consider. When <code>backwards==True</code>, this should be the <em>latest</em> slice in the series. Note that if a start slice is specified in the <code>backwards==True</code> case, the slice itself is skipped to allow simultaneously starting forward and backwards runs. Default is to find all slices (including the last one in the backwards case). </td></tr>
    <tr><td class="paramname">end_slice</td><td>Last slice to consider. Take all (except for <code>start_slice</code>) if not given (default). </td></tr>
    <tr><td class="paramname">max_slices</td><td>Truncate the number of slices returned after this many if given. </td></tr>
    <tr><td class="paramname">backwards_skip_first</td><td>If <code>True</code> (default), skip the starting slice when going backwards as described above. If <code>False</code>, include the starting slice in all cases. </td></tr>
    <tr><td class="paramname">skip_checkpoints</td><td>Whether to ignore checkpoints in the simulation folders. Default is <code>True</code>. </td></tr>
    <tr><td class="paramname">disp</td><td>Raise a <code>ValueError</code> if no slices are found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2670272f6854daf98f8a96767308fbec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2670272f6854daf98f8a96767308fbec">&#9670;&nbsp;</a></span>optimize_bipolar_scaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.optimize_bipolar_scaling </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>factor</em> = <code>0.75</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>threshold_factor</em> = <code>5.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>res_decrease_factor</em> = <code>0.9</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_smoothing</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_smoothing</em> = <code>0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>recursions</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_shrinking</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform successive tests to try to find optimal bipolar scale parameter. </p>
<p>This function parameterizes the given MOTS in bipolar coordinates and reparameterizes in the s-t-coordinate-space. Afterwards, the residual expansion between collocation points is measured. By changing the scaling parameter (half-distance of the two foci), the result will generally become better or worse, depending on how well the coordinates are adapted to the curve's shape. A very simple numerical search is used to find a scale that is better than the given <code>initial_scale</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curve</td><td>MOTS to base the measurements on. Should have low residual expansion already. </td></tr>
    <tr><td class="paramname">initial_scale</td><td>Scaling to start with. </td></tr>
    <tr><td class="paramname">move</td><td>Origin, i.e. center between the foci of the bipolar coordinates. </td></tr>
    <tr><td class="paramname">factor</td><td>Factor by which to increase or decrease the scaling each step, respectively. Default is <code>0.75</code>, i.e. increase using <code>value/0.75</code> and decrease using <code>value*0.75</code>. </td></tr>
    <tr><td class="paramname">threshold_factor</td><td>Factor by which to increase the initial residual expansion. This defines the target resolution used in each reparameterization. The idea is to avoid being in the roundoff plateau, so that values react to how well the scaling is suited to the problem, and not fluctuate a lot. Default is <code>0.9</code>. </td></tr>
    <tr><td class="paramname">res_decrease_factor</td><td>Factor used for initially finding the resolution with which to work during the search. The initial resolution is reduced successively by this factor until the residual expansion is above <code>threshold_factor*residual</code>. Default is <code>10</code>. </td></tr>
    <tr><td class="paramname">initial_smoothing</td><td>If given, perform an optimization for the smoothing parameter of the <code>'curv2'</code> reparameterization strategy, starting from the given value. This is done after the bipolar scaling parameter is optimized. </td></tr>
    <tr><td class="paramname">max_smoothing</td><td>Maximum smoothing value to allow. For high smoothing values, the results usually don't change anymore. Under certain circumstances, the search may start to increase this smoothing value indefinitely (effectively amounting to the limit of arc-length parameterization). Default is <code>0.1</code>. </td></tr>
    <tr><td class="paramname">verbose</td><td>Whether to print status messages. Default is <code>True</code>. </td></tr>
    <tr><td class="paramname">recursions</td><td>If the result gets worse for the initial steps up and down, put a parabola through the three obtained values. Its minimum is then taken as the initial step for another search. The <code>recursions</code> value determines how often this should happen (i.e. it is reduced by one each recursion). If <code>recursions==0</code>, the minimum of the parabola is taken as optimal value. </td></tr>
    <tr><td class="paramname">max_shrinking</td><td>Upon recursion (see above), don't move too close to not moving at all (i.e. a <code>factor</code> of <code>1.0</code>). This parameter ensures that <code>(new_factor-1)/(factor-1) &gt;= max_shrinking</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac0233a9fd75b4d9b90478f0f9df1e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0233a9fd75b4d9b90478f0f9df1e9a">&#9670;&nbsp;</a></span>track_mots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.axisym.trackmots.track_mots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sim_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>out_base_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>MOTS_map</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Track one MOTS through slices of simulation data. </p>
<p>See the package documentation for ..<a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html" title="Track a single MOTS through slices of a simulation. ">axisym.trackmots</a> for examples of invoking the tracker.</p>
<p>The tracker basically has two "modes" to run in:</p><ol type="1">
<li>Find mode: Try to locate MOTSs in each slice</li>
<li>Property mode: Compute area, stability, etc., of previously found MOTSs</li>
</ol>
<p>The idea is that the two modes can potentially be run in parallel: You start with a finding run. After the first few MOTSs have been found and stored in the output folder, a property runner can be invoked to compute physical properties parallel to the finding run. If desired, the property runner can be instructed to wait for results of the finder in case it catches up.</p>
<p>Computed properties are stored as <code>user_data</code> of the curve object. After computing the properties, the file from where the curve was loaded is overwritten with the new curve containing the computed data. Note that this introduces an issue happening if two <em>property runners</em> compute (potentially different) properties of the same curve in parallel, since the one finishing last will effectively erase the results computed by the others. This means you should let only one property runner work on a curve at a time. No check is done to enforce this.</p>
<p>For some tasks, the finder or property runner need to consider sibling MOTSs (e.g. to compute distances between MOTSs) or future/past MOTSs of the same tube (e.g. to compute the signature). Sibling MOTSs are located using the following assumptions:</p><ul>
<li>Each MOTS has their own output folder</li>
<li>Each of these folders belong to a "run", i.e. a common parent folder</li>
</ul>
<p>This should be accomplished by setting <code>folder</code> appropriately, e.g.: </p><pre class="fragment">folder="foo/run1/AH"
</pre><p>An example file structure (with <code>out_base_dir="some/path"</code>) might be: </p><pre class="fragment">some/path/foo/run1/AH/AH_discrete_it0000000000.npy
some/path/foo/run1/AH/AH_discrete_it0000000001.npy
some/path/foo/run1/top/top_discrete_it0000000000.npy
some/path/foo/run1/top/top_discrete_it0000000001.npy
some/path/foo/run1/bot/bot_discrete_it0000000000.npy
some/path/foo/run1/bot/bot_discrete_it0000000001.npy
some/path/foo/run1/inner/inner_discrete_it0000000000.npy
some/path/foo/run2/inner/inner_discrete_it0000000000.npy
some/path/foo/run2/inner/inner_discrete_it0000000001.npy
</pre><p>Here, the apparent horizon, the top, and bottom MOTSs were found in slices 0 and 1. The inner common MOTS was only found in slice 0. Upon changing settings, we managed to find it in slice 0 and 1 and stored the results under <code>run2</code>.</p>
<p>To make the tracker aware of the <code>top</code> and <code>bot</code> MOTSs from <code>run1</code> when computing properties of <code>run2/inner</code>, you supply a mapping from MOTS name (e.g. <code>top</code>, <code>bot</code>) to the run to take it from (e.g. <code>run1</code>). This is done using the <code>MOTS_map</code> parameter like so: </p><pre class="fragment">MOTS_map=dict(top="run1", bot="run1")
</pre><p>A missing entry in the <code>MOTS_map</code> means we should take the MOTS from the current run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hname</td><td>Name of the horizon to track. This determines the file names as well as which properties are computed. For example, the distance between top and bottom MOTS is computed only if this MOTS has <code>hname="bot"</code> and a sibling MOTS for the same slice named <code>hname="top"</code> has already been found and stored. Similarly, the <em>neck</em> location and properties as well as the distance to the <code>"top"</code> and <code>"bot"</code> MOTSs is computed only for a run with <code>hname="inner"</code>. Examples <code>"AH"</code>, <code>"top"</code>, <code>"bot"</code>, <code>"inner"</code>. </td></tr>
    <tr><td class="paramname">sim_dir</td><td>Folder to find the simulation slices in. Slices from all subfolders are found and sorted alphanumerically. Slices with the same base name (i.e. ignoring differently named parent folders) as one already in the list are skipped. Example <code>"data/simulation/brill-lindquist-2-res256"</code>. </td></tr>
    <tr><td class="paramname">out_base_dir</td><td>Parent folder for all the results. Example: <code>"./results"</code>. </td></tr>
    <tr><td class="paramname">folder</td><td>Sub folder of the <code>out_base_dir</code> containing results for this specific configuration and run. Example: <code>"BL-2-res256/run1/AH"</code>. If configured as in the examples and the MOTS configuration is set to use a <code>simple_name</code> (see the documentation of .<a class="el" href="classmotsfinder_1_1axisym_1_1findmots_1_1MotsFindingConfig.html#a33b0b614c2c46ab0c27d6c9d2e882cd4" title="Initialize a new configuration object. ">findmots.MotsFindingConfig.__init__()</a>), then the curves will be stored in <code>./results/BL-2-res256/run1/AH</code>. </td></tr>
    <tr><td class="paramname">initial_guess</td><td>Curve or filename or float to use as initial guess for tracking this MOTS. Differentiation between the different MOTSs to track through slices happens by using different initial guesses. You may use the .<a class="el" href="classmotsfinder_1_1axisym_1_1initialguess_1_1InitHelper.html" title="Helper to find the initial MOTSs for a Brill-Lindquist-like metric. ">initialguess.InitHelper</a> to help obtaining initial guesses for different MOTSs in a particular slice. </td></tr>
    <tr><td class="paramname">MOTS_map</td><td>Optional map (<code>dict</code>) specifying from which run the auxiliary MOTSs required for certain tasks should be taken. See above for examples. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments configure the settings of the <a class="el" href="classmotsfinder_1_1axisym_1_1trackmots_1_1MOTSTracker.html" title="Class for coordinating tracking a MOTS through slices. ">MOTSTracker</a> (see its documented public attributes). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad57ec603e95646f3d911043d416b5739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57ec603e95646f3d911043d416b5739">&#9670;&nbsp;</a></span>ALL_PROPS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple ALL_PROPS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  (<span class="keywordtype">None</span>, <span class="stringliteral">&#39;none&#39;</span>, <span class="stringliteral">&#39;all&#39;</span>, <span class="stringliteral">&#39;length_maps&#39;</span>, <span class="stringliteral">&#39;constraints&#39;</span>, <span class="stringliteral">&#39;ingoing_exp&#39;</span>,</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;             <span class="stringliteral">&#39;avg_ingoing_exp&#39;</span>, <span class="stringliteral">&#39;area&#39;</span>, <span class="stringliteral">&#39;ricci&#39;</span>, <span class="stringliteral">&#39;mean_curv&#39;</span>, <span class="stringliteral">&#39;curv2&#39;</span>,</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;             <span class="stringliteral">&#39;stability&#39;</span>, <span class="stringliteral">&#39;stability_null&#39;</span>, <span class="stringliteral">&#39;stability_convergence&#39;</span>,</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;             <span class="stringliteral">&#39;stability_convergence_null&#39;</span>, <span class="stringliteral">&#39;neck&#39;</span>, <span class="stringliteral">&#39;dist_top_bot&#39;</span>,</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;             <span class="stringliteral">&#39;z_dist_top_inner&#39;</span>, <span class="stringliteral">&#39;z_dist_bot_inner&#39;</span>, <span class="stringliteral">&#39;signature&#39;</span>,</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;             <span class="stringliteral">&#39;point_dists&#39;</span>, <span class="stringliteral">&#39;area_parts&#39;</span>, <span class="stringliteral">&#39;multipoles&#39;</span>)</div></div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym.html">axisym</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots.html">trackmots</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
