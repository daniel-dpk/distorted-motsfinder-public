<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: ExpansionCurve Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ExpansionCurve Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for curves that can calculate their expansion.  
 <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ExpansionCurve:</div>
<div class="dyncontent">
<div class="center"><img src="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve__inherit__graph.png" border="0" usemap="#ExpansionCurve_inherit__map" alt="Inheritance graph"/></div>
<map name="ExpansionCurve_inherit__map" id="ExpansionCurve_inherit__map">
<area shape="rect" id="node4" href="classmotsfinder_1_1axisym_1_1curve_1_1refparamcurve_1_1RefParamCurve.html" title="Represent a curve as offset function relative to another curve. " alt="" coords="5,229,121,256"/>
<area shape="rect" id="node5" href="classmotsfinder_1_1axisym_1_1curve_1_1starshapedcurve_1_1StarShapedCurve.html" title="Represent as angle&#45;dependent distance from some origin. " alt="" coords="146,229,271,256"/>
<area shape="rect" id="node2" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html" title="Base class for curves in the x&#45;z&#45;plane. " alt="" coords="92,80,179,107"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0c98b291b96568621e2fb6a792f9f9c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ac0c98b291b96568621e2fb6a792f9f9c">__init__</a> (self, h, metric, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>='')</td></tr>
<tr class="memdesc:ac0c98b291b96568621e2fb6a792f9f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class constructor taking a horizon function and metric.  <a href="#ac0c98b291b96568621e2fb6a792f9f9c">More...</a><br /></td></tr>
<tr class="separator:ac0c98b291b96568621e2fb6a792f9f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452fb35a3c468c1f56497580833a223d"><td class="memItemLeft" align="right" valign="top"><a id="a452fb35a3c468c1f56497580833a223d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__getstate__</b> (self)</td></tr>
<tr class="separator:a452fb35a3c468c1f56497580833a223d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a31d38355b42e85a3da79a04e33930"><td class="memItemLeft" align="right" valign="top"><a id="a37a31d38355b42e85a3da79a04e33930"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>__setstate__</b> (self, state)</td></tr>
<tr class="separator:a37a31d38355b42e85a3da79a04e33930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd30d50ea29610265ab20b4b27b5a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#abadd30d50ea29610265ab20b4b27b5a5">h_diff</a> (self, param)</td></tr>
<tr class="memdesc:abadd30d50ea29610265ab20b4b27b5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute derivative of this curve w.r.t. horizon function <code>h</code>.  <a href="#abadd30d50ea29610265ab20b4b27b5a5">More...</a><br /></td></tr>
<tr class="separator:abadd30d50ea29610265ab20b4b27b5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0e44490312b5e51fd7cdf3f8efbc9a"><td class="memItemLeft" align="right" valign="top"><a id="aaf0e44490312b5e51fd7cdf3f8efbc9a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>collocation_points</b> (self, lobatto=False, kw)</td></tr>
<tr class="separator:aaf0e44490312b5e51fd7cdf3f8efbc9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c47092b4b37fab331a7626ef63f342e"><td class="memItemLeft" align="right" valign="top"><a id="a4c47092b4b37fab331a7626ef63f342e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>arc_length</b> (self, a=0, b=np.pi, atol=1e-12, rtol=1e-12, full_output=False)</td></tr>
<tr class="separator:a4c47092b4b37fab331a7626ef63f342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99474abe4a99c3aba2cf55dcbf69ce8e"><td class="memItemLeft" align="right" valign="top"><a id="a99474abe4a99c3aba2cf55dcbf69ce8e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>proper_length_map</b> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, kw)</td></tr>
<tr class="separator:a99474abe4a99c3aba2cf55dcbf69ce8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2053028a7c722407c3e0156724d8969"><td class="memItemLeft" align="right" valign="top"><a id="ad2053028a7c722407c3e0156724d8969"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>z_distance</b> (self, other_curve=None, atol=1e-12, rtol=1e-12, limit=100, allow_intersection=False, full_output=False)</td></tr>
<tr class="separator:ad2053028a7c722407c3e0156724d8969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc03b763d08379e9a2f50e40952166c6"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#abc03b763d08379e9a2f50e40952166c6">inner_z_distance</a> (self, other_curve, where='top', full_output=False, kw)</td></tr>
<tr class="memdesc:abc03b763d08379e9a2f50e40952166c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the z-distance of two points of this and another curve.  <a href="#abc03b763d08379e9a2f50e40952166c6">More...</a><br /></td></tr>
<tr class="separator:abc03b763d08379e9a2f50e40952166c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38381b28dbb789e67f67a08a290f9894"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a38381b28dbb789e67f67a08a290f9894">inner_x_distance</a> (self, other_curve, where='zero', kw)</td></tr>
<tr class="memdesc:a38381b28dbb789e67f67a08a290f9894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the x-distance of two points of this and another curve.  <a href="#a38381b28dbb789e67f67a08a290f9894">More...</a><br /></td></tr>
<tr class="separator:a38381b28dbb789e67f67a08a290f9894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466e295d1bb8750fa1df2b746a0524a4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a466e295d1bb8750fa1df2b746a0524a4">get_calc_obj</a> (self, param)</td></tr>
<tr class="memdesc:a466e295d1bb8750fa1df2b746a0524a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or reuse a calculator object for a given parameter value.  <a href="#a466e295d1bb8750fa1df2b746a0524a4">More...</a><br /></td></tr>
<tr class="separator:a466e295d1bb8750fa1df2b746a0524a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af121af077346547f69460bdda05c371d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af121af077346547f69460bdda05c371d">horizon_function_changed</a> (self)</td></tr>
<tr class="memdesc:af121af077346547f69460bdda05c371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify this curve that the underlying horizon function has changed.  <a href="#af121af077346547f69460bdda05c371d">More...</a><br /></td></tr>
<tr class="separator:af121af077346547f69460bdda05c371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e123567df79f0eb5b554d595e328177"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a> (self)</td></tr>
<tr class="memdesc:a8e123567df79f0eb5b554d595e328177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution (number of DOFs) of the horizon function.  <a href="#a8e123567df79f0eb5b554d595e328177">More...</a><br /></td></tr>
<tr class="separator:a8e123567df79f0eb5b554d595e328177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e237fcc955d9e464d5c32fc84a840f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0e237fcc955d9e464d5c32fc84a840f9">resample</a> (self, new_num)</td></tr>
<tr class="memdesc:a0e237fcc955d9e464d5c32fc84a840f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of DOFs of the horizon function.  <a href="#a0e237fcc955d9e464d5c32fc84a840f9">More...</a><br /></td></tr>
<tr class="separator:a0e237fcc955d9e464d5c32fc84a840f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc2ab7c97360b53459877417ba7213"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a63fc2ab7c97360b53459877417ba7213">suspend_calc_obj</a> (self)</td></tr>
<tr class="memdesc:a63fc2ab7c97360b53459877417ba7213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager to temporarily ignore the current calculator.  <a href="#a63fc2ab7c97360b53459877417ba7213">More...</a><br /></td></tr>
<tr class="separator:a63fc2ab7c97360b53459877417ba7213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4424c4e81f70acc59bf8915971821c62"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4424c4e81f70acc59bf8915971821c62">suspend_curv</a> (self)</td></tr>
<tr class="memdesc:a4424c4e81f70acc59bf8915971821c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager to temporarily ignore the extrinsic curvature.  <a href="#a4424c4e81f70acc59bf8915971821c62">More...</a><br /></td></tr>
<tr class="separator:a4424c4e81f70acc59bf8915971821c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474b5d328f851a167e5a83cb99f7ed25"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a474b5d328f851a167e5a83cb99f7ed25">temp_metric</a> (self, metric=None)</td></tr>
<tr class="memdesc:a474b5d328f851a167e5a83cb99f7ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager to temporarily replace the used metric.  <a href="#a474b5d328f851a167e5a83cb99f7ed25">More...</a><br /></td></tr>
<tr class="separator:a474b5d328f851a167e5a83cb99f7ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d946c32710bf1ff05efb654bee672fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8d946c32710bf1ff05efb654bee672fc">expansion</a> (self, param, hdiff=None, ingoing=False)</td></tr>
<tr class="memdesc:a8d946c32710bf1ff05efb654bee672fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the expansion at one parameter value.  <a href="#a8d946c32710bf1ff05efb654bee672fc">More...</a><br /></td></tr>
<tr class="separator:a8d946c32710bf1ff05efb654bee672fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242dab961b882fae1ab7023a7dbeb44a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a242dab961b882fae1ab7023a7dbeb44a">expansions</a> (self, params, hdiff=None, ingoing=False)</td></tr>
<tr class="memdesc:a242dab961b882fae1ab7023a7dbeb44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8d946c32710bf1ff05efb654bee672fc" title="Compute the expansion at one parameter value. ">expansion()</a>, but on a whole set of parameter values.  <a href="#a242dab961b882fae1ab7023a7dbeb44a">More...</a><br /></td></tr>
<tr class="separator:a242dab961b882fae1ab7023a7dbeb44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3232841413c3ca20d1a872d5ecd837ea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3232841413c3ca20d1a872d5ecd837ea">average_expansion</a> (self, ingoing=False, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aac06a1badf4a956bccce3fad0693d948">area</a>=None, full_output=False, kw)</td></tr>
<tr class="memdesc:a3232841413c3ca20d1a872d5ecd837ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average expansion across the surface.  <a href="#a3232841413c3ca20d1a872d5ecd837ea">More...</a><br /></td></tr>
<tr class="separator:a3232841413c3ca20d1a872d5ecd837ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e3cdfacfd16d42836d8bf5893eecf5"><td class="memItemLeft" align="right" valign="top"><a id="a22e3cdfacfd16d42836d8bf5893eecf5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>signature_quantities</b> (self, pts, past_curve=None, future_curve=None)</td></tr>
<tr class="separator:a22e3cdfacfd16d42836d8bf5893eecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f87fe8930191d84b8a0f9c878f3078"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af2f87fe8930191d84b8a0f9c878f3078">linearized_equation_at</a> (self, param, target_expansion=0.0)</td></tr>
<tr class="memdesc:af2f87fe8930191d84b8a0f9c878f3078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the terms of the linearized version of H=0 at one point.  <a href="#af2f87fe8930191d84b8a0f9c878f3078">More...</a><br /></td></tr>
<tr class="separator:af2f87fe8930191d84b8a0f9c878f3078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287674a9252dd9228d16780a17670129"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a287674a9252dd9228d16780a17670129">linearized_equation</a> (self, params, target_expansion=0.0, parallel=False, pool=None)</td></tr>
<tr class="memdesc:a287674a9252dd9228d16780a17670129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return linearized equation as operator and inhomogeneity on a grid.  <a href="#a287674a9252dd9228d16780a17670129">More...</a><br /></td></tr>
<tr class="separator:a287674a9252dd9228d16780a17670129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b59585b2daf3036737fe2e3a3a9f80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a05b59585b2daf3036737fe2e3a3a9f80">ricci_scalar</a> (self, param)</td></tr>
<tr class="memdesc:a05b59585b2daf3036737fe2e3a3a9f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Ricci scalar of the surface at the given parameter.  <a href="#a05b59585b2daf3036737fe2e3a3a9f80">More...</a><br /></td></tr>
<tr class="separator:a05b59585b2daf3036737fe2e3a3a9f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ef465ecbfd8d1a0f5413bda0a8f325"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a49ef465ecbfd8d1a0f5413bda0a8f325">extrinsic_surface_curvature</a> (self, param, trace=False, square=False)</td></tr>
<tr class="memdesc:a49ef465ecbfd8d1a0f5413bda0a8f325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extrinsic curvature tensor of the surface.  <a href="#a49ef465ecbfd8d1a0f5413bda0a8f325">More...</a><br /></td></tr>
<tr class="separator:a49ef465ecbfd8d1a0f5413bda0a8f325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac06a1badf4a956bccce3fad0693d948"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aac06a1badf4a956bccce3fad0693d948">area</a> (self, full_output=False, disp=False, domain=(0, np.pi), kw)</td></tr>
<tr class="memdesc:aac06a1badf4a956bccce3fad0693d948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area of the surface represented by this curve.  <a href="#aac06a1badf4a956bccce3fad0693d948">More...</a><br /></td></tr>
<tr class="separator:aac06a1badf4a956bccce3fad0693d948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca583853d9351f18fdd647ddc7b109d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a2ca583853d9351f18fdd647ddc7b109d">get_det_q_func</a> (self)</td></tr>
<tr class="memdesc:a2ca583853d9351f18fdd647ddc7b109d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function to evaluate det(q).  <a href="#a2ca583853d9351f18fdd647ddc7b109d">More...</a><br /></td></tr>
<tr class="separator:a2ca583853d9351f18fdd647ddc7b109d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea218e8051c9c6b433fc008c252d9b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#afea218e8051c9c6b433fc008c252d9b1">get_area_integrand</a> (self)</td></tr>
<tr class="memdesc:afea218e8051c9c6b433fc008c252d9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a callable evaluating the sqrt(det(q)), i.e.  <a href="#afea218e8051c9c6b433fc008c252d9b1">More...</a><br /></td></tr>
<tr class="separator:afea218e8051c9c6b433fc008c252d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fec2419badaa52a2606abc7f398dc1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a21fec2419badaa52a2606abc7f398dc1">euler_char</a> (self, a=0, b=np.pi, full_output=False, disp=False, kw)</td></tr>
<tr class="memdesc:a21fec2419badaa52a2606abc7f398dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euler characteristic of the surface.  <a href="#a21fec2419badaa52a2606abc7f398dc1">More...</a><br /></td></tr>
<tr class="separator:a21fec2419badaa52a2606abc7f398dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5c33ef11a8f6531a62f65777be3a34"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aea5c33ef11a8f6531a62f65777be3a34">irreducible_mass</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aac06a1badf4a956bccce3fad0693d948">area</a>=None)</td></tr>
<tr class="memdesc:aea5c33ef11a8f6531a62f65777be3a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the irreducible mass.  <a href="#aea5c33ef11a8f6531a62f65777be3a34">More...</a><br /></td></tr>
<tr class="separator:aea5c33ef11a8f6531a62f65777be3a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321e36a1dbf23d671dda1f83832d8d07"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a321e36a1dbf23d671dda1f83832d8d07">horizon_radius</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aac06a1badf4a956bccce3fad0693d948">area</a>=None)</td></tr>
<tr class="memdesc:a321e36a1dbf23d671dda1f83832d8d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the horizon radius.  <a href="#a321e36a1dbf23d671dda1f83832d8d07">More...</a><br /></td></tr>
<tr class="separator:a321e36a1dbf23d671dda1f83832d8d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ec805e4184cc43bfc37a4f801c204"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a261ec805e4184cc43bfc37a4f801c204">stability_parameter</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, m_max=None, m_terminate_index=30, rtol=1e-12, compute_eigenfunctions=False, slice_normal=True, transform_torsion=False, full_output=False)</td></tr>
<tr class="memdesc:a261ec805e4184cc43bfc37a4f801c204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability parameter.  <a href="#a261ec805e4184cc43bfc37a4f801c204">More...</a><br /></td></tr>
<tr class="separator:a261ec805e4184cc43bfc37a4f801c204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1593d55a85a61e1578c554b68370f9d7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a1593d55a85a61e1578c554b68370f9d7">multipoles</a> (self, max_n=10, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, full_output=False, disp=False, kw)</td></tr>
<tr class="memdesc:a1593d55a85a61e1578c554b68370f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the multipoles I_n of the horizon.  <a href="#a1593d55a85a61e1578c554b68370f9d7">More...</a><br /></td></tr>
<tr class="separator:a1593d55a85a61e1578c554b68370f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1289f5b3e099b0f8f124aaa50be6b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3d1289f5b3e099b0f8f124aaa50be6b1">circumference</a> (self, param)</td></tr>
<tr class="memdesc:a3d1289f5b3e099b0f8f124aaa50be6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the circumference of the surface at the given parameter.  <a href="#a3d1289f5b3e099b0f8f124aaa50be6b1">More...</a><br /></td></tr>
<tr class="separator:a3d1289f5b3e099b0f8f124aaa50be6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d876f9c0547a82a18593efaf10f2c1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ab5d876f9c0547a82a18593efaf10f2c1">x_distance</a> (self, param, kw)</td></tr>
<tr class="memdesc:ab5d876f9c0547a82a18593efaf10f2c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the proper length of a coordinate line from the curve to the z-axis.  <a href="#ab5d876f9c0547a82a18593efaf10f2c1">More...</a><br /></td></tr>
<tr class="separator:ab5d876f9c0547a82a18593efaf10f2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0922cb5b5e48ced63e8f638f75fedc4a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0922cb5b5e48ced63e8f638f75fedc4a">find_neck</a> (self, algo='coord', xtol=1e-8, kw)</td></tr>
<tr class="memdesc:a0922cb5b5e48ced63e8f638f75fedc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to locate a 'neck' of this curve.  <a href="#a0922cb5b5e48ced63e8f638f75fedc4a">More...</a><br /></td></tr>
<tr class="separator:a0922cb5b5e48ced63e8f638f75fedc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb06f51cca9db99704ae9fe5eac6a26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#afdb06f51cca9db99704ae9fe5eac6a26">locate_intersection</a> (self, other_curve, xtol=1e-8, domain1=(0, np.pi), domain2=(0, np.pi), strict1=True, strict2=True, N1=20, N2=20)</td></tr>
<tr class="memdesc:afdb06f51cca9db99704ae9fe5eac6a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate one point at which this curve intersects another curve.  <a href="#afdb06f51cca9db99704ae9fe5eac6a26">More...</a><br /></td></tr>
<tr class="separator:afdb06f51cca9db99704ae9fe5eac6a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca1e6cd728f86908a070a06765d59ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6ca1e6cd728f86908a070a06765d59ae">locate_self_intersection</a> (self, neck=None, xtol=1e-8)</td></tr>
<tr class="memdesc:a6ca1e6cd728f86908a070a06765d59ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate a <em>loop</em> in the MOTS around its neck.  <a href="#a6ca1e6cd728f86908a070a06765d59ae">More...</a><br /></td></tr>
<tr class="separator:a6ca1e6cd728f86908a070a06765d59ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e142fbf691a6c614554fea33624c1e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a12e142fbf691a6c614554fea33624c1e">get_distance_function</a> (self, other_curve, Ns=None, xatol=1e-12, mp_finish=True, dps=50, minima_to_check=1)</td></tr>
<tr class="memdesc:a12e142fbf691a6c614554fea33624c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a callable computing the distance between this and another curve.  <a href="#a12e142fbf691a6c614554fea33624c1e">More...</a><br /></td></tr>
<tr class="separator:a12e142fbf691a6c614554fea33624c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5affff3f10d450ec714b967e25971644"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5affff3f10d450ec714b967e25971644">plot_expansion</a> (self, c=0, points=500, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>=r&quot;\mma&quot;, figsize=(5, 3), verbose=True, ingoing=False, kw)</td></tr>
<tr class="memdesc:a5affff3f10d450ec714b967e25971644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to plot the expansion along the curve.  <a href="#a5affff3f10d450ec714b967e25971644">More...</a><br /></td></tr>
<tr class="separator:a5affff3f10d450ec714b967e25971644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d19c53e7e580b11b2a3d934a60f4b13"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4d19c53e7e580b11b2a3d934a60f4b13">plot_coeffs</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>=r&quot;\mma&quot;, figsize=(5, 3), kw)</td></tr>
<tr class="memdesc:a4d19c53e7e580b11b2a3d934a60f4b13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to plot the horizon function's spectral coefficients.  <a href="#a4d19c53e7e580b11b2a3d934a60f4b13">More...</a><br /></td></tr>
<tr class="separator:a4d19c53e7e580b11b2a3d934a60f4b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html">BaseCurve</a></td></tr>
<tr class="memitem:adf720f5b495cd977ef9d261d5f20b7bf inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#adf720f5b495cd977ef9d261d5f20b7bf">__init__</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>='')</td></tr>
<tr class="memdesc:adf720f5b495cd977ef9d261d5f20b7bf inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baseclass init for curves.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#adf720f5b495cd977ef9d261d5f20b7bf">More...</a><br /></td></tr>
<tr class="separator:adf720f5b495cd977ef9d261d5f20b7bf inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3700b94d209d5fc275b75342c97ab92a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a3700b94d209d5fc275b75342c97ab92a">save</a> (self, filename, overwrite=False, verbose=True, msg='')</td></tr>
<tr class="memdesc:a3700b94d209d5fc275b75342c97ab92a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the curve to disk.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a3700b94d209d5fc275b75342c97ab92a">More...</a><br /></td></tr>
<tr class="separator:a3700b94d209d5fc275b75342c97ab92a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452fb35a3c468c1f56497580833a223d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a452fb35a3c468c1f56497580833a223d">__getstate__</a> (self)</td></tr>
<tr class="memdesc:a452fb35a3c468c1f56497580833a223d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a picklable state object representing the whole curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a452fb35a3c468c1f56497580833a223d">More...</a><br /></td></tr>
<tr class="separator:a452fb35a3c468c1f56497580833a223d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a31d38355b42e85a3da79a04e33930 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a37a31d38355b42e85a3da79a04e33930">__setstate__</a> (self, state)</td></tr>
<tr class="memdesc:a37a31d38355b42e85a3da79a04e33930 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a complete curve from the given unpickled state.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a37a31d38355b42e85a3da79a04e33930">More...</a><br /></td></tr>
<tr class="separator:a37a31d38355b42e85a3da79a04e33930 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade300aee3cd305ca4ada280d408f471c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ade300aee3cd305ca4ada280d408f471c">user_data</a> (self)</td></tr>
<tr class="memdesc:ade300aee3cd305ca4ada280d408f471c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary of custom data stored in the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ade300aee3cd305ca4ada280d408f471c">More...</a><br /></td></tr>
<tr class="separator:ade300aee3cd305ca4ada280d408f471c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5907ca3bbf8e7cd8f40c3007338f6d02 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a> (self)</td></tr>
<tr class="memdesc:a5907ca3bbf8e7cd8f40c3007338f6d02 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this curve (used e.g. as label for plotting).  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">More...</a><br /></td></tr>
<tr class="separator:a5907ca3bbf8e7cd8f40c3007338f6d02 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d212fdcbbcee30e90a64ce349d32f8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a62d212fdcbbcee30e90a64ce349d32f8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> (self, value)</td></tr>
<tr class="separator:a62d212fdcbbcee30e90a64ce349d32f8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f62eec984a99f7a9a7ee58c40cd4c4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a10f62eec984a99f7a9a7ee58c40cd4c4">override_evaluator</a> (self, evaluator)</td></tr>
<tr class="memdesc:a10f62eec984a99f7a9a7ee58c40cd4c4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for temporarily overriding the evaluator(s) used.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a10f62eec984a99f7a9a7ee58c40cd4c4">More...</a><br /></td></tr>
<tr class="separator:a10f62eec984a99f7a9a7ee58c40cd4c4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6386ff53ecf46bc525a3cb16448ae413 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6386ff53ecf46bc525a3cb16448ae413">fix_evaluator</a> (self)</td></tr>
<tr class="memdesc:a6386ff53ecf46bc525a3cb16448ae413 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context to temporarily fix the evaluator(s) of used expressions.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6386ff53ecf46bc525a3cb16448ae413">More...</a><br /></td></tr>
<tr class="separator:a6386ff53ecf46bc525a3cb16448ae413 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfc1c44054807f99ee5e5052ee6d4db inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abdfc1c44054807f99ee5e5052ee6d4db">freeze_evaluator</a> (self)</td></tr>
<tr class="memdesc:abdfc1c44054807f99ee5e5052ee6d4db inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indefinitely freeze all evaluators of this curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abdfc1c44054807f99ee5e5052ee6d4db">More...</a><br /></td></tr>
<tr class="separator:abdfc1c44054807f99ee5e5052ee6d4db inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86324d541d9b0f48b3cfe8647467613 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ad86324d541d9b0f48b3cfe8647467613">unfreeze_evaluator</a> (self)</td></tr>
<tr class="memdesc:ad86324d541d9b0f48b3cfe8647467613 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo a <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abdfc1c44054807f99ee5e5052ee6d4db" title="Indefinitely freeze all evaluators of this curve. ">freeze_evaluator()</a> call.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ad86324d541d9b0f48b3cfe8647467613">More...</a><br /></td></tr>
<tr class="separator:ad86324d541d9b0f48b3cfe8647467613 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174ee487da3aeeb80f401bac6659a5b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6174ee487da3aeeb80f401bac6659a5b">force_evaluator_update</a> (self)</td></tr>
<tr class="memdesc:a6174ee487da3aeeb80f401bac6659a5b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force all cached evaluators to be refreshed.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6174ee487da3aeeb80f401bac6659a5b">More...</a><br /></td></tr>
<tr class="separator:a6174ee487da3aeeb80f401bac6659a5b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6261b742ae694c16790726a8c77c5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aebf6261b742ae694c16790726a8c77c5">copy</a> (self)</td></tr>
<tr class="memdesc:aebf6261b742ae694c16790726a8c77c5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an independent copy of this curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aebf6261b742ae694c16790726a8c77c5">More...</a><br /></td></tr>
<tr class="separator:aebf6261b742ae694c16790726a8c77c5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac216f7b7ba5435436bdb601aebe7b284 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac216f7b7ba5435436bdb601aebe7b284">__call__</a> (self, param, xyz=False)</td></tr>
<tr class="memdesc:ac216f7b7ba5435436bdb601aebe7b284 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curve at a particular parameter value.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac216f7b7ba5435436bdb601aebe7b284">More...</a><br /></td></tr>
<tr class="separator:ac216f7b7ba5435436bdb601aebe7b284 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f370c7e8e1286146a7f0878615a2575 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2f370c7e8e1286146a7f0878615a2575">collocation_points</a> (self, kw)</td></tr>
<tr class="memdesc:a2f370c7e8e1286146a7f0878615a2575 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the collocation points of the current curve representation.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2f370c7e8e1286146a7f0878615a2575">More...</a><br /></td></tr>
<tr class="separator:a2f370c7e8e1286146a7f0878615a2575 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ab29fbc886ed361b8bd4e78a468cd inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">diff</a> (self, param, diff=1, xyz=False)</td></tr>
<tr class="memdesc:af90ab29fbc886ed361b8bd4e78a468cd inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of this curve w.r.t. its parameter.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">More...</a><br /></td></tr>
<tr class="separator:af90ab29fbc886ed361b8bd4e78a468cd inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f6d98c9d65d438f6883a7b11628cac inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac4f6d98c9d65d438f6883a7b11628cac">tangent</a> (self, param, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">diff</a>=0, xyz=False)</td></tr>
<tr class="memdesc:ac4f6d98c9d65d438f6883a7b11628cac inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidean) tangent vector or one of its derivatives.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac4f6d98c9d65d438f6883a7b11628cac">More...</a><br /></td></tr>
<tr class="separator:ac4f6d98c9d65d438f6883a7b11628cac inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde5537a950b9c8a5e0c430fc86d91d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1bde5537a950b9c8a5e0c430fc86d91d">normal</a> (self, param, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">diff</a>=0, xyz=False)</td></tr>
<tr class="memdesc:a1bde5537a950b9c8a5e0c430fc86d91d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidean) normal vector or a derivative thereof.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1bde5537a950b9c8a5e0c430fc86d91d">More...</a><br /></td></tr>
<tr class="separator:a1bde5537a950b9c8a5e0c430fc86d91d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb82a7718f79c5641e8caf3d3c86da5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2eb82a7718f79c5641e8caf3d3c86da5">curvature_in_coord_space</a> (self, param)</td></tr>
<tr class="memdesc:a2eb82a7718f79c5641e8caf3d3c86da5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curvature of this curve in flat coordinate space.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2eb82a7718f79c5641e8caf3d3c86da5">More...</a><br /></td></tr>
<tr class="separator:a2eb82a7718f79c5641e8caf3d3c86da5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd813da94de7a86721ed6f86e581008 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aecd813da94de7a86721ed6f86e581008">arc_length</a> (self, a=0, b=np.pi, atol=1e-12, rtol=1e-12, limit=100, full_output=False)</td></tr>
<tr class="memdesc:aecd813da94de7a86721ed6f86e581008 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aecd813da94de7a86721ed6f86e581008">More...</a><br /></td></tr>
<tr class="separator:aecd813da94de7a86721ed6f86e581008 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf941a618b577b673e4d897bca584d7 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7">arc_length_using_metric</a> (self, metric, a=0, b=np.pi, atol=1e-12, rtol=1e-12, limit=100, full_output=False)</td></tr>
<tr class="memdesc:a0bf941a618b577b673e4d897bca584d7 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of this curve w.r.t. a given metric.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7">More...</a><br /></td></tr>
<tr class="separator:a0bf941a618b577b673e4d897bca584d7 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0947d643e386c5ab4ac57734fabfec58 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0947d643e386c5ab4ac57734fabfec58">proper_length_map</a> (self, num=None, evaluators=True, full_output=False, kw)</td></tr>
<tr class="memdesc:a0947d643e386c5ab4ac57734fabfec58 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate functions to map between curve parameter and proper length.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0947d643e386c5ab4ac57734fabfec58">More...</a><br /></td></tr>
<tr class="separator:a0947d643e386c5ab4ac57734fabfec58 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2053028a7c722407c3e0156724d8969 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ad2053028a7c722407c3e0156724d8969">z_distance</a> (self, other_curve=None, atol=1e-12, rtol=1e-12, limit=100, allow_intersection=False, full_output=False)</td></tr>
<tr class="memdesc:ad2053028a7c722407c3e0156724d8969 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the z-distance to another curve or the origin.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ad2053028a7c722407c3e0156724d8969">More...</a><br /></td></tr>
<tr class="separator:ad2053028a7c722407c3e0156724d8969 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beed94746c44987d8fce97cc3173d24 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1beed94746c44987d8fce97cc3173d24">z_distance_using_metric</a> (self, metric, other_curve=None, atol=1e-12, rtol=1e-12, limit=100, allow_intersection=False, full_output=False)</td></tr>
<tr class="memdesc:a1beed94746c44987d8fce97cc3173d24 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute z-distance to another curve w.r.t. a given metric.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1beed94746c44987d8fce97cc3173d24">More...</a><br /></td></tr>
<tr class="separator:a1beed94746c44987d8fce97cc3173d24 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8fe559aeaa7a8bd70a89a39bb2fb94 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0d8fe559aeaa7a8bd70a89a39bb2fb94">rotate_to_xz_plane</a> (self, point)</td></tr>
<tr class="memdesc:a0d8fe559aeaa7a8bd70a89a39bb2fb94 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a 3D point onto the x-z-plane with positive x.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0d8fe559aeaa7a8bd70a89a39bb2fb94">More...</a><br /></td></tr>
<tr class="separator:a0d8fe559aeaa7a8bd70a89a39bb2fb94 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d4bbd33a7d210f88789216f24ec9d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af0d4bbd33a7d210f88789216f24ec9d5">closest_point</a> (self, point, start_param=None, Ns=25)</td></tr>
<tr class="memdesc:af0d4bbd33a7d210f88789216f24ec9d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the parameter at which the curve is closest to a given point.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af0d4bbd33a7d210f88789216f24ec9d5">More...</a><br /></td></tr>
<tr class="separator:af0d4bbd33a7d210f88789216f24ec9d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06de71936f2ea3123e81da7cdf38e594 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a06de71936f2ea3123e81da7cdf38e594">find_line_intersection</a> (self, point, vector, Ns=50)</td></tr>
<tr class="memdesc:a06de71936f2ea3123e81da7cdf38e594 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the point at which this curve intersects a given line.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a06de71936f2ea3123e81da7cdf38e594">More...</a><br /></td></tr>
<tr class="separator:a06de71936f2ea3123e81da7cdf38e594 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c7cd146b41d259e63a054663978a2d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a66c7cd146b41d259e63a054663978a2d">find_max_x</a> (self, Ns=50)</td></tr>
<tr class="memdesc:a66c7cd146b41d259e63a054663978a2d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the point of the curve with maximum distance to the z-axis.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a66c7cd146b41d259e63a054663978a2d">More...</a><br /></td></tr>
<tr class="separator:a66c7cd146b41d259e63a054663978a2d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9679540ba891f22d4d5807a67f9e50b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ae9679540ba891f22d4d5807a67f9e50b">inf_norm</a> (self, other_curve, kw)</td></tr>
<tr class="memdesc:ae9679540ba891f22d4d5807a67f9e50b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L_inf norm of this curve minus another curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ae9679540ba891f22d4d5807a67f9e50b">More...</a><br /></td></tr>
<tr class="separator:ae9679540ba891f22d4d5807a67f9e50b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fd2069205163d29380e6e8dd5e62d8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a30fd2069205163d29380e6e8dd5e62d8">point_distances</a> (self, params=None)</td></tr>
<tr class="memdesc:a30fd2069205163d29380e6e8dd5e62d8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coordinate distances of points along the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a30fd2069205163d29380e6e8dd5e62d8">More...</a><br /></td></tr>
<tr class="separator:a30fd2069205163d29380e6e8dd5e62d8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f3e555bf32dfac79e9bf37783aea48 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a01f3e555bf32dfac79e9bf37783aea48">plot_distances</a> (self, params=None, kw)</td></tr>
<tr class="memdesc:a01f3e555bf32dfac79e9bf37783aea48 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for quickly plotting coordinate distances of collocation points.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a01f3e555bf32dfac79e9bf37783aea48">More...</a><br /></td></tr>
<tr class="separator:a01f3e555bf32dfac79e9bf37783aea48 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3abd3fbea9be82da82aa7b20982edd18 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a3abd3fbea9be82da82aa7b20982edd18">plot</a> (self, lw=2, equal_lengths=True, copy_x=True, kw)</td></tr>
<tr class="memdesc:a3abd3fbea9be82da82aa7b20982edd18 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot the curve represented by this object.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a3abd3fbea9be82da82aa7b20982edd18">More...</a><br /></td></tr>
<tr class="separator:a3abd3fbea9be82da82aa7b20982edd18 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5e36941b3d856737e81516acd45edc50"><td class="memItemLeft" align="right" valign="top"><a id="a5e36941b3d856737e81516acd45edc50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>h</b></td></tr>
<tr class="separator:a5e36941b3d856737e81516acd45edc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0cae22c2d95be3ff185398d62a4a32"><td class="memItemLeft" align="right" valign="top"><a id="a5d0cae22c2d95be3ff185398d62a4a32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>metric</b></td></tr>
<tr class="separator:a5d0cae22c2d95be3ff185398d62a4a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0898b285d76b1bc8480f855f81cd74ef"><td class="memItemLeft" align="right" valign="top"><a id="a0898b285d76b1bc8480f855f81cd74ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>extr_curvature</b></td></tr>
<tr class="separator:a0898b285d76b1bc8480f855f81cd74ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html">BaseCurve</a></td></tr>
<tr class="memitem:a8a6287602630db6aeffcb6cf5787a216 inherit pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a8a6287602630db6aeffcb6cf5787a216"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>domain</b></td></tr>
<tr class="separator:a8a6287602630db6aeffcb6cf5787a216 inherit pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af3056926ad0964c2b80f97a192ad8c89"><td class="memItemLeft" align="right" valign="top"><a id="af3056926ad0964c2b80f97a192ad8c89"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>_create_evaluators</b> (self)</td></tr>
<tr class="separator:af3056926ad0964c2b80f97a192ad8c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ba5441991ba928333e024d28a0c5d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a56ba5441991ba928333e024d28a0c5d4">_create_calc_obj</a> (self, param)</td></tr>
<tr class="memdesc:a56ba5441991ba928333e024d28a0c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cache/calculator for a specific parameter value.  <a href="#a56ba5441991ba928333e024d28a0c5d4">More...</a><br /></td></tr>
<tr class="separator:a56ba5441991ba928333e024d28a0c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a14271c4bcf292a4c843cc8edaf8fba"><td class="memItemLeft" align="right" valign="top"><a id="a8a14271c4bcf292a4c843cc8edaf8fba"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>_cached_stability_op</b> (self, func, pts, m, cache=None, kw)</td></tr>
<tr class="separator:a8a14271c4bcf292a4c843cc8edaf8fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae140ab19abd6ce8f0f3448a685113abf"><td class="memItemLeft" align="right" valign="top"><a id="ae140ab19abd6ce8f0f3448a685113abf"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ae140ab19abd6ce8f0f3448a685113abf">_stability_eigenvalue_equation_timesym</a> (self, pts, slice_normal, transform_torsion)</td></tr>
<tr class="memdesc:ae140ab19abd6ce8f0f3448a685113abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue equation evaluator for time-symmetric case. <br /></td></tr>
<tr class="separator:ae140ab19abd6ce8f0f3448a685113abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e3196d9adc51db55bba3688db8697"><td class="memItemLeft" align="right" valign="top"><a id="a6e7e3196d9adc51db55bba3688db8697"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6e7e3196d9adc51db55bba3688db8697">_stability_eigenvalue_equation_general</a> (self, pts, slice_normal, transform_torsion)</td></tr>
<tr class="memdesc:a6e7e3196d9adc51db55bba3688db8697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue equation evaluator for the general case. <br /></td></tr>
<tr class="separator:a6e7e3196d9adc51db55bba3688db8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729cfd2b525e29c406af01b6e413cd94"><td class="memItemLeft" align="right" valign="top"><a id="a729cfd2b525e29c406af01b6e413cd94"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a729cfd2b525e29c406af01b6e413cd94">_locate_self_intersection</a> (self, neck, xtol)</td></tr>
<tr class="memdesc:a729cfd2b525e29c406af01b6e413cd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6ca1e6cd728f86908a070a06765d59ae" title="Locate a loop in the MOTS around its neck. ">locate_self_intersection()</a>. <br /></td></tr>
<tr class="separator:a729cfd2b525e29c406af01b6e413cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeee148d074b5656912a95a1515100102"><td class="memItemLeft" align="right" valign="top"><a id="aeee148d074b5656912a95a1515100102"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_calc</b></td></tr>
<tr class="separator:aeee148d074b5656912a95a1515100102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html">BaseCurve</a></td></tr>
<tr class="memitem:abaa7ea341ccde12aa7ad22b948b714b6 inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abaa7ea341ccde12aa7ad22b948b714b6">load</a> (filename)</td></tr>
<tr class="memdesc:abaa7ea341ccde12aa7ad22b948b714b6 inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function to load an expression object from disk.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abaa7ea341ccde12aa7ad22b948b714b6">More...</a><br /></td></tr>
<tr class="separator:abaa7ea341ccde12aa7ad22b948b714b6 inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633ad52910822ac982ff3214ec097451 inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a633ad52910822ac982ff3214ec097451">plot_curves</a> (curves, cmap=None, last_callback=None, kw)</td></tr>
<tr class="memdesc:a633ad52910822ac982ff3214ec097451 inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method for plotting multiple curves in the same plot.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a633ad52910822ac982ff3214ec097451">More...</a><br /></td></tr>
<tr class="separator:a633ad52910822ac982ff3214ec097451 inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for curves that can calculate their expansion. </p>
<p>This base class implements the functionality common to all concrete curve classes that are aware of the geometry they are living in. These take the Riemannian 3-metric and extrinsic curvature of the slice to compute quantities such as the expansion.</p>
<p>Most of the actual calculation of these quantities is done in so called "calculation" objects that exist for a specific point on the curve and cache and reuse interim results.</p>
<p>In addition to the abstract functions in <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html" title="Base class for curves in the x-z-plane. ">basecurve.BaseCurve</a> not implemented here, subclasses need to implement the following additional functions:</p><ul>
<li><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aebf6261b742ae694c16790726a8c77c5" title="Create an independent copy of this curve. ">copy()</a> to create an independent copy of the curve</li>
<li><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a56ba5441991ba928333e024d28a0c5d4" title="Create a cache/calculator for a specific parameter value. ">_create_calc_obj()</a> to create the cache/calculator object </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac0c98b291b96568621e2fb6a792f9f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c98b291b96568621e2fb6a792f9f9c">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class constructor taking a horizon function and metric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>(<a class="el" href="classmotsfinder_1_1exprs_1_1numexpr_1_1NumericExpression.html" title="Parent class for numeric expressions. ">exprs.numexpr.NumericExpression</a>) The "horizon function" defining this curve. How this function is interpreted is up to the subclass and its calculator object. </td></tr>
    <tr><td class="paramname">metric</td><td>The Riemannian 3-metric defining the geometry of the surrounding space. </td></tr>
    <tr><td class="paramname">name</td><td>Name of this curve. This may be used when printing information about this curve or as label in plots. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a56ba5441991ba928333e024d28a0c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ba5441991ba928333e024d28a0c5d4">&#9670;&nbsp;</a></span>_create_calc_obj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _create_calc_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a cache/calculator for a specific parameter value. </p>
<p>This is only called when a new calculator object needs to be constructed (i.e. this is a calculator factory). Subclasses should create the respective calculator type they need. </p>

</div>
</div>
<a id="aac06a1badf4a956bccce3fad0693d948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac06a1badf4a956bccce3fad0693d948">&#9670;&nbsp;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def area </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>(0,&#160;np.pi)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the area of the surface represented by this curve. </p>
<p>Note that no warning will be generated in case the integral does not converge properly. To obtain information about such warnings, either set <code>disp=True</code> to raise an error in these cases, or use <code>full_output=True</code> and check if the last returned element is <code>None</code> (signaling no problem was found).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return a 4-tuple containing the computed area, an estimated error, the <code>infodict</code> result of <code>scipy.integrate.quad</code> and any generated warning message. This fourth element will be <code>None</code> in case no warning occurred. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">disp</td><td>If <code>Ture</code>, raise any warnings generated during integration as an <code><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1IntegrationError.html" title="Raised for non-converging integrals or if accuracy cannot be reached. ">IntegrationError</a></code>. </td></tr>
    <tr><td class="paramname">domain</td><td>Parameter range to integrate over. Default is the full surface, i.e. <code>(0, pi)</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments are passed to <code>scipy.integrate.quad</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed area. See also <code>full_output</code> above.</dd></dl>
<p><b>Notes</b> </p>
<p>The area of the surface <img class="formulaInl" alt="$\sigma$" src="form_97.png"/> is defined as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A = \int_\sigma \sqrt{\det q}\ d^2x, \]" src="form_125.png"/>
</p>
<p> where </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ q = \Pi_\sigma g = g\big|_\sigma - \underline{\nu} \otimes \underline{\nu}, \qquad q_{ab} = g_{ab} - \nu_a \nu_b \]" src="form_126.png"/>
</p>
<p> is the induced metric on <img class="formulaInl" alt="$\sigma$" src="form_97.png"/> (compare equation (2) in [1]). Here, <img class="formulaInl" alt="$\nu$" src="form_12.png"/> is the outward pointing normal of <img class="formulaInl" alt="$\sigma$" src="form_97.png"/> and <img class="formulaInl" alt="$\underline{\nu} = g(\nu,\,\cdot\,)$" src="form_127.png"/>.</p>
<p><b>References</b> </p>
<p>[1] Gundlach, Carsten. "Pseudospectral apparent horizon finders: An
     efficient new algorithm." Physical Review D 57.2 (1998): 863. </p>

</div>
</div>
<a id="a3232841413c3ca20d1a872d5ecd837ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3232841413c3ca20d1a872d5ecd837ea">&#9670;&nbsp;</a></span>average_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def average_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average expansion across the surface. </p>
<p>This computes the average expansion </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \overline\Theta = \frac{1}{A} \int \Theta \sqrt{q}\ d^2x. \]" src="form_318.png"/>
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ingoing</td><td>Whether to average over the ingoing (<code>True</code>) or outgoing (<code>False</code>) expansion. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">area</td><td>Optionally re-use an already computed area value. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the average expansion and the estimated error. Otherwise return just the average expansion. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments are passed to <code>scipy.integrate.quad</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d1289f5b3e099b0f8f124aaa50be6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d1289f5b3e099b0f8f124aaa50be6b1">&#9670;&nbsp;</a></span>circumference()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def circumference </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the circumference of the surface at the given parameter. </p>

</div>
</div>
<a id="a21fec2419badaa52a2606abc7f398dc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fec2419badaa52a2606abc7f398dc1">&#9670;&nbsp;</a></span>euler_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def euler_char </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>np.pi</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euler characteristic of the surface. </p>
<p>This assumes the curve to represent a closed (compact) smooth surface without boundary. As such, we get by the Gauss-Bonnet theorem </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ 2\pi\chi(\mathcal{S}) = \frac{1}{2} \int_\mathcal{S} \mathcal{R}\ dA, \]" src="form_405.png"/>
</p>
<p> where <img class="formulaInl" alt="$\chi$" src="form_406.png"/> is the Euler characteristic of the surface <img class="formulaInl" alt="$\mathcal{S}$" src="form_407.png"/> which is represented by this curve and <img class="formulaInl" alt="$\mathcal{R}$" src="form_408.png"/> its Ricci (scalar) curvature.</p>
<p>In axisymmetry and corresponding coordinates, we can carry out the integral over the angle <img class="formulaInl" alt="$\phi$" src="form_409.png"/>, which gives <img class="formulaInl" alt="$2\pi$" src="form_410.png"/> and end up with </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \chi(\mathcal{S}) = \frac{1}{2} \int_0^\pi \mathcal{R}(\lambda)\sqrt{q}\ d\lambda, \]" src="form_411.png"/>
</p>
<p> where <img class="formulaInl" alt="$\sqrt{q}$" src="form_412.png"/> is the square root of the determinant of the induced metric <code>q</code>.</p>
<p>From the Euler characteristic, you can compute the genus <code>G</code> of the surface via <img class="formulaInl" alt="$G = -\chi/2 + 1$" src="form_413.png"/>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>Curve parameters between which to integrate. Defaults are <code>0</code> and <code>pi</code>, respectively. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to return information about the integration in addition to the value. If <code>True</code>, return a tuple of <code>chi, chi_err, info, warning</code>. Otherwise (default), return just <code>chi</code>. If <code>warning</code> is not <code>None</code>, the integral did not converge as expected. </td></tr>
    <tr><td class="paramname">disp</td><td>Whether to raise an error in case the integral did not converge as expected. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to <code>scipy.integrate.quad()</code>. Use these to set e.g. <code>epsrel</code> to the desired tolerance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d946c32710bf1ff05efb654bee672fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d946c32710bf1ff05efb654bee672fc">&#9670;&nbsp;</a></span>expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hdiff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the expansion at one parameter value. </p>
<p>This function can also compute derivatives of the expansion w.r.t. the horizon function <code>h</code> or one of its derivatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameter (i.e. <img class="formulaInl" alt="$\lambda$" src="form_36.png"/> value) specifying the point on the curve at which to compute the expansion of the surface. </td></tr>
    <tr><td class="paramname">hdiff</td><td>If given, compute the functional derivative of the expansion w.r.t. a derivative of the horizon function. For example, if <code>hdiff==0</code>, compute <img class="formulaInl" alt="$\partial_h\Theta$" src="form_379.png"/> and for <code>hdiff==1</code>, compute <img class="formulaInl" alt="$\partial_{h'}\Theta$" src="form_380.png"/>. If <code>None</code> (default), compute the expansion. </td></tr>
    <tr><td class="paramname">ingoing</td><td>By default, the outgoing null geodesics' expansion is returned. If <code>ingoing==True</code>, the expansion of the ingoing null geodesics is computed instead. Functional derivatives of the ingoing expansion are not currently implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a242dab961b882fae1ab7023a7dbeb44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242dab961b882fae1ab7023a7dbeb44a">&#9670;&nbsp;</a></span>expansions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def expansions </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hdiff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8d946c32710bf1ff05efb654bee672fc" title="Compute the expansion at one parameter value. ">expansion()</a>, but on a whole set of parameter values. </p>

</div>
</div>
<a id="a49ef465ecbfd8d1a0f5413bda0a8f325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ef465ecbfd8d1a0f5413bda0a8f325">&#9670;&nbsp;</a></span>extrinsic_surface_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extrinsic_surface_curvature </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trace</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>square</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the extrinsic curvature tensor of the surface. </p>
<p>This computes the components </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ k_{AB} = -\nabla_A \nu_B, \qquad A,B = \lambda,\varphi \]" src="form_123.png"/>
</p>
<p> where <img class="formulaInl" alt="$\lambda,\varphi$" src="form_71.png"/> are coordinates on the surface represented by this curve, <img class="formulaInl" alt="$\nu$" src="form_12.png"/> is the outward pointing normal of the surface in the slice, and <img class="formulaInl" alt="$\nabla$" src="form_124.png"/> is the spacetime covariant derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameter (i.e. <img class="formulaInl" alt="$\lambda$" src="form_36.png"/> value) specifying the point on the curve at which to compute the extrinsic curvature of the surface. </td></tr>
    <tr><td class="paramname">trace</td><td>If <code>True</code>, returns the trace of the extrinsic curvature. Default is <code>False</code>. May not be used together with <code>square</code>. </td></tr>
    <tr><td class="paramname">square</td><td>If <code>True</code>, returns the square <img class="formulaInl" alt="$k_{AB} k^{AB}$" src="form_95.png"/>. Default is <code>False</code>. May not be used together with <code>trace</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NumPy 2x2 array containing the components of <code>k_AB</code>. If either <code>trace</code> or <code>square</code> is <code>True</code>, returns a float. </dd></dl>

</div>
</div>
<a id="a0922cb5b5e48ced63e8f638f75fedc4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0922cb5b5e48ced63e8f638f75fedc4a">&#9670;&nbsp;</a></span>find_neck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_neck </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algo</em> = <code>'coord'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to locate a 'neck' of this curve. </p>
<p>The neck can be defined by various means. One working definition is to take a locally minimal proper circumference of the surface defined by this curve by rotating a point around the z-axis. The two poles lying on the z-axis are excluded, of course.</p>
<p>This function implements the following algorithm to find the neck: Starting from the north-pole (<code>param=0</code>), we first find the point where the quantity (e.g. circumference) has a local <em>maximum</em>. From there, we do small steps forward to bracket the first local minimum, which is then located precisely.</p>
<dl class="section return"><dt>Returns</dt><dd>A tuple of <code>(param, value)</code>, where <code>param</code> is the curve parameter of the neck and <code>value</code> the value of the quantity used to define the neck.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo</td><td>The algorithm/definition of the neck. Understood values currently are <code>'coord'</code> (neck has minimal x-coordinate value), <code>'circumference'</code> (neck has minimal proper circumference), <code>'proper_x_dist'</code> (neck has minimal proper distance to z-axis, measured along a straight coordinate line in x-direction). Default is <code>'coord'</code>. </td></tr>
    <tr><td class="paramname">xtol</td><td>Tolerance in curve parameter value for the search. Default is <code>1e-8</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are used in case of <code>algo==proper_x_dist</code> and are supplied to the <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ab5d876f9c0547a82a18593efaf10f2c1" title="Return the proper length of a coordinate line from the curve to the z-axis. ">x_distance()</a> method calls. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea218e8051c9c6b433fc008c252d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea218e8051c9c6b433fc008c252d9b1">&#9670;&nbsp;</a></span>get_area_integrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_area_integrand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a callable evaluating the sqrt(det(q)), i.e. </p>
<p>the area element. </p>

</div>
</div>
<a id="a466e295d1bb8750fa1df2b746a0524a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466e295d1bb8750fa1df2b746a0524a4">&#9670;&nbsp;</a></span>get_calc_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_calc_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create or reuse a calculator object for a given parameter value. </p>
<p>In case the current cache/calculator already belongs to the given parameter value, it is reused and returned instead of a new one being created each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>(float) Parameter of the curve for which to construct the cache/calculator object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ca583853d9351f18fdd647ddc7b109d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca583853d9351f18fdd647ddc7b109d">&#9670;&nbsp;</a></span>get_det_q_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_det_q_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function to evaluate det(q). </p>

</div>
</div>
<a id="a12e142fbf691a6c614554fea33624c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e142fbf691a6c614554fea33624c1e">&#9670;&nbsp;</a></span>get_distance_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_distance_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Ns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xatol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mp_finish</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dps</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minima_to_check</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a callable computing the distance between this and another curve. </p>
<p>The computed distance is the coordinate distance between a point of this curve to the closest point on another curve.</p>
<p>The returned callable will take one mandatory argument: the parameter at which to evaluate the current curve. The resulting point is then taken and the given <code>other_curve</code> searched for the point closest to that point. The distance to this function is then returned.</p>
<p>A second optional parameter of the returned function determines whether only the distance (<code>False</code>, default) or the distance and the parameter on the other curve is returned (if <code>True</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>The curve to which the distance should be computed in the returned function. </td></tr>
    <tr><td class="paramname">Ns</td><td>Number of points to take on <code>other_curve</code> for finding the initial guess for the minimum search. Default is to take the resolution of <code>other_curve</code>. </td></tr>
    <tr><td class="paramname">xatol</td><td>In case <code>mp_finish==False</code>, use this tolerance in the SciPy <code>minimize_scalar()</code> call. Default is <code>1e-12</code>. </td></tr>
    <tr><td class="paramname">mp_finish</td><td>If <code>True</code> (default), evaluate some terms using arbitrary precision mpmath arithmetics and find the minimum with a robust but slow golden section search. This allows finding minima <em>much</em> closer to the actual minimum. In general, with <code>mp_finish==False</code>, we are usually limited by approximately <code>1e-8</code>, while with <code>mp_finish==True</code>, we can get to around <code>1e-15</code> (e.g. if <code>other_curve</code> is this curve). </td></tr>
    <tr><td class="paramname">dps</td><td>Decimal places for mpmath computations. Default is <code>50</code>. </td></tr>
    <tr><td class="paramname">minima_to_check</td><td>Number of local minima to check for a global minimum. Default is <code>1</code>, which means we search just around the smallest distance from the initial grid of points. Higher values may help locate the correct minimum especially in cases of self-intersecting curves. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abadd30d50ea29610265ab20b4b27b5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadd30d50ea29610265ab20b4b27b5a5">&#9670;&nbsp;</a></span>h_diff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def h_diff </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute derivative of this curve w.r.t. horizon function <code>h</code>. </p>

</div>
</div>
<a id="af121af077346547f69460bdda05c371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af121af077346547f69460bdda05c371d">&#9670;&nbsp;</a></span>horizon_function_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def horizon_function_changed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify this curve that the underlying horizon function has changed. </p>
<p>Since we cache the calculation object for efficiency, changes to the horizon function will not affect results if evaluating the expansion at the exact same point. This method invalidates any cached evaluators and calculation objects to produce newly computed results in the next computation call. </p>

</div>
</div>
<a id="a321e36a1dbf23d671dda1f83832d8d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321e36a1dbf23d671dda1f83832d8d07">&#9670;&nbsp;</a></span>horizon_radius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def horizon_radius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the horizon radius. </p>
<p>The horizon radius is defined as (cf. [1]) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ R := \sqrt{A/4\pi}, \]" src="form_141.png"/>
</p>
<p> where <code>A</code> is the horizon's area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Optional area for which to compute the horizon radius. By default, the area of the axisymmetric surface represented by this curve is computed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Ashtekar, Abhay, and Badri Krishnan. "Isolated and dynamical
     horizons and their applications." Living Reviews in Relativity 7.1 (2004): 10. </p>

</div>
</div>
<a id="a38381b28dbb789e67f67a08a290f9894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38381b28dbb789e67f67a08a290f9894">&#9670;&nbsp;</a></span>inner_x_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inner_x_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>'zero'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the x-distance of two points of this and another curve. </p>
<p>Similar to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#abc03b763d08379e9a2f50e40952166c6" title="Compute the z-distance of two points of this and another curve. ">inner_z_distance()</a>, this method does <em>not</em> compute how close two surfaces approach each other (which would return zero for intersecting surfaces). Instead, it computes one possible measure for how close the two surfaces are from being identical, i.e. it computes the distance of two corresponding points.</p>
<p>In this function, we measure the distance on a straight coordinate line in x-direction connecting either two points on the x-axis itself (i.e. for <code>x==0</code>) or on a line in x-direction starting at the point of largest coordinate distance to the z-axis (i.e. for largest x value).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to which to compute the distance. </td></tr>
    <tr><td class="paramname">where</td><td>One of <code>'zero', 'max'</code>. Default is <code>'zero'</code>. Where to take the points on both surfaces. Here, <code>'max'</code> means to take the point of largest distance to the z-axis of this curve. Hence, the result will not be symmetric w.r.t. switching the two curves. </td></tr>
    <tr><td class="paramname">metric</td><td>Which metric to use for integrating along the connecting line of the two points. By default, takes the current metric stored in this curve. Explicitely specify <code>None</code> to get the coordinate distance. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7" title="Compute the length of this curve w.r.t. a given metric. ">arc_length_using_metric()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc03b763d08379e9a2f50e40952166c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc03b763d08379e9a2f50e40952166c6">&#9670;&nbsp;</a></span>inner_z_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inner_z_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>'top'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the z-distance of two points of this and another curve. </p>
<p>In contrast to z_distance(), this method does <em>not</em> compute how close two surfaces approach each other. Instead, it computes one possible measure for how close the two surfaces are from being identical, i.e. it computes the distance of two corresponding points.</p>
<p>In this function, we take either the top or bottom points of both surfaces on the z-axis and compute their distance. The distance will have negative sign if this curve is in the <em>interior</em> of the <code>other_curve</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to which to compute the distance. </td></tr>
    <tr><td class="paramname">where</td><td>One of <code>'top', 'bottom'</code>. Default is <code>'top'</code>. Where to take the points on both surfaces. </td></tr>
    <tr><td class="paramname">metric</td><td>Which metric to use for integrating along the connecting line of the two points. By default, takes the current metric stored in this curve. Explicitely specify <code>None</code> to get the coordinate distance. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the computed result and an estimation of the error. Otherwise (default), just return the result. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7" title="Compute the length of this curve w.r.t. a given metric. ">arc_length_using_metric()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea5c33ef11a8f6531a62f65777be3a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5c33ef11a8f6531a62f65777be3a34">&#9670;&nbsp;</a></span>irreducible_mass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def irreducible_mass </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the irreducible mass. </p>
<p>The irreducible mass of a horizon is (see e.g. [1]) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ M := \sqrt{A/16\pi}, \]" src="form_140.png"/>
</p>
<p> where <code>A</code> is the horizon's area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Optional area for which to compute the mass. By default, the area of the axisymmetric surface represented by this curve is computed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Chu, Tony, Harald P. Pfeiffer, and Michael I. Cohen. "Horizon
     dynamics of distorted rotating black holes." Physical Review D 83.10 (2011): 104018. </p>

</div>
</div>
<a id="a287674a9252dd9228d16780a17670129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287674a9252dd9228d16780a17670129">&#9670;&nbsp;</a></span>linearized_equation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def linearized_equation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target_expansion</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pool</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return linearized equation as operator and inhomogeneity on a grid. </p>
<p>This form is suitable to be processed by the pseudospectral solver <a class="el" href="namespacemotsfinder_1_1ndsolve_1_1solver.html#aa9b143582d20b970c4f3001cad8fa3b5" title="Numerically solve a linear differential equation. ">ndsolve.solver.ndsolve()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Points at which to evaluate the equation terms. Should be the collocation points for a pseudospectral solver. </td></tr>
    <tr><td class="paramname">target_expansion</td><td>Optional float indicating the desired expansion of the surface to find. Default is <code>0.0</code> (i.e. a MOTS). </td></tr>
    <tr><td class="paramname">parallel</td><td>Whether to evaluate the equation using multiple processes in parallel. If <code>True</code>, uses all available threads. If an integer, uses that many threads. Default is <code>False</code>, i.e. don't compute in parallel. </td></tr>
    <tr><td class="paramname">pool</td><td>Optional processing pool to re-use. If not given, a new pool is created and then destroyed after the computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2f87fe8930191d84b8a0f9c878f3078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f87fe8930191d84b8a0f9c878f3078">&#9670;&nbsp;</a></span>linearized_equation_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def linearized_equation_at </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target_expansion</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the terms of the linearized version of H=0 at one point. </p>

</div>
</div>
<a id="afdb06f51cca9db99704ae9fe5eac6a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb06f51cca9db99704ae9fe5eac6a26">&#9670;&nbsp;</a></span>locate_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def locate_intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain1</em> = <code>(0,&#160;np.pi)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain2</em> = <code>(0,&#160;np.pi)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict1</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict2</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N1</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N2</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate one point at which this curve intersects another curve. </p>
<dl class="section return"><dt>Returns</dt><dd>Tuple <code>(param1, param2)</code>, where <code>param1</code> is the parameter value of this curve and <code>param2</code> the parameter value of the <code>other_curve</code> at which the two curves have the same location. If no intersection is found, returns <code>(None, None)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to find the intersection with. </td></tr>
    <tr><td class="paramname">xtol</td><td>Tolerance in curve parameter values for the search. Default is <code>1e-8</code>. </td></tr>
    <tr><td class="paramname">domain1,domain2</td><td>Optional interval of the curves to consider. Default is the full curve, i.e. <code>(0, pi)</code> for both. </td></tr>
    <tr><td class="paramname">strict1,strict2</td><td>Whether to only allow solutions in the given domains <code>domain1</code>, <code>domain2</code>, respectively (default). If either is <code>False</code>, the respective domain is used just for the initial coarse check to find a starting point. Setting e.g. <code>N1=1</code> and <code>strict1=False</code> allows specifying a starting point on this (first) curve. </td></tr>
    <tr><td class="paramname">N1,N2</td><td>Number of equally spaced rough samples to check for a good starting point. To avoid running into some local minimal distance (e.g. at the curve ends), this number should be high enough. Alternatively (or additionally), one may specify a smaller domain if there is prior knowledge about the curve shapes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca1e6cd728f86908a070a06765d59ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca1e6cd728f86908a070a06765d59ae">&#9670;&nbsp;</a></span>locate_self_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def locate_self_intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>neck</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a <em>loop</em> in the MOTS around its neck. </p>
<dl class="section return"><dt>Returns</dt><dd>Two parameter values <code>(param1, param2)</code> where the curve has the same location in the x-z-plane. If not loop is found, returns <code>(None, None)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neck</td><td>Parameter where the neck is located. If not given, finds the neck using default arguments of <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0922cb5b5e48ced63e8f638f75fedc4a" title="Try to locate a &#39;neck&#39; of this curve. ">find_neck()</a>. </td></tr>
    <tr><td class="paramname">xtol</td><td>Tolerance in curve parameter values for the search. Default is <code>1e-8</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1593d55a85a61e1578c554b68370f9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1593d55a85a61e1578c554b68370f9d7">&#9670;&nbsp;</a></span>multipoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def multipoles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_n</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the multipoles I_n of the horizon. </p>
<p>This is based on the considerations in [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_n</td><td>Integer specifying the maximum number <code>n</code> (inclusive) up to which the moments <img class="formulaInl" alt="$I_n$" src="form_319.png"/> should be computed. </td></tr>
    <tr><td class="paramname">num</td><td>Resolution for the pseudospectral solution of the invariant coordinate <img class="formulaInl" alt="$\zeta$" src="form_149.png"/>. Default is to use the current curve's resolution, but at least 100. </td></tr>
    <tr><td class="paramname">get_zeta</td><td>Optional argument. If specified and <code>True</code>, don't return the multipole moments but the solution <img class="formulaInl" alt="$\zeta$" src="form_149.png"/>. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to return an <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results. ">numutils.IntegrationResults</a> object containing all values with their errors and any warnings. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">disp</td><td>Raise an error in case of an integration warning. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments are supplied to the <code>scipy.integrate.quad</code> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of computed moments <img class="formulaInl" alt="$I_n$" src="form_319.png"/> for <code>n=0,1,..,max_n</code>.</dd></dl>
<p><b>References</b> </p>
<p>[1] Ashtekar, Abhay, et al. "Multipole moments of isolated horizons." Classical and Quantum Gravity 21.11 (2004): 2549. </p>

</div>
</div>
<a id="a8e123567df79f0eb5b554d595e328177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e123567df79f0eb5b554d595e328177">&#9670;&nbsp;</a></span>num()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def num </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolution (number of DOFs) of the horizon function. </p>

</div>
</div>
<a id="a4d19c53e7e580b11b2a3d934a60f4b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d19c53e7e580b11b2a3d934a60f4b13">&#9670;&nbsp;</a></span>plot_coeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def plot_coeffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>r&quot;\gamma&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>figsize</em> = <code>(5,&#160;3)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to plot the horizon function's spectral coefficients. </p>
<p>This may help in quickly judging convergence based on exponential decay. </p>

</div>
</div>
<a id="a5affff3f10d450ec714b967e25971644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5affff3f10d450ec714b967e25971644">&#9670;&nbsp;</a></span>plot_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def plot_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>r&quot;\gamma&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>figsize</em> = <code>(5,&#160;3)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to plot the expansion along the curve. </p>
<p>This may help in quickly judging convergence. The parameter <code>c</code> is subtracted from the values, which is useful to analyse constant expansion surfaces. </p>

</div>
</div>
<a id="a0e237fcc955d9e464d5c32fc84a840f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e237fcc955d9e464d5c32fc84a840f9">&#9670;&nbsp;</a></span>resample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the number of DOFs of the horizon function. </p>
<p>Other algorithms may use this number to implement modification of the horizon function for a search for e.g. MOTSs.</p>
<p>This function returns the curve object itself to allow for chaining. </p>

</div>
</div>
<a id="a05b59585b2daf3036737fe2e3a3a9f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b59585b2daf3036737fe2e3a3a9f80">&#9670;&nbsp;</a></span>ricci_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Ricci scalar of the surface at the given parameter. </p>
<p>See <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcalc_1_1ExpansionCalc.html#ae5dcd5322e3a34af3c21ae93ace09e22" title="Compute the Ricci scalar of the surface represented by the curve. ">expcalc.ExpansionCalc.ricci_scalar()</a> for details. </p>

</div>
</div>
<a id="a261ec805e4184cc43bfc37a4f801c204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261ec805e4184cc43bfc37a4f801c204">&#9670;&nbsp;</a></span>stability_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def stability_parameter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_max</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_terminate_index</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_eigenfunctions</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_normal</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform_torsion</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the stability parameter. </p>
<p>The stability parameter is defined in [1] as the principal eigenvalue of the stability operator. We use the normal vector in the slice and use the axisymmetry to simplify the analytical task.</p>
<p>According to Proposition 5.1 in [1], the MOTS represented by this curve is stably outermost iff the stability parameter is greater or equal to zero and strictly stably outermost iff it is greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Pseudospectral resolution of the discretization of the operator. By default, uses the resolution of the curve representation itself. </td></tr>
    <tr><td class="paramname">m_max</td><td>Maximum angular mode to consider. Default is to use <code>num-1</code>. </td></tr>
    <tr><td class="paramname">m_terminate_index</td><td>Index of the eigenvalue of the <code>m=0</code> mode to use to as stopping criterion for the angular mode. If the real part of the thus specified <code>m=0</code> eigenvalue is less or equal to the (real part of the) smallest eigenvalue of the current <code>m</code>, then no higher <code>m</code> modes are considered. This effectively gives the number of <code>m=0</code> eigenvalues of which we want to determine the multiplicity. Default is <code>30</code>. Set explicitly to <code>None</code> to not stop based on this criterion. </td></tr>
    <tr><td class="paramname">rtol</td><td>Tolerance for reality check. The principal eigenvalue is shown in [1] to be real. If it has a non-zero imaginary part greater than <code>rtol * |real_part|</code>, then a <code>RuntimeError</code> is raised. Default is <code>1e-12</code>. </td></tr>
    <tr><td class="paramname">compute_eigenfunctions</td><td>Whether to compute the eigenfunction for each eigenvalue. Default is <code>False</code>. The eigenfunctions will be accessible from the StabilitySpectrum object via the <code>spectrum.get_eigenfunction()</code> method. Note that the method for computing the eigenvalues is a different one in this case and hence the numerical values (and even the accuracy) may differ from the case <code>compute_eigenfunctions=False</code>. </td></tr>
    <tr><td class="paramname">slice_normal</td><td>Whether to consider the stability operator w.r.t. the outward normal in the spatial slice (default). If <code>False</code>, consider the operator w.r.t. the past-pointing outward null normal <img class="formulaInl" alt="$-k^\mu$" src="form_447.png"/>. </td></tr>
    <tr><td class="paramname">transform_torsion</td><td>Apply a transformation to the lightlike null vectors <code>k</code> and <code>l</code> such that the rotation 1-form <img class="formulaInl" alt="$s_A$" src="form_448.png"/> (torsion of <code>l</code>) becomes divergence free. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return all eigenvalues in addition to the principal eigenvalue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The principal eigenvalue as a float (i.e. the real part, ignoring any spurious imaginary part). If <code>full_output==True</code>, returns a StabilitySpectrum object as second element containing all found eigenvalues.</dd></dl>
<p><b>Notes</b> </p>
<p>If the MOTS <img class="formulaInl" alt="$\mathcal{S}$" src="form_407.png"/> is contained in a time-symmetric slice <img class="formulaInl" alt="$\Sigma$" src="form_101.png"/> of spacetime, and we compute the stability w.r.t. the outward pointing normal <img class="formulaInl" alt="$\nu$" src="form_12.png"/> of <img class="formulaInl" alt="$\mathcal{S}$" src="form_407.png"/> in <img class="formulaInl" alt="$\Sigma$" src="form_101.png"/>, then the stability operator simplifies greatly to </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ L_\nu \zeta = -\Delta_\mathcal{S} \zeta - (R_{ij}\nu^i\nu^j + \mathcal{K}_{AB}\mathcal{K}^{AB}) \zeta, \]" src="form_434.png"/>
</p>
<p> where <img class="formulaInl" alt="$R_{ij}$" src="form_143.png"/> is the Ricci tensor of <img class="formulaInl" alt="$(\Sigma, g)$" src="form_144.png"/>, <img class="formulaInl" alt="$\mathcal{K}_{AB}$" src="form_435.png"/> is the extrinsic curvature of <img class="formulaInl" alt="$\mathcal{S}$" src="form_407.png"/>, <img class="formulaInl" alt="$\Delta_\mathcal{S} = q^{AB}\,D_A\,D_B$" src="form_436.png"/> is the Laplacian on <img class="formulaInl" alt="$(\mathcal{S}, q)$" src="form_437.png"/>, <code>g</code> is the 3-metric on the slice and <code>q</code> the induced 2-metric on the MOTS.</p>
<p>Without time symmetry, the full operator (in vacuum) reads </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ L_\nu \zeta = -\Delta_\mathcal{S} \zeta + 2 s^A D_A \zeta + \big( \frac{1}{2} \mathcal{R} - s_A s^A + D_A s^A - \frac{1}{2} q^{AC} q^{BD} K^\mu_{AB} K^\nu_{CD} \ell_\mu \ell_\nu \big). \]" src="form_438.png"/>
</p>
<p> Here, <img class="formulaInl" alt="$\mathcal{R}$" src="form_408.png"/> is the Ricci scalar of <img class="formulaInl" alt="$\mathcal{S}$" src="form_407.png"/>, <img class="formulaInl" alt="$s_A = -\frac{1}{2} k_\mu \nabla_A \ell^\mu$" src="form_439.png"/> and <img class="formulaInl" alt="$K^\mu_{AB}\ell_\mu = -\nabla_A \ell_B$" src="form_440.png"/>. Note that <img class="formulaInl" alt="$\nabla$" src="form_124.png"/> refers to the covariant derivative compatible with the spacetime 4-metric and <img class="formulaInl" alt="$k^\mu$" src="form_441.png"/> and <img class="formulaInl" alt="$\ell^\mu$" src="form_442.png"/> are the future pointing ingoing and outgoing null normals to <img class="formulaInl" alt="$\mathcal{S}$" src="form_407.png"/>, respectively.</p>
<p>To find the principal eigenvalue of <img class="formulaInl" alt="$L_\nu$" src="form_148.png"/>, first note that due to the axisymmetry, the <img class="formulaInl" alt="$\varphi$" src="form_107.png"/>-dependence of <img class="formulaInl" alt="$\zeta$" src="form_149.png"/> can be expressed as </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ \zeta(\lambda, \varphi) = \sum_{m=-\infty}^\infty \zeta_m(\lambda) e^{im\varphi}. \]" src="form_421.png"/>
</p>
<p> Since the <img class="formulaInl" alt="$e^{im\varphi}$" src="form_422.png"/> are linearly independent, the spectrum will consist of the union of spectra of the <img class="formulaInl" alt="$\zeta_m$" src="form_423.png"/>. When taking the union, we label the eigenvalues by their <code>m</code>-mode to be able to count their multiplicity.</p>
<p>The effect of applying <img class="formulaInl" alt="$L$" src="form_443.png"/> to <img class="formulaInl" alt="$\zeta_m e^{im\varphi}$" src="form_444.png"/> can in axisymmetry be reduced to a 1D problem of acting on just <img class="formulaInl" alt="$\zeta_m$" src="form_423.png"/> via (no summation here, <img class="formulaInl" alt="$m$" src="form_446.png"/> is the angular mode, not an index) </p><p class="formulaDsp">
<img class="formulaDsp" alt="\[ L^m \zeta_m = (L + 2 i m s^\varphi + m^2 q^{\varphi\varphi}) \zeta_m. \]" src="form_445.png"/>
</p>
<p>The eigenvalues themselves are found using <a class="el" href="classmotsfinder_1_1ndsolve_1_1solver_1_1NDSolver.html#a280cc9d8aeddcb741338cfc65fe9cf52" title="Compute the eigenvalues of the operator. ">motsfinder.ndsolve.solver.NDSolver.eigenvalues()</a>, which means we just need to provide the coefficient functions defining the one-dimensional operator <img class="formulaInl" alt="$L^m$" src="form_425.png"/> acting on <img class="formulaInl" alt="$\zeta_m$" src="form_423.png"/>. The Laplacian acting on <img class="formulaInl" alt="$\zeta_m$" src="form_423.png"/> reads </p><p class="formulaDsp">
<img class="formulaDsp" alt="\begin{eqnarray*} \Delta_\sigma \zeta_m &amp;=&amp; \frac{1}{\sqrt{q}} \partial_A (\sqrt{q} q^{AB} \partial_B \zeta_m) = \left( \frac{1}{2} q^{AB} q^{C\lambda} \partial_C q_{AB} + \partial_A q^{A\lambda} \right) \zeta_m' + q^{\lambda\lambda} \zeta_m'' \\ &amp;=&amp; \left( \frac{1}{2} q^{AB} q^{C\lambda} - q^{AC} q^{B\lambda} \right) (\partial_C q_{AB}) \zeta_m' + q^{\lambda\lambda} \zeta_m''. \end{eqnarray*}" src="form_426.png"/>
</p>
<p><b>References</b> </p>
<p>[1] Andersson, Lars, Marc Mars, and Walter Simon. "Stability of marginally outer trapped surfaces and existence of marginally outer trapped tubes." arXiv preprint arXiv:0704.2889 (2007). </p>

</div>
</div>
<a id="a63fc2ab7c97360b53459877417ba7213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc2ab7c97360b53459877417ba7213">&#9670;&nbsp;</a></span>suspend_calc_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def suspend_calc_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context manager to temporarily ignore the current calculator. </p>
<p>When leaving the with-scope, the current calculator is restored. This may be useful during evaluation of expansions for perturbed curves in finite difference approximations of functional derivatives of the expansion. </p>

</div>
</div>
<a id="a4424c4e81f70acc59bf8915971821c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4424c4e81f70acc59bf8915971821c62">&#9670;&nbsp;</a></span>suspend_curv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def suspend_curv </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context manager to temporarily ignore the extrinsic curvature. </p>

</div>
</div>
<a id="a474b5d328f851a167e5a83cb99f7ed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474b5d328f851a167e5a83cb99f7ed25">&#9670;&nbsp;</a></span>temp_metric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def temp_metric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context manager to temporarily replace the used metric. </p>
<p>When leaving the with-scope, the previous metric is restored. </p>

</div>
</div>
<a id="ab5d876f9c0547a82a18593efaf10f2c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d876f9c0547a82a18593efaf10f2c1">&#9670;&nbsp;</a></span>x_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def x_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the proper length of a coordinate line from the curve to the z-axis. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>motsfinder/axisym/curve/expcurve.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym.html">axisym</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1curve.html">curve</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1curve_1_1expcurve.html">expcurve</a></li><li class="navelem"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html">ExpansionCurve</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
