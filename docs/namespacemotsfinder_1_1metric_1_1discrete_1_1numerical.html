<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: motsfinder.metric.discrete.numerical Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   &#160;<span id="projectnumber">v1.5</span>
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">motsfinder.metric.discrete.numerical Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Numerical low-level computations and helpers.  
<a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1metric_1_1discrete_1_1numerical_1_1GridDataError.html">GridDataError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raised if discrete data is not compatible with this module.  <a href="classmotsfinder_1_1metric_1_1discrete_1_1numerical_1_1GridDataError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a55eee709f1472816b75aad8347c29ab0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a55eee709f1472816b75aad8347c29ab0">interpolate</a> (mat, coords, linear=False, cache=None, base_idx=None)</td></tr>
<tr class="memdesc:a55eee709f1472816b75aad8347c29ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a (small) matrix patch, interpolate a value between grid points.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a55eee709f1472816b75aad8347c29ab0">More...</a><br /></td></tr>
<tr class="separator:a55eee709f1472816b75aad8347c29ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e6ad5ed537d9d74270cb7a736bd8e7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ac2e6ad5ed537d9d74270cb7a736bd8e7">_apply_along_first_axis</a> (func, mat, *args, **kwargs)</td></tr>
<tr class="memdesc:ac2e6ad5ed537d9d74270cb7a736bd8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to np.apply_along_axis(), but call func with the fixed indices.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ac2e6ad5ed537d9d74270cb7a736bd8e7">More...</a><br /></td></tr>
<tr class="separator:ac2e6ad5ed537d9d74270cb7a736bd8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62bbd7ba8a3238d76f4648c69f228556"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a62bbd7ba8a3238d76f4648c69f228556">_interp1d</a> (arr, ii, coord, linear, cache=None, base_idx=None)</td></tr>
<tr class="memdesc:a62bbd7ba8a3238d76f4648c69f228556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform 1-D interpolation of a sequence of values.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a62bbd7ba8a3238d76f4648c69f228556">More...</a><br /></td></tr>
<tr class="separator:a62bbd7ba8a3238d76f4648c69f228556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6205d9000b82f03de99dbe1a13e6996f"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a6205d9000b82f03de99dbe1a13e6996f">fd_xz_derivatives</a> (mat, region, dx, dz, derivs, stencil_size=5)</td></tr>
<tr class="memdesc:a6205d9000b82f03de99dbe1a13e6996f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform finite difference differentiation on specified grid points.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a6205d9000b82f03de99dbe1a13e6996f">More...</a><br /></td></tr>
<tr class="separator:a6205d9000b82f03de99dbe1a13e6996f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394a2d9740d46bd55757eeb65ee5f683"><td class="memItemLeft" align="right" valign="top"><a id="a394a2d9740d46bd55757eeb65ee5f683"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a394a2d9740d46bd55757eeb65ee5f683">_fd_xz_derivatives</a> (mat, region, dx, dz, derivs, stencil_size)</td></tr>
<tr class="memdesc:a394a2d9740d46bd55757eeb65ee5f683"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement <a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a6205d9000b82f03de99dbe1a13e6996f" title="Perform finite difference differentiation on specified grid points.">fd_xz_derivatives()</a>. <br /></td></tr>
<tr class="separator:a394a2d9740d46bd55757eeb65ee5f683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5d84d75b3e1fb8c2e93578ae4d2df5d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ae5d84d75b3e1fb8c2e93578ae4d2df5d">eval_sym_axisym_matrix</a> (comp_funcs, *lower_orders, point, diff=0)</td></tr>
<tr class="memdesc:ae5d84d75b3e1fb8c2e93578ae4d2df5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate (derivatives of) a symmetric tensor field at a point.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ae5d84d75b3e1fb8c2e93578ae4d2df5d">More...</a><br /></td></tr>
<tr class="separator:ae5d84d75b3e1fb8c2e93578ae4d2df5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f48fb04413191e169df197c3d86d5e4"><td class="memItemLeft" align="right" valign="top"><a id="a3f48fb04413191e169df197c3d86d5e4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a3f48fb04413191e169df197c3d86d5e4">_get_fy</a> ()</td></tr>
<tr class="memdesc:a3f48fb04413191e169df197c3d86d5e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the y-derivative of scalar f in x-z-plane assuming axisymmetry. <br /></td></tr>
<tr class="separator:a3f48fb04413191e169df197c3d86d5e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a924780bf3fdfd1cbece132dcb36a45"><td class="memItemLeft" align="right" valign="top"><a id="a5a924780bf3fdfd1cbece132dcb36a45"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a5a924780bf3fdfd1cbece132dcb36a45">_get_fxy_fyy_fyz</a> (point, df)</td></tr>
<tr class="memdesc:a5a924780bf3fdfd1cbece132dcb36a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2nd (y-)derivatives of scalar f in x-z-plane assuming axisymmetry. <br /></td></tr>
<tr class="separator:a5a924780bf3fdfd1cbece132dcb36a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638d1f6fb953ef87ddf403ec9e3101c6"><td class="memItemLeft" align="right" valign="top"><a id="a638d1f6fb953ef87ddf403ec9e3101c6"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a638d1f6fb953ef87ddf403ec9e3101c6">_get_Vy</a> (point, V)</td></tr>
<tr class="memdesc:a638d1f6fb953ef87ddf403ec9e3101c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the y-derivative of vector V in x-z-plane assuming axisymmetry. <br /></td></tr>
<tr class="separator:a638d1f6fb953ef87ddf403ec9e3101c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706dd9d0932db9119db313797b00bda9"><td class="memItemLeft" align="right" valign="top"><a id="a706dd9d0932db9119db313797b00bda9"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a706dd9d0932db9119db313797b00bda9">_get_Vxy_Vyy_Vyz</a> (point, V, dV)</td></tr>
<tr class="memdesc:a706dd9d0932db9119db313797b00bda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2nd (y-)derivatives of vector V in x-z-plane assuming axisymmetry. <br /></td></tr>
<tr class="separator:a706dd9d0932db9119db313797b00bda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6214fa1241eef020c7f99de3e604ed26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a6214fa1241eef020c7f99de3e604ed26">_get_Ty</a> (point, T, dTdx=None)</td></tr>
<tr class="memdesc:a6214fa1241eef020c7f99de3e604ed26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the y-derivative of matrix T in x-z-plane assuming axisymmetry.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a6214fa1241eef020c7f99de3e604ed26">More...</a><br /></td></tr>
<tr class="separator:a6214fa1241eef020c7f99de3e604ed26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30017c2b34bfd2cb5b0271ad041d7de"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ae30017c2b34bfd2cb5b0271ad041d7de">_get_Txy_Tyy_Tyz</a> (point, T, dT)</td></tr>
<tr class="memdesc:ae30017c2b34bfd2cb5b0271ad041d7de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the 2nd (y-)derivatives of matrix T in x-z-plane assuming axisymmetry.  <a href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ae30017c2b34bfd2cb5b0271ad041d7de">More...</a><br /></td></tr>
<tr class="separator:ae30017c2b34bfd2cb5b0271ad041d7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab45ab5119a4566a129d7140b7a46809d"><td class="memItemLeft" align="right" valign="top"><a id="ab45ab5119a4566a129d7140b7a46809d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ab45ab5119a4566a129d7140b7a46809d">_sym3x3</a> (T)</td></tr>
<tr class="memdesc:ab45ab5119a4566a129d7140b7a46809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symmetrize a 3x3 matrix by replacing the lower-left three components. <br /></td></tr>
<tr class="separator:ab45ab5119a4566a129d7140b7a46809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4f38523f59e06b4fca3b55e93810ee86"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><b>COEFFS_1ST</b></td></tr>
<tr class="separator:a4f38523f59e06b4fca3b55e93810ee86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bea5cb45acc2446d995cc580ce5e999"><td class="memItemLeft" align="right" valign="top">list&#160;</td><td class="memItemRight" valign="bottom"><b>COEFFS_2ND</b></td></tr>
<tr class="separator:a2bea5cb45acc2446d995cc580ce5e999"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Numerical low-level computations and helpers. </p>
<p>These are used by e.g. the .<a class="el" href="classmotsfinder_1_1metric_1_1discrete_1_1patch_1_1DataPatch.html" title="Represents a patch of field (component) data in axisymmetry.">patch.DataPatch</a> classes to perform their interpolation and differentiation on grids of data. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac2e6ad5ed537d9d74270cb7a736bd8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e6ad5ed537d9d74270cb7a736bd8e7">&#9670;&nbsp;</a></span>_apply_along_first_axis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical._apply_along_first_axis </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kwargs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to np.apply_along_axis(), but call func with the fixed indices. </p>
<p>In contrast to <code>np.apply_along_axis()</code>, <code>func</code> is called with the tuple <code>ii</code> of indices that are fixed in <code>mat</code> as second positional argument. This provides context for where the function is being evaluated in the matrix which may be used to implement e.g. caching mechanisms. </p>

</div>
</div>
<a id="ae30017c2b34bfd2cb5b0271ad041d7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30017c2b34bfd2cb5b0271ad041d7de">&#9670;&nbsp;</a></span>_get_Txy_Tyy_Tyz()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical._get_Txy_Tyy_Tyz </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the 2nd (y-)derivatives of matrix T in x-z-plane assuming axisymmetry. </p>
<p>Here, <code>T = (T_ij)</code> is a matrix-valued function (covariant tensor field). The derivatives are those involving the y-direction, i.e. <code>x,y</code>, <code>y,y</code>, <code>y,z</code>, in that order.</p>
<p>See docstring of <a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ae5d84d75b3e1fb8c2e93578ae4d2df5d" title="Evaluate (derivatives of) a symmetric tensor field at a point.">eval_sym_axisym_matrix()</a> for the implemented formulas. </p>

</div>
</div>
<a id="a6214fa1241eef020c7f99de3e604ed26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6214fa1241eef020c7f99de3e604ed26">&#9670;&nbsp;</a></span>_get_Ty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical._get_Ty </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dTdx</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the y-derivative of matrix T in x-z-plane assuming axisymmetry. </p>
<p>Here, <code>T = (T_ij)</code> is a matrix-valued function (covariant tensor field).</p>
<p>See docstring of <a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#ae5d84d75b3e1fb8c2e93578ae4d2df5d" title="Evaluate (derivatives of) a symmetric tensor field at a point.">eval_sym_axisym_matrix()</a> for the implemented formulas. </p>

</div>
</div>
<a id="a62bbd7ba8a3238d76f4648c69f228556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62bbd7ba8a3238d76f4648c69f228556">&#9670;&nbsp;</a></span>_interp1d()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical._interp1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cache</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_idx</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform 1-D interpolation of a sequence of values. </p>
<p>This takes a 1-D sequence of values, <code>arr</code>, and interpolates a value in relative index space at <code>coord</code> as described in <a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html#a55eee709f1472816b75aad8347c29ab0" title="Given a (small) matrix patch, interpolate a value between grid points.">interpolate()</a>. The order of the interpolating polynomial is determined by the length of the sequence. The result is a floating point value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">arr</td><td>1-D array-like with values. </td></tr>
    <tr><td class="paramname">ii</td><td>In case a <code>cache</code> is used, the parameter <code>ii</code> should consist of indices that are <em>not</em> varied along the axis currently interpolated along. These are added to the last indices of <code>base_idx</code> to generate a unique key for the data of this axis, which will still be the same each time this strip of data is encountered (i.e. even if it is at a different position in the matrix patch currently considered). </td></tr>
    <tr><td class="paramname">coord</td><td>Float indicating the coordinate in relative index space at which to interpolate. </td></tr>
    <tr><td class="paramname">linear</td><td>If <code>True</code>, perform simple linear interpolation instead of Lagrange interpolation. </td></tr>
    <tr><td class="paramname">cache</td><td>Dictionary to use as cache. If given, <code>base_idx</code> must also be supplied. </td></tr>
    <tr><td class="paramname">base_idx</td><td>Tuple of as many indices as <code>mat</code> has axes. This allows the optional cache to be applicable to the full data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae5d84d75b3e1fb8c2e93578ae4d2df5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5d84d75b3e1fb8c2e93578ae4d2df5d">&#9670;&nbsp;</a></span>eval_sym_axisym_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical.eval_sym_axisym_matrix </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>comp_funcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>lower_orders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate (derivatives of) a symmetric tensor field at a point. </p>
<p>This takes the six independent component functions of the <code>xx</code>, <code>xy</code>, <code>xz</code>, <code>yy</code>, <code>yz</code>, and <code>zz</code> components (in that order) of a tensor field <code>T</code>. These should be DataPatch objects. It then computes the derivatives of the requested order <code>diff</code> in all three coordinate directions using the axisymmetry of the tensor to infer the y-derivatives from the x-derivative.</p>
<p>In order to compute derivatives, all lower order derivatives are required (including order 0). These have to be supplied as positional arguments after the list of component functions.</p>
<dl class="section return"><dt>Returns</dt><dd>For <code>diff=0</code>, returns the 3x3 matrix representing <code>T</code> interpolated at <code>point</code>, i.e. \(T_{ij}\). If <code>diff=1</code>, returns <code>dT[i,j,k]</code>, where the indices mean \(\partial_i T_{jk}\) and if <code>diff=2</code>, returns <code>ddT[i,j,k,l]</code> with indices \(\partial_i\partial_j T_{kl}\).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp_funcs</td><td>An iterable of the six independent component functions (DataPatch) of the tensor field. </td></tr>
    <tr><td class="paramname">*lower_orders</td><td>Further positional arguments supplying the lower order derivatives. For <code>diff=0</code>, none should be supplied. For <code>diff=1</code>, one argument, <code>T</code> itself, should be given. For <code>diff=2</code>, <code>T</code> and <code>dT</code> should be given in that order. </td></tr>
    <tr><td class="paramname">point</td><td>The point at which to compute. </td></tr>
    <tr><td class="paramname">diff</td><td>Derivative order to compute. Default is <code>0</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>Based on the considerations in [1], the y-derivatives of tensor field components in the xz-plane can be computed by differentiating eq. (7) in [1] w.r.t. <code>y</code> and evaluating at <code>y=0</code>. The results are </p><p class="formulaDsp">
\begin{eqnarray*} (\partial_y T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} -2T_{xy} &amp; T_{xx}-T_{yy} &amp; -T_{yz} \\ T_{xx}-T_{yy} &amp; 2T_{xy} &amp; T_{xz} \\ -T_{yz} &amp; T_{xz} &amp; 0 \end{array}\right) \\ (\partial_x\partial_y T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} -2T_{xy,x} + \frac{2 T_{xy}}{x} &amp; T_{xx,x} - \frac{T_{xx}}{x} - T_{yy,x} + \frac{T_{yy}}{x} &amp; - T_{yz,x} + \frac{T_{yz}}{x} \\ T_{xx,x}-T_{yy,x}-\frac{T_{xx}}{x} + \frac{T_{yy}}{x} &amp; 2 T_{xy,x} - \frac{2 T_{xy}}{x} &amp; T_{xz,x} - \frac{T_{xz}}{x} \\ -T_{yz,x}+\frac{T_{yz}}{x} &amp; T_{xz,x} - \frac{T_{xz}}{x} &amp; 0 \end{array}\right) \\ (\partial_y\partial_y T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} T_{xx,x}-\frac{2 T_{xx}}{x} + \frac{2 T_{yy}}{x} &amp; T_{xy,x} - \frac{4 T_{xy}}{x} &amp; T_{xz,x} - \frac{T_{xz}}{x}\\ T_{xy,x}-\frac{4 T_{xy}}{x} &amp; \frac{2 T_{xx}}{x} + T_{yy,x} - \frac{2 T_{yy}}{x} &amp; T_{yz,x} - \frac{T_{yz}}{x}\\ T_{xz,x}-\frac{T_{xz}}{x} &amp; T_{yz,x} - \frac{T_{yz}}{x} &amp; T_{zz,x} \end{array}\right) \\ (\partial_y\partial_z T_{ij}) &amp;=&amp; \frac1x \left(\begin{array}{@{}ccc@{}} -2 T_{xy,z} &amp; T_{xx,z}-T_{yy,z} &amp; -T_{yz,z}\\ T_{xx,z}-T_{yy,z} &amp; 2 T_{xy,z} &amp; T_{xz,z}\\ -T_{yz,z} &amp; T_{xz,z} &amp; 0 \end{array}\right). \end{eqnarray*}
</p>
<p> Note that since we don't transform the derivative but use eq. (7) as defining <code>T</code> for <code>y != 0</code>, the rotation matrices <code>R</code> have to be taken as dependent on <code>y</code> and not as rigid rotations.</p>
<p><b>References</b> </p>
<p>[1] Alcubierre, Miguel, et al. "Symmetry without symmetry: Numerical
     simulation of axisymmetric systems using Cartesian grids." International Journal of Modern Physics D 10.03 (2001): 273-289. </p>

</div>
</div>
<a id="a6205d9000b82f03de99dbe1a13e6996f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6205d9000b82f03de99dbe1a13e6996f">&#9670;&nbsp;</a></span>fd_xz_derivatives()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical.fd_xz_derivatives </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>derivs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>stencil_size</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform finite difference differentiation on specified grid points. </p>
<p>Given a matrix <code>mat</code> containing values on a grid, this function approximates the first or second derivative for each grid point in the given <code>region</code> using 3-, 5-, 7- or 9-point stencils.</p>
<p>Note that only <code>x</code> and <code>z</code> (and possibly mixed) derivatives are computed, even though <code>mat</code> needs to have three axes.</p>
<dl class="section return"><dt>Returns</dt><dd>For each element of <code>derivs</code>, a matrix of the shape of <code>region</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Matrix with the values to use. Must have at least <code>(stencil_size-1)/2</code> additional points in the first and third axes on the borders of the given <code>region</code>. </td></tr>
    <tr><td class="paramname">region</td><td>Region of grid points at which to compute the derivatives. Should consist of three iterables of indices, the tensor product of which defines the actual set of indices in the region. </td></tr>
    <tr><td class="paramname">dx,dz</td><td>Physical distance of grid points in coordinate space along the axes. </td></tr>
    <tr><td class="paramname">derivs</td><td>Derivative orders to compute. To compute the x-, z-, and x-z-derivatives, use <code>derivs=([1, 0], [0, 1], [1, 1])</code>. </td></tr>
    <tr><td class="paramname">stencil_size</td><td>Number of grid points to consider (i.e. the "size" of the stencil). This determines the order of accuracy of the derivative computed. Allowed values currently are 3, 5, 7, 9. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55eee709f1472816b75aad8347c29ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55eee709f1472816b75aad8347c29ab0">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.metric.discrete.numerical.interpolate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coords</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>linear</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cache</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>base_idx</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a (small) matrix patch, interpolate a value between grid points. </p>
<p>This takes the whole matrix patch supplied, i.e. the order of the interpolating polynomial is determined by the size of the patch. For example, if <code>mat</code> is a 5x5x5 matrix, 5 point Lagrange interpolation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>Patch to interpolate within. The size of the patch determines the order of the interpolating polynomials. </td></tr>
    <tr><td class="paramname">coords</td><td>Coordinates in relative index space at which to interpolate. Should be closest to the center grid point for best results. For example, if <code>mat</code> is a 5x5 matrix with indices <code>mat[i,j], i=0,...,4, j=0,...,4</code>, then possible <code>coords</code> are <code>coords = (1.8, 2.2)</code>. If the grid points correspond to physical coordinates, they should be translated into relative index space for this function. </td></tr>
    <tr><td class="paramname">linear</td><td>If <code>True</code>, ignore the patch size and do simple linear interpolation. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">cache</td><td>Optional dictionary to store and reuse interpolating Lagrange polynomials for the first axis of the matrix patch. If given, you also need to supply <code>base_idx</code>, which maps the patch back to the full matrix and allows the cache to be used for the whole data. </td></tr>
    <tr><td class="paramname">base_idx</td><td>Tuple of as many indices as <code>mat</code> has axes. This allows the optional cache to be applicable to the full data when supplying only small patches of it to this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a4f38523f59e06b4fca3b55e93810ee86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f38523f59e06b4fca3b55e93810ee86">&#9670;&nbsp;</a></span>COEFFS_1ST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list COEFFS_1ST</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  [</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    np.array([                  -1., 0.,   1.                 ]) /   2., <span class="comment"># order=2</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    np.array([            1.,   -8., 0.,   8.,   -1.          ]) /  12., <span class="comment"># order=4</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    np.array([     -1.,   9.,  -45., 0.,  45.,   -9.,  1.     ]) /  60., <span class="comment"># order=6</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    np.array([3., -32., 168., -672., 0., 672., -168., 32., -3.]) / 840., <span class="comment"># order=8</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2bea5cb45acc2446d995cc580ce5e999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bea5cb45acc2446d995cc580ce5e999">&#9670;&nbsp;</a></span>COEFFS_2ND</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list COEFFS_2ND</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;=  [</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    np.array([                      1.,     -2.,    1.                   ]),         <span class="comment"># order=2</span></div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    np.array([              -1.,   16.,    -30.,   16.,    -1.           ]) /   12., <span class="comment"># order=4</span></div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    np.array([       2.,   -27.,  270.,   -490.,  270.,   -27.,   2.     ]) /  180., <span class="comment"># order=6</span></div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    np.array([-9., 128., -1008., 8064., -14350., 8064., -1008., 128., -9.]) / 5040., <span class="comment"># order=8</span></div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;]</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1metric.html">metric</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete.html">discrete</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1metric_1_1discrete_1_1numerical.html">numerical</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
