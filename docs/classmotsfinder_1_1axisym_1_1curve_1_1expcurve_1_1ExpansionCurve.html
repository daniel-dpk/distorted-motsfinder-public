<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: ExpansionCurve Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   &#160;<span id="projectnumber">v1.4-4-g8c2eec1</span>
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ExpansionCurve Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class for curves that can calculate their expansion.  
 <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for ExpansionCurve:</div>
<div class="dyncontent">
<div class="center"><img src="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve__inherit__graph.png" border="0" usemap="#aExpansionCurve_inherit__map" alt="Inheritance graph"/></div>
<map name="aExpansionCurve_inherit__map" id="aExpansionCurve_inherit__map">
<area shape="rect" title="Base class for curves that can calculate their expansion." alt="" coords="79,155,206,181"/>
<area shape="rect" href="classmotsfinder_1_1axisym_1_1curve_1_1refparamcurve_1_1RefParamCurve.html" title="Represent a curve as offset function relative to another curve." alt="" coords="5,229,128,256"/>
<area shape="rect" href="classmotsfinder_1_1axisym_1_1curve_1_1starshapedcurve_1_1StarShapedCurve.html" title="Represent as angle&#45;dependent distance from some origin." alt="" coords="153,229,287,256"/>
<area shape="rect" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html" title="Base class for curves in the x&#45;z&#45;plane." alt="" coords="97,80,189,107"/>
<area shape="rect" title=" " alt="" coords="111,5,174,32"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0c98b291b96568621e2fb6a792f9f9c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ac0c98b291b96568621e2fb6a792f9f9c">__init__</a> (self, h, metric, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>='')</td></tr>
<tr class="memdesc:ac0c98b291b96568621e2fb6a792f9f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class constructor taking a horizon function and metric.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ac0c98b291b96568621e2fb6a792f9f9c">More...</a><br /></td></tr>
<tr class="separator:ac0c98b291b96568621e2fb6a792f9f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452fb35a3c468c1f56497580833a223d"><td class="memItemLeft" align="right" valign="top"><a id="a452fb35a3c468c1f56497580833a223d"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a452fb35a3c468c1f56497580833a223d">__getstate__</a> (self)</td></tr>
<tr class="memdesc:a452fb35a3c468c1f56497580833a223d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a picklable state object representing the whole curve. <br /></td></tr>
<tr class="separator:a452fb35a3c468c1f56497580833a223d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a31d38355b42e85a3da79a04e33930"><td class="memItemLeft" align="right" valign="top"><a id="a37a31d38355b42e85a3da79a04e33930"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a37a31d38355b42e85a3da79a04e33930">__setstate__</a> (self, state)</td></tr>
<tr class="memdesc:a37a31d38355b42e85a3da79a04e33930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore a complete curve from the given unpickled state. <br /></td></tr>
<tr class="separator:a37a31d38355b42e85a3da79a04e33930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadd30d50ea29610265ab20b4b27b5a5"><td class="memItemLeft" align="right" valign="top"><a id="abadd30d50ea29610265ab20b4b27b5a5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#abadd30d50ea29610265ab20b4b27b5a5">h_diff</a> (self, param)</td></tr>
<tr class="memdesc:abadd30d50ea29610265ab20b4b27b5a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute derivative of this curve w.r.t. horizon function <code>h</code>. <br /></td></tr>
<tr class="separator:abadd30d50ea29610265ab20b4b27b5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6480b3d8c00e95fb9e74dc1dc2cd5827"><td class="memItemLeft" align="right" valign="top"><a id="a6480b3d8c00e95fb9e74dc1dc2cd5827"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>collocation_points</b> (self, lobatto=False, **kw)</td></tr>
<tr class="separator:a6480b3d8c00e95fb9e74dc1dc2cd5827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c47092b4b37fab331a7626ef63f342e"><td class="memItemLeft" align="right" valign="top"><a id="a4c47092b4b37fab331a7626ef63f342e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>arc_length</b> (self, a=0, b=np.pi, atol=1e-12, rtol=1e-12, full_output=False)</td></tr>
<tr class="separator:a4c47092b4b37fab331a7626ef63f342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16f4c6bd41b64efe15df080b8e39feb"><td class="memItemLeft" align="right" valign="top"><a id="af16f4c6bd41b64efe15df080b8e39feb"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>proper_length_map</b> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, **kw)</td></tr>
<tr class="separator:af16f4c6bd41b64efe15df080b8e39feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2053028a7c722407c3e0156724d8969"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad2053028a7c722407c3e0156724d8969">z_distance</a> (self, other_curve=None, atol=1e-12, rtol=1e-12, limit=100, allow_intersection=False, full_output=False)</td></tr>
<tr class="memdesc:ad2053028a7c722407c3e0156724d8969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the z-distance to another curve or the origin.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad2053028a7c722407c3e0156724d8969">More...</a><br /></td></tr>
<tr class="separator:ad2053028a7c722407c3e0156724d8969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b7e93bceac5de451c3941cb4d38dad"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa9b7e93bceac5de451c3941cb4d38dad">inner_z_distance</a> (self, other_curve, where='top', full_output=False, **kw)</td></tr>
<tr class="memdesc:aa9b7e93bceac5de451c3941cb4d38dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the z-distance of two points of this and another curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa9b7e93bceac5de451c3941cb4d38dad">More...</a><br /></td></tr>
<tr class="separator:aa9b7e93bceac5de451c3941cb4d38dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77698b57e38c511c95a15de2c9165d3"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af77698b57e38c511c95a15de2c9165d3">inner_x_distance</a> (self, other_curve, where='zero', **kw)</td></tr>
<tr class="memdesc:af77698b57e38c511c95a15de2c9165d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the x-distance of two points of this and another curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af77698b57e38c511c95a15de2c9165d3">More...</a><br /></td></tr>
<tr class="separator:af77698b57e38c511c95a15de2c9165d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a466e295d1bb8750fa1df2b746a0524a4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a466e295d1bb8750fa1df2b746a0524a4">get_calc_obj</a> (self, param)</td></tr>
<tr class="memdesc:a466e295d1bb8750fa1df2b746a0524a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create or reuse a calculator object for a given parameter value.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a466e295d1bb8750fa1df2b746a0524a4">More...</a><br /></td></tr>
<tr class="separator:a466e295d1bb8750fa1df2b746a0524a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af121af077346547f69460bdda05c371d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af121af077346547f69460bdda05c371d">horizon_function_changed</a> (self)</td></tr>
<tr class="memdesc:af121af077346547f69460bdda05c371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify this curve that the underlying horizon function has changed.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af121af077346547f69460bdda05c371d">More...</a><br /></td></tr>
<tr class="separator:af121af077346547f69460bdda05c371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e123567df79f0eb5b554d595e328177"><td class="memItemLeft" align="right" valign="top"><a id="a8e123567df79f0eb5b554d595e328177"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a> (self)</td></tr>
<tr class="memdesc:a8e123567df79f0eb5b554d595e328177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolution (number of DOFs) of the horizon function. <br /></td></tr>
<tr class="separator:a8e123567df79f0eb5b554d595e328177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e237fcc955d9e464d5c32fc84a840f9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0e237fcc955d9e464d5c32fc84a840f9">resample</a> (self, new_num)</td></tr>
<tr class="memdesc:a0e237fcc955d9e464d5c32fc84a840f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the number of DOFs of the horizon function.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0e237fcc955d9e464d5c32fc84a840f9">More...</a><br /></td></tr>
<tr class="separator:a0e237fcc955d9e464d5c32fc84a840f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63fc2ab7c97360b53459877417ba7213"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a63fc2ab7c97360b53459877417ba7213">suspend_calc_obj</a> (self)</td></tr>
<tr class="memdesc:a63fc2ab7c97360b53459877417ba7213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager to temporarily ignore the current calculator.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a63fc2ab7c97360b53459877417ba7213">More...</a><br /></td></tr>
<tr class="separator:a63fc2ab7c97360b53459877417ba7213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4424c4e81f70acc59bf8915971821c62"><td class="memItemLeft" align="right" valign="top"><a id="a4424c4e81f70acc59bf8915971821c62"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4424c4e81f70acc59bf8915971821c62">suspend_curv</a> (self)</td></tr>
<tr class="memdesc:a4424c4e81f70acc59bf8915971821c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager to temporarily ignore the extrinsic curvature. <br /></td></tr>
<tr class="separator:a4424c4e81f70acc59bf8915971821c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474b5d328f851a167e5a83cb99f7ed25"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a474b5d328f851a167e5a83cb99f7ed25">temp_metric</a> (self, metric=None)</td></tr>
<tr class="memdesc:a474b5d328f851a167e5a83cb99f7ed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager to temporarily replace the used metric.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a474b5d328f851a167e5a83cb99f7ed25">More...</a><br /></td></tr>
<tr class="separator:a474b5d328f851a167e5a83cb99f7ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d946c32710bf1ff05efb654bee672fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8d946c32710bf1ff05efb654bee672fc">expansion</a> (self, param, hdiff=None, ingoing=False)</td></tr>
<tr class="memdesc:a8d946c32710bf1ff05efb654bee672fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the expansion at one parameter value.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8d946c32710bf1ff05efb654bee672fc">More...</a><br /></td></tr>
<tr class="separator:a8d946c32710bf1ff05efb654bee672fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242dab961b882fae1ab7023a7dbeb44a"><td class="memItemLeft" align="right" valign="top"><a id="a242dab961b882fae1ab7023a7dbeb44a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a242dab961b882fae1ab7023a7dbeb44a">expansions</a> (self, params, hdiff=None, ingoing=False)</td></tr>
<tr class="memdesc:a242dab961b882fae1ab7023a7dbeb44a"><td class="mdescLeft">&#160;</td><td class="mdescRight">As <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8d946c32710bf1ff05efb654bee672fc" title="Compute the expansion at one parameter value.">expansion()</a>, but on a whole set of parameter values. <br /></td></tr>
<tr class="separator:a242dab961b882fae1ab7023a7dbeb44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7eb8ad525191669e3faa100f023277"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aec7eb8ad525191669e3faa100f023277">average_expansion</a> (self, ingoing=False, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3e0047689b5918a7d26f5698a176615d">area</a>=None, full_output=False, **kw)</td></tr>
<tr class="memdesc:aec7eb8ad525191669e3faa100f023277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the average expansion across the surface.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aec7eb8ad525191669e3faa100f023277">More...</a><br /></td></tr>
<tr class="separator:aec7eb8ad525191669e3faa100f023277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb06da2987923a6c0f1efe6b6906d00"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6bb06da2987923a6c0f1efe6b6906d00">collect_close_in_time</a> (self, curves, steps=3)</td></tr>
<tr class="memdesc:a6bb06da2987923a6c0f1efe6b6906d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a list of curves close (in time) to this one.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6bb06da2987923a6c0f1efe6b6906d00">More...</a><br /></td></tr>
<tr class="separator:a6bb06da2987923a6c0f1efe6b6906d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3480e378bb9d98fdbe4b6a8a18f5bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5d3480e378bb9d98fdbe4b6a8a18f5bf">time_interpolators</a> (self, curves, points=None, proper=True, steps=3, eps=0.0)</td></tr>
<tr class="memdesc:a5d3480e378bb9d98fdbe4b6a8a18f5bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a set of functions interpolating along a MOTT.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5d3480e378bb9d98fdbe4b6a8a18f5bf">More...</a><br /></td></tr>
<tr class="separator:a5d3480e378bb9d98fdbe4b6a8a18f5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124738aa04c429c1e8b3622ea2b47044"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a124738aa04c429c1e8b3622ea2b47044">time_shift_params</a> (self, params, tevs, next_curve)</td></tr>
<tr class="memdesc:a124738aa04c429c1e8b3622ea2b47044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transport a list of parameters in time.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a124738aa04c429c1e8b3622ea2b47044">More...</a><br /></td></tr>
<tr class="separator:a124738aa04c429c1e8b3622ea2b47044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac59f67e49be52dc9c8a6d1a5ff846fc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aac59f67e49be52dc9c8a6d1a5ff846fc">signature_quantities</a> (self, pts, curves, proper=True, steps=3)</td></tr>
<tr class="memdesc:aac59f67e49be52dc9c8a6d1a5ff846fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the MOTS tube signature along points of this MOTS.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aac59f67e49be52dc9c8a6d1a5ff846fc">More...</a><br /></td></tr>
<tr class="separator:aac59f67e49be52dc9c8a6d1a5ff846fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad4da6539184472b914b8be8af13791"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4ad4da6539184472b914b8be8af13791">time_evolution_vector</a> (self, pts, curves, steps=3, search_step=1e-3, search_dist_increase=10, max_increases=4, Ns=400, tol=1e-12, full_output=False, verbose=False)</td></tr>
<tr class="memdesc:a4ad4da6539184472b914b8be8af13791"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the time evolution 4D vector.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4ad4da6539184472b914b8be8af13791">More...</a><br /></td></tr>
<tr class="separator:a4ad4da6539184472b914b8be8af13791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38053ffe9e087b496b35cdbbc6327d8b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a38053ffe9e087b496b35cdbbc6327d8b">integrate_tev_divergence</a> (self, curves, tev_args=None, n=&quot;auto&quot;, unity_b=False, full_output=False)</td></tr>
<tr class="memdesc:a38053ffe9e087b496b35cdbbc6327d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate the divergence of the time evolution vector (TEV).  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a38053ffe9e087b496b35cdbbc6327d8b">More...</a><br /></td></tr>
<tr class="separator:a38053ffe9e087b496b35cdbbc6327d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c589ad969baa9f956e0eb2491653ba"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a45c589ad969baa9f956e0eb2491653ba">dt_normals</a> (self, pts, curves, steps=3, use_tev=True, tevs=None, unload=True, full_output=False)</td></tr>
<tr class="memdesc:a45c589ad969baa9f956e0eb2491653ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the time derivative of the MOTS normal within the slice.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a45c589ad969baa9f956e0eb2491653ba">More...</a><br /></td></tr>
<tr class="separator:a45c589ad969baa9f956e0eb2491653ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bd95251b6fa5eba926e9007588f961"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a19bd95251b6fa5eba926e9007588f961">extremality_parameter</a> (self, curves, steps=3, n=&quot;auto&quot;, full_output=False)</td></tr>
<tr class="memdesc:a19bd95251b6fa5eba926e9007588f961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extremality parameter.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a19bd95251b6fa5eba926e9007588f961">More...</a><br /></td></tr>
<tr class="separator:a19bd95251b6fa5eba926e9007588f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf576f119b60fc790caa871324a88dca"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adf576f119b60fc790caa871324a88dca">surface_gravity</a> (self, pts, curves, steps=3, wrt=&quot;ell&quot;, tevs=None)</td></tr>
<tr class="memdesc:adf576f119b60fc790caa871324a88dca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a (slicing dependent) surface gravity.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adf576f119b60fc790caa871324a88dca">More...</a><br /></td></tr>
<tr class="separator:adf576f119b60fc790caa871324a88dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa857530befbb8273056ab18d5f588fd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd">timescale_tau2</a> (self, tevs, kappas_tev, proper_pts, curves, steps=3, option=0)</td></tr>
<tr class="memdesc:aaa857530befbb8273056ab18d5f588fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of the timescale <code>tau</code>.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aaa857530befbb8273056ab18d5f588fd">More...</a><br /></td></tr>
<tr class="separator:aaa857530befbb8273056ab18d5f588fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40079c05732aedfe1bc8544e7a5d2014"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a40079c05732aedfe1bc8544e7a5d2014">timescale_T2</a> (self, tevs)</td></tr>
<tr class="memdesc:a40079c05732aedfe1bc8544e7a5d2014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the square of the timescale <code>T</code>.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a40079c05732aedfe1bc8544e7a5d2014">More...</a><br /></td></tr>
<tr class="separator:a40079c05732aedfe1bc8544e7a5d2014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5c782f8ffdf59548daf2e6d39666e8"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5f5c782f8ffdf59548daf2e6d39666e8">xi_vector</a> (self, pts, curves, steps=3, r_hat=True, full_output=False, get_tevs=False, tevs=None)</td></tr>
<tr class="memdesc:a5f5c782f8ffdf59548daf2e6d39666e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the xi vector.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5f5c782f8ffdf59548daf2e6d39666e8">More...</a><br /></td></tr>
<tr class="separator:a5f5c782f8ffdf59548daf2e6d39666e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1dca9e2b825bc59677a54a64a07b7c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4e1dca9e2b825bc59677a54a64a07b7c">xi_square_integral</a> (self, curves, steps=3, n=&quot;auto&quot;)</td></tr>
<tr class="memdesc:a4e1dca9e2b825bc59677a54a64a07b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the square of the xi vector.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4e1dca9e2b825bc59677a54a64a07b7c">More...</a><br /></td></tr>
<tr class="separator:a4e1dca9e2b825bc59677a54a64a07b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0967b92e27f90bef5e071afe84f9752"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa0967b92e27f90bef5e071afe84f9752">expand_xi_scalar</a> (self, curves, steps=3, lmax=&quot;auto&quot;, zeta=None, min_lmax=64, max_lmax=512, coeff_threshold=None, compress=True, hat=False, r_hat=True, full_output=False)</td></tr>
<tr class="memdesc:aa0967b92e27f90bef5e071afe84f9752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the xi vector into spin weighted spherical harmonics.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa0967b92e27f90bef5e071afe84f9752">More...</a><br /></td></tr>
<tr class="separator:aa0967b92e27f90bef5e071afe84f9752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82822ba93eadd30cf5d02bdbcab3887"><td class="memItemLeft" align="right" valign="top"><a id="af82822ba93eadd30cf5d02bdbcab3887"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af82822ba93eadd30cf5d02bdbcab3887">get_stability_calc_obj</a> (self, param)</td></tr>
<tr class="memdesc:af82822ba93eadd30cf5d02bdbcab3887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a StabilityCalc object at the given point of the curve. <br /></td></tr>
<tr class="separator:af82822ba93eadd30cf5d02bdbcab3887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f87fe8930191d84b8a0f9c878f3078"><td class="memItemLeft" align="right" valign="top"><a id="af2f87fe8930191d84b8a0f9c878f3078"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af2f87fe8930191d84b8a0f9c878f3078">linearized_equation_at</a> (self, param, target_expansion=0.0)</td></tr>
<tr class="memdesc:af2f87fe8930191d84b8a0f9c878f3078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the terms of the linearized version of H=0 at one point. <br /></td></tr>
<tr class="separator:af2f87fe8930191d84b8a0f9c878f3078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287674a9252dd9228d16780a17670129"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a287674a9252dd9228d16780a17670129">linearized_equation</a> (self, params, target_expansion=0.0, parallel=False, pool=None)</td></tr>
<tr class="memdesc:a287674a9252dd9228d16780a17670129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return linearized equation as operator and inhomogeneity on a grid.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a287674a9252dd9228d16780a17670129">More...</a><br /></td></tr>
<tr class="separator:a287674a9252dd9228d16780a17670129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b59585b2daf3036737fe2e3a3a9f80"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a05b59585b2daf3036737fe2e3a3a9f80">ricci_scalar</a> (self, param)</td></tr>
<tr class="memdesc:a05b59585b2daf3036737fe2e3a3a9f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Ricci scalar of the surface at the given parameter.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a05b59585b2daf3036737fe2e3a3a9f80">More...</a><br /></td></tr>
<tr class="separator:a05b59585b2daf3036737fe2e3a3a9f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ef465ecbfd8d1a0f5413bda0a8f325"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a49ef465ecbfd8d1a0f5413bda0a8f325">extrinsic_surface_curvature</a> (self, param, trace=False, square=False)</td></tr>
<tr class="memdesc:a49ef465ecbfd8d1a0f5413bda0a8f325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the extrinsic curvature tensor of the surface.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a49ef465ecbfd8d1a0f5413bda0a8f325">More...</a><br /></td></tr>
<tr class="separator:a49ef465ecbfd8d1a0f5413bda0a8f325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0047689b5918a7d26f5698a176615d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3e0047689b5918a7d26f5698a176615d">area</a> (self, full_output=False, disp=False, domain=(0, np.pi), **kw)</td></tr>
<tr class="memdesc:a3e0047689b5918a7d26f5698a176615d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the area of the surface represented by this curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3e0047689b5918a7d26f5698a176615d">More...</a><br /></td></tr>
<tr class="separator:a3e0047689b5918a7d26f5698a176615d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95132b13eed51da5774d19df48cd8f7"><td class="memItemLeft" align="right" valign="top"><a id="ad95132b13eed51da5774d19df48cd8f7"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad95132b13eed51da5774d19df48cd8f7">get_ricci_scalar_func</a> (self, cached=False)</td></tr>
<tr class="memdesc:ad95132b13eed51da5774d19df48cd8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an (optionally cached) function to evaluate the Ricci scalar. <br /></td></tr>
<tr class="separator:ad95132b13eed51da5774d19df48cd8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d5f7aa93ad9cf41e64aa493710e7ac7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5d5f7aa93ad9cf41e64aa493710e7ac7">get_det_q_func</a> (self, cached=False)</td></tr>
<tr class="memdesc:a5d5f7aa93ad9cf41e64aa493710e7ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a function to evaluate det(q).  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5d5f7aa93ad9cf41e64aa493710e7ac7">More...</a><br /></td></tr>
<tr class="separator:a5d5f7aa93ad9cf41e64aa493710e7ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea218e8051c9c6b433fc008c252d9b1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#afea218e8051c9c6b433fc008c252d9b1">get_area_integrand</a> (self)</td></tr>
<tr class="memdesc:afea218e8051c9c6b433fc008c252d9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a callable evaluating the sqrt(det(q)), i.e.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#afea218e8051c9c6b433fc008c252d9b1">More...</a><br /></td></tr>
<tr class="separator:afea218e8051c9c6b433fc008c252d9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59175e6bd575240b590d3ec3d0549ffa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a59175e6bd575240b590d3ec3d0549ffa">euler_char</a> (self, a=0, b=np.pi, full_output=False, disp=False, **kw)</td></tr>
<tr class="memdesc:a59175e6bd575240b590d3ec3d0549ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Euler characteristic of the surface.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a59175e6bd575240b590d3ec3d0549ffa">More...</a><br /></td></tr>
<tr class="separator:a59175e6bd575240b590d3ec3d0549ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea5c33ef11a8f6531a62f65777be3a34"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aea5c33ef11a8f6531a62f65777be3a34">irreducible_mass</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3e0047689b5918a7d26f5698a176615d">area</a>=None)</td></tr>
<tr class="memdesc:aea5c33ef11a8f6531a62f65777be3a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the irreducible mass.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aea5c33ef11a8f6531a62f65777be3a34">More...</a><br /></td></tr>
<tr class="separator:aea5c33ef11a8f6531a62f65777be3a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321e36a1dbf23d671dda1f83832d8d07"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a321e36a1dbf23d671dda1f83832d8d07">horizon_radius</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3e0047689b5918a7d26f5698a176615d">area</a>=None)</td></tr>
<tr class="memdesc:a321e36a1dbf23d671dda1f83832d8d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the horizon radius.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a321e36a1dbf23d671dda1f83832d8d07">More...</a><br /></td></tr>
<tr class="separator:a321e36a1dbf23d671dda1f83832d8d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621b9f8de00dfe38f3462427775d876d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a621b9f8de00dfe38f3462427775d876d">stability_parameter</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, m_max=None, m_terminate_index=30, rtol=1e-12, compute_eigenfunctions=False, slice_normal=True, transform_torsion=False, force_general=False, zeta=None, basis_cls=ChebyBasis, full_output=False)</td></tr>
<tr class="memdesc:a621b9f8de00dfe38f3462427775d876d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the stability parameter.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a621b9f8de00dfe38f3462427775d876d">More...</a><br /></td></tr>
<tr class="separator:a621b9f8de00dfe38f3462427775d876d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b72eda23af6809e3e8fe0efc629bea"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a92b72eda23af6809e3e8fe0efc629bea">shear</a> (self, param, full_output=False)</td></tr>
<tr class="memdesc:a92b72eda23af6809e3e8fe0efc629bea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shear of the MOTS at a point.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a92b72eda23af6809e3e8fe0efc629bea">More...</a><br /></td></tr>
<tr class="separator:a92b72eda23af6809e3e8fe0efc629bea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c32ba686eba25a876d97795c9f6dc"><td class="memItemLeft" align="right" valign="top"><a id="ad20c32ba686eba25a876d97795c9f6dc"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>shear_hat_square_integral</b> (self, tevs)</td></tr>
<tr class="separator:ad20c32ba686eba25a876d97795c9f6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb64e0c5cf26aebd690f4554fdecdd0"><td class="memItemLeft" align="right" valign="top"><a id="a5eb64e0c5cf26aebd690f4554fdecdd0"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>xi_hat_square_integral</b> (self, tevs, curves, steps=3)</td></tr>
<tr class="separator:a5eb64e0c5cf26aebd690f4554fdecdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5c000930d3e6d00162847b955b295e"><td class="memItemLeft" align="right" valign="top"><a id="a6a5c000930d3e6d00162847b955b295e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>compute_xi_square_integral</b> (self, tevs, curves, steps=3, hat=False, r_hat=True)</td></tr>
<tr class="separator:a6a5c000930d3e6d00162847b955b295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380a3fc19ab9398c2ac5a30068553444"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a380a3fc19ab9398c2ac5a30068553444">shear_square_integral</a> (self, n=&quot;auto&quot;)</td></tr>
<tr class="memdesc:a380a3fc19ab9398c2ac5a30068553444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the shear squared.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a380a3fc19ab9398c2ac5a30068553444">More...</a><br /></td></tr>
<tr class="separator:a380a3fc19ab9398c2ac5a30068553444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa641f4b2dd3163ce333e948970884a7c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa641f4b2dd3163ce333e948970884a7c">shear_scalar</a> (self, param, full_output=False)</td></tr>
<tr class="memdesc:aa641f4b2dd3163ce333e948970884a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the complex shear scalar.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa641f4b2dd3163ce333e948970884a7c">More...</a><br /></td></tr>
<tr class="separator:aa641f4b2dd3163ce333e948970884a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab6ec2db3a3392db0e778878c44668a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a7ab6ec2db3a3392db0e778878c44668a">expand_shear_scalar</a> (self, lmax=&quot;auto&quot;, zeta=None, min_lmax=64, max_lmax=4096, coeff_threshold=None, hat=False, curves=None, steps=3, compress=True, full_output=False)</td></tr>
<tr class="memdesc:a7ab6ec2db3a3392db0e778878c44668a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the shear scalar into spin 2 weighted spherical harmonics.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a7ab6ec2db3a3392db0e778878c44668a">More...</a><br /></td></tr>
<tr class="separator:a7ab6ec2db3a3392db0e778878c44668a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f22b1b99aaf1965a8acee1648a16499"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a9f22b1b99aaf1965a8acee1648a16499">compute_zeta</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, det_q_function=None)</td></tr>
<tr class="memdesc:a9f22b1b99aaf1965a8acee1648a16499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerically compute the invariant angle zeta.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a9f22b1b99aaf1965a8acee1648a16499">More...</a><br /></td></tr>
<tr class="separator:a9f22b1b99aaf1965a8acee1648a16499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9369f0ebb256c0239aaea0e8df62a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a1f9369f0ebb256c0239aaea0e8df62a9">multipoles</a> (self, min_n=0, max_n=10, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a8e123567df79f0eb5b554d595e328177">num</a>=None, det_q_function=None, ricci_scalar_function=None, zeta=None, full_output=False, disp=False, **kw)</td></tr>
<tr class="memdesc:a1f9369f0ebb256c0239aaea0e8df62a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the multipoles I_n of the horizon.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a1f9369f0ebb256c0239aaea0e8df62a9">More...</a><br /></td></tr>
<tr class="separator:a1f9369f0ebb256c0239aaea0e8df62a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1289f5b3e099b0f8f124aaa50be6b1"><td class="memItemLeft" align="right" valign="top"><a id="a3d1289f5b3e099b0f8f124aaa50be6b1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3d1289f5b3e099b0f8f124aaa50be6b1">circumference</a> (self, param)</td></tr>
<tr class="memdesc:a3d1289f5b3e099b0f8f124aaa50be6b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the circumference of the surface at the given parameter. <br /></td></tr>
<tr class="separator:a3d1289f5b3e099b0f8f124aaa50be6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3301e4a4e9697771e4d19b9b03b87db1"><td class="memItemLeft" align="right" valign="top"><a id="a3301e4a4e9697771e4d19b9b03b87db1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3301e4a4e9697771e4d19b9b03b87db1">x_distance</a> (self, param, **kw)</td></tr>
<tr class="memdesc:a3301e4a4e9697771e4d19b9b03b87db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the proper length of a coordinate line from the curve to the z-axis. <br /></td></tr>
<tr class="separator:a3301e4a4e9697771e4d19b9b03b87db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da563d8d0d36fb22f95b39c26a5a4a"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad4da563d8d0d36fb22f95b39c26a5a4a">find_neck</a> (self, algo='coord', xtol=1e-8, **kw)</td></tr>
<tr class="memdesc:ad4da563d8d0d36fb22f95b39c26a5a4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to locate a 'neck' of this curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad4da563d8d0d36fb22f95b39c26a5a4a">More...</a><br /></td></tr>
<tr class="separator:ad4da563d8d0d36fb22f95b39c26a5a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb06f51cca9db99704ae9fe5eac6a26"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#afdb06f51cca9db99704ae9fe5eac6a26">locate_intersection</a> (self, other_curve, xtol=1e-8, domain1=(0, np.pi), domain2=(0, np.pi), strict1=True, strict2=True, N1=20, N2=20)</td></tr>
<tr class="memdesc:afdb06f51cca9db99704ae9fe5eac6a26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate one point at which this curve intersects another curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#afdb06f51cca9db99704ae9fe5eac6a26">More...</a><br /></td></tr>
<tr class="separator:afdb06f51cca9db99704ae9fe5eac6a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca1e6cd728f86908a070a06765d59ae"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6ca1e6cd728f86908a070a06765d59ae">locate_self_intersection</a> (self, neck=None, xtol=1e-8)</td></tr>
<tr class="memdesc:a6ca1e6cd728f86908a070a06765d59ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locate a <em>loop</em> in the MOTS around its neck.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6ca1e6cd728f86908a070a06765d59ae">More...</a><br /></td></tr>
<tr class="separator:a6ca1e6cd728f86908a070a06765d59ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e142fbf691a6c614554fea33624c1e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a12e142fbf691a6c614554fea33624c1e">get_distance_function</a> (self, other_curve, Ns=None, xatol=1e-12, mp_finish=True, dps=50, minima_to_check=1)</td></tr>
<tr class="memdesc:a12e142fbf691a6c614554fea33624c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a callable computing the distance between this and another curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a12e142fbf691a6c614554fea33624c1e">More...</a><br /></td></tr>
<tr class="separator:a12e142fbf691a6c614554fea33624c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4417b4ffab13d47bbcb986cc844ae2f7"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4417b4ffab13d47bbcb986cc844ae2f7">plot_expansion</a> (self, c=0, points=500, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>=r&quot;\gamma&quot;, figsize=(5, 3), verbose=True, ingoing=False, **kw)</td></tr>
<tr class="memdesc:a4417b4ffab13d47bbcb986cc844ae2f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to plot the expansion along the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4417b4ffab13d47bbcb986cc844ae2f7">More...</a><br /></td></tr>
<tr class="separator:a4417b4ffab13d47bbcb986cc844ae2f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b50656b2043eb74fa8321e6c2419238"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0b50656b2043eb74fa8321e6c2419238">plot_coeffs</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>=r&quot;\gamma&quot;, figsize=(5, 3), **kw)</td></tr>
<tr class="memdesc:a0b50656b2043eb74fa8321e6c2419238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function to plot the horizon function's spectral coefficients.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0b50656b2043eb74fa8321e6c2419238">More...</a><br /></td></tr>
<tr class="separator:a0b50656b2043eb74fa8321e6c2419238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html">BaseCurve</a></td></tr>
<tr class="memitem:adf720f5b495cd977ef9d261d5f20b7bf inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#adf720f5b495cd977ef9d261d5f20b7bf">__init__</a> (self, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a>='')</td></tr>
<tr class="memdesc:adf720f5b495cd977ef9d261d5f20b7bf inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baseclass init for curves.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#adf720f5b495cd977ef9d261d5f20b7bf">More...</a><br /></td></tr>
<tr class="separator:adf720f5b495cd977ef9d261d5f20b7bf inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3700b94d209d5fc275b75342c97ab92a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a3700b94d209d5fc275b75342c97ab92a">save</a> (self, filename, overwrite=False, verbose=True, msg='')</td></tr>
<tr class="memdesc:a3700b94d209d5fc275b75342c97ab92a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the curve to disk.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a3700b94d209d5fc275b75342c97ab92a">More...</a><br /></td></tr>
<tr class="separator:a3700b94d209d5fc275b75342c97ab92a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7177919b0036bb495fb3aa3fbdd9f102 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a7177919b0036bb495fb3aa3fbdd9f102">load</a> (cls, filename, retries=0, sleep=5, verbose=False)</td></tr>
<tr class="memdesc:a7177919b0036bb495fb3aa3fbdd9f102 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method to load an object from disk.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a7177919b0036bb495fb3aa3fbdd9f102">More...</a><br /></td></tr>
<tr class="separator:a7177919b0036bb495fb3aa3fbdd9f102 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fff96e4e479ac2c0657a9d7b5c277a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="ac5fff96e4e479ac2c0657a9d7b5c277a"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac5fff96e4e479ac2c0657a9d7b5c277a">loaded_from</a> (self)</td></tr>
<tr class="memdesc:ac5fff96e4e479ac2c0657a9d7b5c277a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filename (if any) from which this object was loaded. <br /></td></tr>
<tr class="separator:ac5fff96e4e479ac2c0657a9d7b5c277a inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade300aee3cd305ca4ada280d408f471c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ade300aee3cd305ca4ada280d408f471c">user_data</a> (self)</td></tr>
<tr class="memdesc:ade300aee3cd305ca4ada280d408f471c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary of custom data stored in the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ade300aee3cd305ca4ada280d408f471c">More...</a><br /></td></tr>
<tr class="separator:ade300aee3cd305ca4ada280d408f471c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25b8d0cbf89b13338c98f0d5d1012b4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="ac25b8d0cbf89b13338c98f0d5d1012b4"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac25b8d0cbf89b13338c98f0d5d1012b4">replace_user_data</a> (self, new_data)</td></tr>
<tr class="memdesc:ac25b8d0cbf89b13338c98f0d5d1012b4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the <code>user_data</code> dictionary with a different object. <br /></td></tr>
<tr class="separator:ac25b8d0cbf89b13338c98f0d5d1012b4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5907ca3bbf8e7cd8f40c3007338f6d02 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a5907ca3bbf8e7cd8f40c3007338f6d02"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a5907ca3bbf8e7cd8f40c3007338f6d02">name</a> (self)</td></tr>
<tr class="memdesc:a5907ca3bbf8e7cd8f40c3007338f6d02 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of this curve (used e.g. as label for plotting). <br /></td></tr>
<tr class="separator:a5907ca3bbf8e7cd8f40c3007338f6d02 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d212fdcbbcee30e90a64ce349d32f8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a62d212fdcbbcee30e90a64ce349d32f8"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> (self, value)</td></tr>
<tr class="separator:a62d212fdcbbcee30e90a64ce349d32f8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f62eec984a99f7a9a7ee58c40cd4c4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a10f62eec984a99f7a9a7ee58c40cd4c4">override_evaluator</a> (self, evaluator)</td></tr>
<tr class="memdesc:a10f62eec984a99f7a9a7ee58c40cd4c4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context for temporarily overriding the evaluator(s) used.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a10f62eec984a99f7a9a7ee58c40cd4c4">More...</a><br /></td></tr>
<tr class="separator:a10f62eec984a99f7a9a7ee58c40cd4c4 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6386ff53ecf46bc525a3cb16448ae413 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a6386ff53ecf46bc525a3cb16448ae413"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6386ff53ecf46bc525a3cb16448ae413">fix_evaluator</a> (self)</td></tr>
<tr class="memdesc:a6386ff53ecf46bc525a3cb16448ae413 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context to temporarily fix the evaluator(s) of used expressions. <br /></td></tr>
<tr class="separator:a6386ff53ecf46bc525a3cb16448ae413 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdfc1c44054807f99ee5e5052ee6d4db inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abdfc1c44054807f99ee5e5052ee6d4db">freeze_evaluator</a> (self)</td></tr>
<tr class="memdesc:abdfc1c44054807f99ee5e5052ee6d4db inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indefinitely freeze all evaluators of this curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abdfc1c44054807f99ee5e5052ee6d4db">More...</a><br /></td></tr>
<tr class="separator:abdfc1c44054807f99ee5e5052ee6d4db inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86324d541d9b0f48b3cfe8647467613 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="ad86324d541d9b0f48b3cfe8647467613"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ad86324d541d9b0f48b3cfe8647467613">unfreeze_evaluator</a> (self)</td></tr>
<tr class="memdesc:ad86324d541d9b0f48b3cfe8647467613 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo a <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#abdfc1c44054807f99ee5e5052ee6d4db" title="Indefinitely freeze all evaluators of this curve.">freeze_evaluator()</a> call. <br /></td></tr>
<tr class="separator:ad86324d541d9b0f48b3cfe8647467613 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174ee487da3aeeb80f401bac6659a5b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a6174ee487da3aeeb80f401bac6659a5b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6174ee487da3aeeb80f401bac6659a5b">force_evaluator_update</a> (self)</td></tr>
<tr class="memdesc:a6174ee487da3aeeb80f401bac6659a5b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force all cached evaluators to be refreshed. <br /></td></tr>
<tr class="separator:a6174ee487da3aeeb80f401bac6659a5b inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf6261b742ae694c16790726a8c77c5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="aebf6261b742ae694c16790726a8c77c5"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aebf6261b742ae694c16790726a8c77c5">copy</a> (self)</td></tr>
<tr class="memdesc:aebf6261b742ae694c16790726a8c77c5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an independent copy of this curve. <br /></td></tr>
<tr class="separator:aebf6261b742ae694c16790726a8c77c5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac216f7b7ba5435436bdb601aebe7b284 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac216f7b7ba5435436bdb601aebe7b284">__call__</a> (self, param, xyz=False)</td></tr>
<tr class="memdesc:ac216f7b7ba5435436bdb601aebe7b284 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the curve at a particular parameter value.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac216f7b7ba5435436bdb601aebe7b284">More...</a><br /></td></tr>
<tr class="separator:ac216f7b7ba5435436bdb601aebe7b284 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d64214395625dd136acac967dc8539 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a79d64214395625dd136acac967dc8539"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a79d64214395625dd136acac967dc8539">collocation_points</a> (self, **kw)</td></tr>
<tr class="memdesc:a79d64214395625dd136acac967dc8539 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the collocation points of the current curve representation. <br /></td></tr>
<tr class="separator:a79d64214395625dd136acac967dc8539 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ab29fbc886ed361b8bd4e78a468cd inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">diff</a> (self, param, diff=1, xyz=False)</td></tr>
<tr class="memdesc:af90ab29fbc886ed361b8bd4e78a468cd inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the derivative of this curve w.r.t. its parameter.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">More...</a><br /></td></tr>
<tr class="separator:af90ab29fbc886ed361b8bd4e78a468cd inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f6d98c9d65d438f6883a7b11628cac inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac4f6d98c9d65d438f6883a7b11628cac">tangent</a> (self, param, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">diff</a>=0, xyz=False)</td></tr>
<tr class="memdesc:ac4f6d98c9d65d438f6883a7b11628cac inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidean) tangent vector or one of its derivatives.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ac4f6d98c9d65d438f6883a7b11628cac">More...</a><br /></td></tr>
<tr class="separator:ac4f6d98c9d65d438f6883a7b11628cac inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde5537a950b9c8a5e0c430fc86d91d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1bde5537a950b9c8a5e0c430fc86d91d">normal</a> (self, param, <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af90ab29fbc886ed361b8bd4e78a468cd">diff</a>=0, xyz=False)</td></tr>
<tr class="memdesc:a1bde5537a950b9c8a5e0c430fc86d91d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the (Euclidean) normal vector or a derivative thereof.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1bde5537a950b9c8a5e0c430fc86d91d">More...</a><br /></td></tr>
<tr class="separator:a1bde5537a950b9c8a5e0c430fc86d91d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb82a7718f79c5641e8caf3d3c86da5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2eb82a7718f79c5641e8caf3d3c86da5">curvature_in_coord_space</a> (self, param)</td></tr>
<tr class="memdesc:a2eb82a7718f79c5641e8caf3d3c86da5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the curvature of this curve in flat coordinate space.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2eb82a7718f79c5641e8caf3d3c86da5">More...</a><br /></td></tr>
<tr class="separator:a2eb82a7718f79c5641e8caf3d3c86da5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd813da94de7a86721ed6f86e581008 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aecd813da94de7a86721ed6f86e581008">arc_length</a> (self, a=0, b=np.pi, atol=1e-12, rtol=1e-12, limit=100, full_output=False)</td></tr>
<tr class="memdesc:aecd813da94de7a86721ed6f86e581008 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aecd813da94de7a86721ed6f86e581008">More...</a><br /></td></tr>
<tr class="separator:aecd813da94de7a86721ed6f86e581008 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf941a618b577b673e4d897bca584d7 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7">arc_length_using_metric</a> (self, metric, a=0, b=np.pi, atol=1e-12, rtol=1e-12, limit=100, full_output=False)</td></tr>
<tr class="memdesc:a0bf941a618b577b673e4d897bca584d7 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the length of this curve w.r.t. a given metric.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7">More...</a><br /></td></tr>
<tr class="separator:a0bf941a618b577b673e4d897bca584d7 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa295e91e8fec272ea965605cd3a9ff69 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aa295e91e8fec272ea965605cd3a9ff69">proper_length_map</a> (self, num=None, evaluators=True, accurate=True, full_output=False, **kw)</td></tr>
<tr class="memdesc:aa295e91e8fec272ea965605cd3a9ff69 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate functions to map between curve parameter and proper length.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aa295e91e8fec272ea965605cd3a9ff69">More...</a><br /></td></tr>
<tr class="separator:aa295e91e8fec272ea965605cd3a9ff69 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e6955081abbb4458fdd3002cc159d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a09e6955081abbb4458fdd3002cc159d5">cached_length_maps</a> (self, evaluators=True, warn=True, full_output=False)</td></tr>
<tr class="memdesc:a09e6955081abbb4458fdd3002cc159d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the proper length maps from the curve's <code>user_data</code>.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a09e6955081abbb4458fdd3002cc159d5">More...</a><br /></td></tr>
<tr class="separator:a09e6955081abbb4458fdd3002cc159d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1beed94746c44987d8fce97cc3173d24 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1beed94746c44987d8fce97cc3173d24">z_distance_using_metric</a> (self, metric, other_curve=None, atol=1e-12, rtol=1e-12, limit=100, allow_intersection=False, full_output=False)</td></tr>
<tr class="memdesc:a1beed94746c44987d8fce97cc3173d24 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute z-distance to another curve w.r.t. a given metric.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1beed94746c44987d8fce97cc3173d24">More...</a><br /></td></tr>
<tr class="separator:a1beed94746c44987d8fce97cc3173d24 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8fe559aeaa7a8bd70a89a39bb2fb94 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0d8fe559aeaa7a8bd70a89a39bb2fb94">rotate_to_xz_plane</a> (self, point)</td></tr>
<tr class="memdesc:a0d8fe559aeaa7a8bd70a89a39bb2fb94 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotate a 3D point onto the x-z-plane with positive x.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0d8fe559aeaa7a8bd70a89a39bb2fb94">More...</a><br /></td></tr>
<tr class="separator:a0d8fe559aeaa7a8bd70a89a39bb2fb94 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0d4bbd33a7d210f88789216f24ec9d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af0d4bbd33a7d210f88789216f24ec9d5">closest_point</a> (self, point, start_param=None, Ns=25)</td></tr>
<tr class="memdesc:af0d4bbd33a7d210f88789216f24ec9d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the parameter at which the curve is closest to a given point.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af0d4bbd33a7d210f88789216f24ec9d5">More...</a><br /></td></tr>
<tr class="separator:af0d4bbd33a7d210f88789216f24ec9d5 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06de71936f2ea3123e81da7cdf38e594 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a06de71936f2ea3123e81da7cdf38e594">find_line_intersection</a> (self, point, vector, Ns=50)</td></tr>
<tr class="memdesc:a06de71936f2ea3123e81da7cdf38e594 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the point at which this curve intersects a given line.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a06de71936f2ea3123e81da7cdf38e594">More...</a><br /></td></tr>
<tr class="separator:a06de71936f2ea3123e81da7cdf38e594 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c7cd146b41d259e63a054663978a2d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a66c7cd146b41d259e63a054663978a2d">find_max_x</a> (self, Ns=50)</td></tr>
<tr class="memdesc:a66c7cd146b41d259e63a054663978a2d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the point of the curve with maximum distance to the z-axis.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a66c7cd146b41d259e63a054663978a2d">More...</a><br /></td></tr>
<tr class="separator:a66c7cd146b41d259e63a054663978a2d inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab918d07baeb7e91c3d3db5bcb67e3d34 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ab918d07baeb7e91c3d3db5bcb67e3d34">find_local_min_x</a> (self, Ns=None)</td></tr>
<tr class="memdesc:ab918d07baeb7e91c3d3db5bcb67e3d34 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the location of a local minimum of the x-coordinate.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ab918d07baeb7e91c3d3db5bcb67e3d34">More...</a><br /></td></tr>
<tr class="separator:ab918d07baeb7e91c3d3db5bcb67e3d34 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c3e773d4be4b4834988c1d1cc5b4fc inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a75c3e773d4be4b4834988c1d1cc5b4fc">inf_norm</a> (self, other_curve, **kw)</td></tr>
<tr class="memdesc:a75c3e773d4be4b4834988c1d1cc5b4fc inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute L_inf norm of this curve minus another curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a75c3e773d4be4b4834988c1d1cc5b4fc">More...</a><br /></td></tr>
<tr class="separator:a75c3e773d4be4b4834988c1d1cc5b4fc inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fd2069205163d29380e6e8dd5e62d8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a30fd2069205163d29380e6e8dd5e62d8">point_distances</a> (self, params=None)</td></tr>
<tr class="memdesc:a30fd2069205163d29380e6e8dd5e62d8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the coordinate distances of points along the curve.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a30fd2069205163d29380e6e8dd5e62d8">More...</a><br /></td></tr>
<tr class="separator:a30fd2069205163d29380e6e8dd5e62d8 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db2769d4f034b27e6fbe4fd77cdf27c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a6db2769d4f034b27e6fbe4fd77cdf27c"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a6db2769d4f034b27e6fbe4fd77cdf27c">plot_distances</a> (self, params=None, **kw)</td></tr>
<tr class="memdesc:a6db2769d4f034b27e6fbe4fd77cdf27c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for quickly plotting coordinate distances of collocation points. <br /></td></tr>
<tr class="separator:a6db2769d4f034b27e6fbe4fd77cdf27c inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee51925b3eab3e6be9004ae866af46 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a47ee51925b3eab3e6be9004ae866af46">plot</a> (self, lw=2, equal_lengths=True, copy_x=True, **kw)</td></tr>
<tr class="memdesc:a47ee51925b3eab3e6be9004ae866af46 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plot the curve represented by this object.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a47ee51925b3eab3e6be9004ae866af46">More...</a><br /></td></tr>
<tr class="separator:a47ee51925b3eab3e6be9004ae866af46 inherit pub_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5e36941b3d856737e81516acd45edc50"><td class="memItemLeft" align="right" valign="top"><a id="a5e36941b3d856737e81516acd45edc50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>h</b></td></tr>
<tr class="separator:a5e36941b3d856737e81516acd45edc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0cae22c2d95be3ff185398d62a4a32"><td class="memItemLeft" align="right" valign="top"><a id="a5d0cae22c2d95be3ff185398d62a4a32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>metric</b></td></tr>
<tr class="separator:a5d0cae22c2d95be3ff185398d62a4a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0898b285d76b1bc8480f855f81cd74ef"><td class="memItemLeft" align="right" valign="top"><a id="a0898b285d76b1bc8480f855f81cd74ef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>extr_curvature</b></td></tr>
<tr class="separator:a0898b285d76b1bc8480f855f81cd74ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html">BaseCurve</a></td></tr>
<tr class="memitem:a8a6287602630db6aeffcb6cf5787a216 inherit pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top"><a id="a8a6287602630db6aeffcb6cf5787a216"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>domain</b></td></tr>
<tr class="separator:a8a6287602630db6aeffcb6cf5787a216 inherit pub_attribs_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:af3056926ad0964c2b80f97a192ad8c89"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af3056926ad0964c2b80f97a192ad8c89">_create_evaluators</a> (self)</td></tr>
<tr class="memdesc:af3056926ad0964c2b80f97a192ad8c89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return evaluator(s) of any internal numeric expressions.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#af3056926ad0964c2b80f97a192ad8c89">More...</a><br /></td></tr>
<tr class="separator:af3056926ad0964c2b80f97a192ad8c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ba5441991ba928333e024d28a0c5d4"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a56ba5441991ba928333e024d28a0c5d4">_create_calc_obj</a> (self, param)</td></tr>
<tr class="memdesc:a56ba5441991ba928333e024d28a0c5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a cache/calculator for a specific parameter value.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a56ba5441991ba928333e024d28a0c5d4">More...</a><br /></td></tr>
<tr class="separator:a56ba5441991ba928333e024d28a0c5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6ee3888e09c401cdec36c825977c33"><td class="memItemLeft" align="right" valign="top"><a id="a0c6ee3888e09c401cdec36c825977c33"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a0c6ee3888e09c401cdec36c825977c33">_integrate_tev_divergence_unity_time</a> (self, curves, tev_args, n)</td></tr>
<tr class="memdesc:a0c6ee3888e09c401cdec36c825977c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a38053ffe9e087b496b35cdbbc6327d8b" title="Integrate the divergence of the time evolution vector (TEV).">integrate_tev_divergence()</a> for unity time component. <br /></td></tr>
<tr class="separator:a0c6ee3888e09c401cdec36c825977c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1095dc03d2653673d46009d7beb02163"><td class="memItemLeft" align="right" valign="top"><a id="a1095dc03d2653673d46009d7beb02163"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a1095dc03d2653673d46009d7beb02163">_integrate_tev_divergence_unity_b</a> (self, curves, tev_args, n)</td></tr>
<tr class="memdesc:a1095dc03d2653673d46009d7beb02163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a38053ffe9e087b496b35cdbbc6327d8b" title="Integrate the divergence of the time evolution vector (TEV).">integrate_tev_divergence()</a> for unity <code>b</code> coefficient. <br /></td></tr>
<tr class="separator:a1095dc03d2653673d46009d7beb02163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870663199b128cdaa750a4eb54ea86c1"><td class="memItemLeft" align="right" valign="top"><a id="a870663199b128cdaa750a4eb54ea86c1"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a870663199b128cdaa750a4eb54ea86c1">_dt_normals</a> (self, pts, curves, steps, use_tev, tevs, unload, full_output)</td></tr>
<tr class="memdesc:a870663199b128cdaa750a4eb54ea86c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a45c589ad969baa9f956e0eb2491653ba" title="Compute the time derivative of the MOTS normal within the slice.">dt_normals()</a>. <br /></td></tr>
<tr class="separator:a870663199b128cdaa750a4eb54ea86c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbded0fcab5b47058c77890ad26922fb"><td class="memItemLeft" align="right" valign="top"><a id="adbded0fcab5b47058c77890ad26922fb"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adbded0fcab5b47058c77890ad26922fb">_surface_gravity</a> (self, pts, curves, steps, wrt, tevs)</td></tr>
<tr class="memdesc:adbded0fcab5b47058c77890ad26922fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#adf576f119b60fc790caa871324a88dca" title="Compute a (slicing dependent) surface gravity.">surface_gravity()</a>. <br /></td></tr>
<tr class="separator:adbded0fcab5b47058c77890ad26922fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d1d395d70dec7a17863e4137eafd"><td class="memItemLeft" align="right" valign="top"><a id="a25c2d1d395d70dec7a17863e4137eafd"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>_compute_dtau_c</b> (self, curves, steps, tevs)</td></tr>
<tr class="separator:a25c2d1d395d70dec7a17863e4137eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2458f51a1e26dd4fb842d4bd92c1e5b"><td class="memItemLeft" align="right" valign="top"><a id="ad2458f51a1e26dd4fb842d4bd92c1e5b"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad2458f51a1e26dd4fb842d4bd92c1e5b">_xi_vector</a> (self, pts, curves, steps, r_hat, full_output, get_tevs, tevs)</td></tr>
<tr class="memdesc:ad2458f51a1e26dd4fb842d4bd92c1e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a5f5c782f8ffdf59548daf2e6d39666e8" title="Compute the xi vector.">xi_vector()</a>. <br /></td></tr>
<tr class="separator:ad2458f51a1e26dd4fb842d4bd92c1e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc806692c9515801090061681a04017e"><td class="memItemLeft" align="right" valign="top"><a id="acc806692c9515801090061681a04017e"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>_cached_stability_op</b> (self, func, pts, m, cache=None, **kw)</td></tr>
<tr class="separator:acc806692c9515801090061681a04017e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae140ab19abd6ce8f0f3448a685113abf"><td class="memItemLeft" align="right" valign="top"><a id="ae140ab19abd6ce8f0f3448a685113abf"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ae140ab19abd6ce8f0f3448a685113abf">_stability_eigenvalue_equation_timesym</a> (self, pts, slice_normal, transform_torsion)</td></tr>
<tr class="memdesc:ae140ab19abd6ce8f0f3448a685113abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue equation evaluator for time-symmetric case. <br /></td></tr>
<tr class="separator:ae140ab19abd6ce8f0f3448a685113abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7e3196d9adc51db55bba3688db8697"><td class="memItemLeft" align="right" valign="top"><a id="a6e7e3196d9adc51db55bba3688db8697"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6e7e3196d9adc51db55bba3688db8697">_stability_eigenvalue_equation_general</a> (self, pts, slice_normal, transform_torsion)</td></tr>
<tr class="memdesc:a6e7e3196d9adc51db55bba3688db8697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eigenvalue equation evaluator for the general case. <br /></td></tr>
<tr class="separator:a6e7e3196d9adc51db55bba3688db8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cfdebdef5897c08023f7ccd43db3be"><td class="memItemLeft" align="right" valign="top"><a id="a14cfdebdef5897c08023f7ccd43db3be"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><b>_cache_vectorized</b> (cls, func, boundary_tol=0.0, boundary_val=0.0, domain=(0.0, np.pi))</td></tr>
<tr class="separator:a14cfdebdef5897c08023f7ccd43db3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73205e27f89026e04b1efa80b0e6288b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a73205e27f89026e04b1efa80b0e6288b">_expand_into_SWSPH</a> (self, func, spinweight, lmax, min_lmax, max_lmax, coeff_threshold, compress, zeta=None, full_output=False)</td></tr>
<tr class="memdesc:a73205e27f89026e04b1efa80b0e6288b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand some quantity into SWSPH.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a73205e27f89026e04b1efa80b0e6288b">More...</a><br /></td></tr>
<tr class="separator:a73205e27f89026e04b1efa80b0e6288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729cfd2b525e29c406af01b6e413cd94"><td class="memItemLeft" align="right" valign="top"><a id="a729cfd2b525e29c406af01b6e413cd94"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a729cfd2b525e29c406af01b6e413cd94">_locate_self_intersection</a> (self, neck, xtol)</td></tr>
<tr class="memdesc:a729cfd2b525e29c406af01b6e413cd94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a6ca1e6cd728f86908a070a06765d59ae" title="Locate a loop in the MOTS around its neck.">locate_self_intersection()</a>. <br /></td></tr>
<tr class="separator:a729cfd2b525e29c406af01b6e413cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aeee148d074b5656912a95a1515100102"><td class="memItemLeft" align="right" valign="top"><a id="aeee148d074b5656912a95a1515100102"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>_calc</b></td></tr>
<tr class="separator:aeee148d074b5656912a95a1515100102"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html">BaseCurve</a></td></tr>
<tr class="memitem:a2e81a373d92565a3a8dbcd724026506f inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2e81a373d92565a3a8dbcd724026506f">plot_curves</a> (*curves, cmap=None, last_callback=None, **kw)</td></tr>
<tr class="memdesc:a2e81a373d92565a3a8dbcd724026506f inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static method for plotting multiple curves in the same plot.  <a href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a2e81a373d92565a3a8dbcd724026506f">More...</a><br /></td></tr>
<tr class="separator:a2e81a373d92565a3a8dbcd724026506f inherit pub_static_methods_classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for curves that can calculate their expansion. </p>
<p>This base class implements the functionality common to all concrete curve classes that are aware of the geometry they are living in. These take the Riemannian 3-metric and extrinsic curvature of the slice to compute quantities such as the expansion.</p>
<p>Most of the actual calculation of these quantities is done in so called "calculation" objects that exist for a specific point on the curve and cache and reuse interim results.</p>
<p>In addition to the abstract functions in <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html" title="Base class for curves in the x-z-plane.">basecurve.BaseCurve</a> not implemented here, subclasses need to implement the following additional functions:</p><ul>
<li><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#aebf6261b742ae694c16790726a8c77c5" title="Create an independent copy of this curve.">copy()</a> to create an independent copy of the curve</li>
<li><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a56ba5441991ba928333e024d28a0c5d4" title="Create a cache/calculator for a specific parameter value.">_create_calc_obj()</a> to create the cache/calculator object </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac0c98b291b96568621e2fb6a792f9f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c98b291b96568621e2fb6a792f9f9c">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def __init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>''</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base class constructor taking a horizon function and metric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">h</td><td>(<a class="el" href="classmotsfinder_1_1exprs_1_1numexpr_1_1NumericExpression.html" title="Parent class for numeric expressions.">exprs.numexpr.NumericExpression</a>) The "horizon function" defining this curve. How this function is interpreted is up to the subclass and its calculator object. </td></tr>
    <tr><td class="paramname">metric</td><td>The Riemannian 3-metric defining the geometry of the surrounding space. </td></tr>
    <tr><td class="paramname">name</td><td>Name of this curve. This may be used when printing information about this curve or as label in plots. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a56ba5441991ba928333e024d28a0c5d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ba5441991ba928333e024d28a0c5d4">&#9670;&nbsp;</a></span>_create_calc_obj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _create_calc_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a cache/calculator for a specific parameter value. </p>
<p>This is only called when a new calculator object needs to be constructed (i.e. this is a calculator factory). Subclasses should create the respective calculator type they need. </p>

<p>Reimplemented in <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1starshapedcurve_1_1StarShapedCurve.html#a56ba5441991ba928333e024d28a0c5d4">StarShapedCurve</a>, and <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1refparamcurve_1_1RefParamCurve.html#a56ba5441991ba928333e024d28a0c5d4">RefParamCurve</a>.</p>

</div>
</div>
<a id="af3056926ad0964c2b80f97a192ad8c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3056926ad0964c2b80f97a192ad8c89">&#9670;&nbsp;</a></span>_create_evaluators()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _create_evaluators </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return evaluator(s) of any internal numeric expressions. </p>
<p>Subclasses may have multiple expressions representing the curve. Since it is inefficient to repeatedly create evaluators when the underlying expressions don't change, the BaseCurve class can handle freezing (i.e. reusing) evaluators. Any evaluators returned from this function will participate in this mechanism. </p>

<p>Reimplemented from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#af3056926ad0964c2b80f97a192ad8c89">BaseCurve</a>.</p>

</div>
</div>
<a id="a73205e27f89026e04b1efa80b0e6288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73205e27f89026e04b1efa80b0e6288b">&#9670;&nbsp;</a></span>_expand_into_SWSPH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def _expand_into_SWSPH </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>spinweight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_lmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coeff_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeta</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand some quantity into SWSPH. </p>
<p>The <code>func</code> has to be vectorized, i.e. take a sequence of parameter values and return a sequence of complex values of the same length. </p>

</div>
</div>
<a id="a3e0047689b5918a7d26f5698a176615d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0047689b5918a7d26f5698a176615d">&#9670;&nbsp;</a></span>area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def area </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>(0,&#160;np.pi)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the area of the surface represented by this curve. </p>
<p>Note that no warning will be generated in case the integral does not converge properly. To obtain information about such warnings, either set <code>disp=True</code> to raise an error in these cases, or use <code>full_output=True</code> and check if the last returned element is <code>None</code> (signaling no problem was found).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return a 4-tuple containing the computed area, an estimated error, the <code>infodict</code> result of <code>scipy.integrate.quad</code> and any generated warning message. This fourth element will be <code>None</code> in case no warning occurred. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">disp</td><td>If <code>Ture</code>, raise any warnings generated during integration as an <code><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1IntegrationError.html" title="Raised for non-converging integrals or if accuracy cannot be reached.">IntegrationError</a></code>. </td></tr>
    <tr><td class="paramname">domain</td><td>Parameter range to integrate over. Default is the full surface, i.e. <code>(0, pi)</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments are passed to <code>scipy.integrate.quad</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed area. See also <code>full_output</code> above.</dd></dl>
<p><b>Notes</b> </p>
<p>The area of the surface \(\sigma\) is defined as </p><p class="formulaDsp">
\[ A = \int_\sigma \sqrt{\det q}\ d^2x, \]
</p>
<p> where </p><p class="formulaDsp">
\[ q = \Pi_\sigma g = g\big|_\sigma - \underline{\nu} \otimes \underline{\nu}, \qquad q_{ab} = g_{ab} - \nu_a \nu_b \]
</p>
<p> is the induced metric on \(\sigma\) (compare equation (2) in [1]). Here, \(\nu\) is the outward pointing normal of \(\sigma\) and \(\underline{\nu} = g(\nu,\,\cdot\,)\).</p>
<p><b>References</b> </p>
<p>[1] Gundlach, Carsten. "Pseudospectral apparent horizon finders: An
     efficient new algorithm." Physical Review D 57.2 (1998): 863. </p>

</div>
</div>
<a id="aec7eb8ad525191669e3faa100f023277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7eb8ad525191669e3faa100f023277">&#9670;&nbsp;</a></span>average_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def average_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the average expansion across the surface. </p>
<p>This computes the average expansion </p><p class="formulaDsp">
\[ \overline\Theta = \frac{1}{A} \int \Theta \sqrt{q}\ d^2x. \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ingoing</td><td>Whether to average over the ingoing (<code>True</code>) or outgoing (<code>False</code>) expansion. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">area</td><td>Optionally re-use an already computed area value. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the average expansion and the estimated error. Otherwise return just the average expansion. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments are passed to <code>scipy.integrate.quad</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6bb06da2987923a6c0f1efe6b6906d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb06da2987923a6c0f1efe6b6906d00">&#9670;&nbsp;</a></span>collect_close_in_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def collect_close_in_time </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a list of curves close (in time) to this one. </p>
<p>Given a list of <code>curves</code>, which may or may not contain the current one (<code>self</code>), we collect at most <code>steps</code> curves before and <code>steps</code> curves after this one. The returned list will contain the current curve. </p>

</div>
</div>
<a id="a9f22b1b99aaf1965a8acee1648a16499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f22b1b99aaf1965a8acee1648a16499">&#9670;&nbsp;</a></span>compute_zeta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def compute_zeta </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>det_q_function</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerically compute the invariant angle zeta. </p>
<p>For a "round" 2-sphere we have \(\zeta = \cos\theta\). In general, it is defined in [1] via </p><p class="formulaDsp">
\[ \partial_A\zeta = \frac{1}{R^2} \epsilon_{BA} \phi^B, \qquad \int_{\mathcal{S}} \zeta\, d^2V = 0 \,, \]
</p>
<p> where \(\epsilon_{AB}\) is the volume 2-form on the surface \(\mathcal{S}\) represented by this curve. Since our coordinates \((\lambda, \varphi)\) are already adapted to the axisymmetry, this simplifies to an ODE for \(\zeta\), namely </p><p class="formulaDsp">
\[ \partial_\lambda \zeta = - \frac{\sqrt{\det q}}{R^2} \,, \]
</p>
<p> where \(R\) is the areal radius of \(\mathcal{S}\).</p>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classmotsfinder_1_1exprs_1_1numexpr_1_1NumericExpression.html" title="Parent class for numeric expressions.">exprs.numexpr.NumericExpression</a> representing \(\zeta\).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Spectral resolution of the numerical solution. The default is to take the curve's current resolution and at least <code>100</code>. </td></tr>
    <tr><td class="paramname">det_q_function</td><td>Optional callable evaluating \(\det q\). Can be used to supply a cached version of <code>det_q</code>. If not supplied, uses an uncached version.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Ashtekar, Abhay, et al. "Multipole moments of isolated horizons." Classical and Quantum Gravity 21.11 (2004): 2549. </p>

</div>
</div>
<a id="a45c589ad969baa9f956e0eb2491653ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c589ad969baa9f956e0eb2491653ba">&#9670;&nbsp;</a></span>dt_normals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def dt_normals </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>use_tev</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tevs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unload</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the time derivative of the MOTS normal within the slice. </p>
<p>The outward pointing normal to the MOTS within the spatial slice is traced along the MOTT section (defined by the <code>curves</code>) and its derivative w.r.t. coordinate time is computed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>List of points (in terms of pi-normalized proper length) to compute the derivative of the normal at. It is much more efficient to compute multiple normals at once instead of calling this method multiple times. This holds especially when the metric is given as data on a grid loaded from a file and not available in memory. </td></tr>
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">use_tev</td><td>Which <code>tau</code> coordinate to use (see below). If <code>True</code>, use the integral curve of the time evolution vector (i.e. with tangents orthogonal to the MOTSs). This is much more expensive. If <code>False</code>, just use a curve constructed from taking the same fraction of the proper length of the curves on each curve. The two variants should produce the same results (within numerical errors). If the time evolution vectors are needed afterwords, it makes sense to set <code>use_tev=True</code> and <code>full_output=True</code> to get the vectors together with the time computed derivative. </td></tr>
    <tr><td class="paramname">tevs</td><td>Optional list of time evolution vector objects. Only used in case <code>use_tev==True</code>. Each vector in this sequence has to correspond to the respective element in <code>pts</code>. </td></tr>
    <tr><td class="paramname">unload</td><td>Whether to free memory by unloading slice data from all MOTSs not in the same slice as the current MOTS. Default is <code>True</code>. If <code>False</code>, slice data of up to <code>2*steps + 1</code> will reside simultaneously in memory and not be removed after calling this method. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to also return the tangent vectors to the MOTT that were used to compute the time derivative of the normal. In case <code>use_tev=True</code>, this will be a list of <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1TimeVectorData.html" title="MOTT time evolution vector.">TimeVectorData</a> objects, while for <code>use_tev=False</code>, it will be a list of <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1SignatureQuantities.html" title="Class storing quantities allowing visualization of signature.">SignatureQuantities</a> objects.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>This computes \(\partial_t \nu^i\), where \(\nu^i\) are the spatial components of the normal vector in the slice. It does <b>not</b> simply compute how the normal changes along the MOTT. If we define a "time" parameter along the MOTT via \(\tau(p) = t\) iff \(p\in\mathcal{S}_t\subset\Sigma_t\), then we can choose some coordinates on the MOTSs and follow the lines of varying \(\tau\). There are two options to do that: One is to use the fraction of each curve's proper length as curve parameter and the other is to choose the parameter such that the \(\tau\) coordinate produces a vector field \(\partial_\tau\) that is orthogonal to the MOTSs. The latter is used if <code>use_tev=True</code>. Note that </p><p class="formulaDsp">
\[ \partial_\tau = \frac{\partial x^\mu}{\partial\tau} \partial_\mu = \partial_t + \dot x^i \partial_i \,, \]
</p>
<p> where the dot is defined as derivative w.r.t. \(\tau\). As a result, we compute the derivative of the normal w.r.t. time via </p><p class="formulaDsp">
\[ \partial_t \nu^i = \dot\nu^i - \dot x^j \partial_j \nu^i \,. \]
</p>
 
</div>
</div>
<a id="a59175e6bd575240b590d3ec3d0549ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59175e6bd575240b590d3ec3d0549ffa">&#9670;&nbsp;</a></span>euler_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def euler_char </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em> = <code>np.pi</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Euler characteristic of the surface. </p>
<p>This assumes the curve to represent a closed (compact) smooth surface without boundary. As such, we get by the Gauss-Bonnet theorem </p><p class="formulaDsp">
\[ 2\pi\chi(\mathcal{S}) = \frac{1}{2} \int_\mathcal{S} \mathcal{R}\ dA, \]
</p>
<p> where \(\chi\) is the Euler characteristic of the surface \(\mathcal{S}\) which is represented by this curve and \(\mathcal{R}\) its Ricci (scalar) curvature.</p>
<p>In axisymmetry and corresponding coordinates, we can carry out the integral over the angle \(\phi\), which gives \(2\pi\) and end up with </p><p class="formulaDsp">
\[ \chi(\mathcal{S}) = \frac{1}{2} \int_0^\pi \mathcal{R}(\lambda)\sqrt{q}\ d\lambda, \]
</p>
<p> where \(\sqrt{q}\) is the square root of the determinant of the induced metric <code>q</code>.</p>
<p>From the Euler characteristic, you can compute the genus <code>G</code> of the surface via \(G = -\chi/2 + 1\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a,b</td><td>Curve parameters between which to integrate. Defaults are <code>0</code> and <code>pi</code>, respectively. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to return information about the integration in addition to the value. If <code>True</code>, return a tuple of <code>chi, chi_err, info, warning</code>. Otherwise (default), return just <code>chi</code>. If <code>warning</code> is not <code>None</code>, the integral did not converge as expected. </td></tr>
    <tr><td class="paramname">disp</td><td>Whether to raise an error in case the integral did not converge as expected. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to <code>scipy.integrate.quad()</code>. Use these to set e.g. <code>epsrel</code> to the desired tolerance. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ab6ec2db3a3392db0e778878c44668a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab6ec2db3a3392db0e778878c44668a">&#9670;&nbsp;</a></span>expand_shear_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def expand_shear_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmax</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeta</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_lmax</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_lmax</em> = <code>4096</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coeff_threshold</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compress</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the shear scalar into spin 2 weighted spherical harmonics. </p>
<p>This uses the <code>spinsfast</code> module to expand the shear scalar (computed using <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa641f4b2dd3163ce333e948970884a7c" title="Compute the complex shear scalar.">shear_scalar()</a>) into spherical harmonics of spin weight 2. To do this, the shear scalar is constructed as a function of \(\theta\), where \(\cos\theta=\zeta\) is the invariant angle defining a geometrically invariant parameterization of axisymmetric MOTSs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lmax</td><td>Largest <code>ell</code> value in the expansion into \({}_2Y_{\ell m}\). The default, <code>"auto"</code> will start with a low resolution and successively double this resolution until a "knee" is detected in the expansion coefficients. Such a knee indicates convergence and increasing the resolution further does not increase accuracy of results. </td></tr>
    <tr><td class="paramname">zeta</td><td>Expression evaluating the invariant angle as function of the intrinsic curve parameter \(\lambda\). If not given, this function is numerically computed using <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a9f22b1b99aaf1965a8acee1648a16499" title="Numerically compute the invariant angle zeta.">compute_zeta()</a>. </td></tr>
    <tr><td class="paramname">min_lmax,max_lmax</td><td>If <code>lmax="auto"</code>, start expanding with <code>lmax=min_lmax</code>. If no "knee" is detected in the resulting coefficients, the resolution is doubled until a knee is detected or we have reached <code>max_lmax</code>. </td></tr>
    <tr><td class="paramname">coeff_threshold</td><td>If the final few coefficients are larger than <code>coeff_threshold</code> times the largest coefficient, then do not try to detect a knee in the coefficients but immediately increase the resolution. By default, knee detection is always run. </td></tr>
    <tr><td class="paramname">hat</td><td>If <code>True</code>, expand \(\hat\sigma\) instead of \(\sigma\). Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">curves,steps</td><td>In case <code>hat==True</code>, the curves and steps to do time interpolation with need to be supplied. See <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa0967b92e27f90bef5e071afe84f9752" title="Expand the xi vector into spin weighted spherical harmonics.">expand_xi_scalar()</a> for their meaning. </td></tr>
    <tr><td class="paramname">compress</td><td>Since the shear scalar is purely real for axisymmetric MOTSs, the only non-zero coefficients in the expansion will be the ones with <code>m=0</code>. Setting <code>compress=True</code> (default) will extract this one row of possibly non-vanishing coefficients and return it. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the coefficients, the (complex) shear scalar values at the grid points in \(\theta=\arccos\zeta\) and the grid points themselves. Otherwise (default), return just the coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0967b92e27f90bef5e071afe84f9752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0967b92e27f90bef5e071afe84f9752">&#9670;&nbsp;</a></span>expand_xi_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def expand_xi_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lmax</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeta</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_lmax</em> = <code>64</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_lmax</em> = <code>512</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>coeff_threshold</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compress</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hat</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r_hat</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the xi vector into spin weighted spherical harmonics. </p>
<p>We expand the quantity </p><p class="formulaDsp">
\[ \xi_{(\ell)} := \overline{m}^A \xi_A \]
</p>
<p> into spin weighted spherical harmonics of spin weight -1. The complex null tetrad \((\ell, k, m, \overline{m})\) is constructed using \(m = \frac{1}{\sqrt{2}} (e_1 + i e_2)\), where \(e_1 = \frac{\partial_\lambda}{\sqrt{q_{\lambda\lambda}}}\) and \(e_2 = \frac{\partial_\varphi}{\sqrt{q_{\varphi\varphi}}}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">lmax</td><td>Largest <code>ell</code> value in the expansion into \({}_{-1}Y_{\ell m}\). Default is <code>"auto"</code>, which tries to find a maximum between <code>min_lmax</code> and <code>max_lmax</code> such that the coefficients fall off sufficiently up to <code>lmax</code>. </td></tr>
    <tr><td class="paramname">min_lmax,max_lmax</td><td>If <code>lmax="auto"</code>, start expanding with <code>lmax=min_lmax</code>. If no "knee" is detected in the resulting coefficients, the resolution is doubled until a knee is detected or we have reached <code>max_lmax</code>. </td></tr>
    <tr><td class="paramname">coeff_threshold</td><td>If the final few coefficients are larger than <code>coeff_threshold</code> times the largest coefficient, then do not try to detect a knee in the coefficients but immediately increase the resolution. By default, knee detection is always run. </td></tr>
    <tr><td class="paramname">compress</td><td>Since the scalar is purely real for axisymmetric MOTSs, the only non-zero coefficients in the expansion will be the ones with <code>m=0</code>. Setting <code>compress=True</code> (default) will extract this one row of possibly non-vanishing coefficients and return it. </td></tr>
    <tr><td class="paramname">hat</td><td>Expand \(\hat\xi\) instead of \(\xi\). Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">r_hat</td><td>Use the normalized evolution vector to construct \(\xi^\mu\). Default is <code>True</code>. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the coefficients, the (complex) shear scalar values at the grid points in \(\theta=\arccos\zeta\) and the grid points themselves. Otherwise (default), return just the coefficients. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d946c32710bf1ff05efb654bee672fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d946c32710bf1ff05efb654bee672fc">&#9670;&nbsp;</a></span>expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hdiff</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the expansion at one parameter value. </p>
<p>This function can also compute derivatives of the expansion w.r.t. the horizon function <code>h</code> or one of its derivatives.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameter (i.e. \(\lambda\) value) specifying the point on the curve at which to compute the expansion of the surface. </td></tr>
    <tr><td class="paramname">hdiff</td><td>If given, compute the functional derivative of the expansion w.r.t. a derivative of the horizon function. For example, if <code>hdiff==0</code>, compute \(\partial_h\Theta\) and for <code>hdiff==1</code>, compute \(\partial_{h&#39;}\Theta\). If <code>None</code> (default), compute the expansion. </td></tr>
    <tr><td class="paramname">ingoing</td><td>By default, the outgoing null geodesics' expansion is returned. If <code>ingoing==True</code>, the expansion of the ingoing null geodesics is computed instead. Functional derivatives of the ingoing expansion are not currently implemented. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19bd95251b6fa5eba926e9007588f961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bd95251b6fa5eba926e9007588f961">&#9670;&nbsp;</a></span>extremality_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extremality_parameter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the extremality parameter. </p>
<p>This computes the extremality parameter given in [1] (the correct formula can be found as eq. (14) in [2]) as </p><p class="formulaDsp">
\[ e = 1 - \frac{1}{8\pi} \int_{\mathcal{S}} \left(\frac{v_\bot + 1}{v_\bot - 1}\right) \Vert \sqrt{2}\sigma_{(\ell)} \Vert^2\ d^2V = 1 - \frac{1}{2} \int_0^\pi \sqrt{q} \left(\frac{v_\bot + 1}{v_\bot - 1}\right) \Vert \sigma_{(\ell)} \Vert^2\ d\lambda \,, \]
</p>
<p> where \(\lambda\) is our parameter along the curve and \(v_\bot\) is defined via </p><p class="formulaDsp">
\[ V^\mu = \alpha\;( n^\mu + v_\bot \nu^\mu ) \,. \]
</p>
<p> Here \(\alpha\) is the lapse function, \(n^\mu\) the future pointing timelike normal to the spatial slice, \(\nu^\mu\) the normal of the MOTS within the slice, and \(V^\mu\) the time evolution vector (tangent to the MOTT and normal to the MOTS).</p>
<p>The factor of \(\sqrt{2}\) results from a different scaling convention for the null normals used to define the shear.</p>
<p><b>References</b> </p>
<p>[1] Booth, Ivan, and Stephen Fairhurst. "Extremality conditions for
     isolated and dynamical horizons." Physical review D 77.8 (2008): 084005.</p>
<p>[2] Booth, Ivan. "Two physical characteristics of numerical apparent
     horizons." Canadian Journal of Physics 86.4 (2008): 669-673. </p>

</div>
</div>
<a id="a49ef465ecbfd8d1a0f5413bda0a8f325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ef465ecbfd8d1a0f5413bda0a8f325">&#9670;&nbsp;</a></span>extrinsic_surface_curvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def extrinsic_surface_curvature </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>trace</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>square</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the extrinsic curvature tensor of the surface. </p>
<p>This computes the components </p><p class="formulaDsp">
\[ k_{AB} = -\nabla_A \nu_B, \qquad A,B = \lambda,\varphi \]
</p>
<p> where \(\lambda,\varphi\) are coordinates on the surface represented by this curve, \(\nu\) is the outward pointing normal of the surface in the slice, and \(\nabla\) is the spacetime covariant derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Parameter (i.e. \(\lambda\) value) specifying the point on the curve at which to compute the extrinsic curvature of the surface. </td></tr>
    <tr><td class="paramname">trace</td><td>If <code>True</code>, returns the trace of the extrinsic curvature. Default is <code>False</code>. May not be used together with <code>square</code>. </td></tr>
    <tr><td class="paramname">square</td><td>If <code>True</code>, returns the square \(k_{AB} k^{AB}\). Default is <code>False</code>. May not be used together with <code>trace</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A NumPy 2x2 array containing the components of <code>k_AB</code>. If either <code>trace</code> or <code>square</code> is <code>True</code>, returns a float. </dd></dl>

</div>
</div>
<a id="ad4da563d8d0d36fb22f95b39c26a5a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da563d8d0d36fb22f95b39c26a5a4a">&#9670;&nbsp;</a></span>find_neck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def find_neck </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>algo</em> = <code>'coord'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to locate a 'neck' of this curve. </p>
<p>The neck can be defined by various means. One working definition is to take a locally minimal proper circumference of the surface defined by this curve by rotating a point around the z-axis. The two poles lying on the z-axis are excluded, of course.</p>
<p>This function implements the following algorithm to find the neck: Starting from the north-pole (<code>param=0</code>), we first find the point where the quantity (e.g. circumference) has a local <em>maximum</em>. From there, we do small steps forward to bracket the first local minimum, which is then located precisely.</p>
<dl class="section return"><dt>Returns</dt><dd>A tuple of <code>(param, value)</code>, where <code>param</code> is the curve parameter of the neck and <code>value</code> the value of the quantity used to define the neck.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algo</td><td>The algorithm/definition of the neck. Understood values currently are <code>'coord'</code> (neck has minimal x-coordinate value), <code>'circumference'</code> (neck has minimal proper circumference), <code>'proper_x_dist'</code> (neck has minimal proper distance to z-axis, measured along a straight coordinate line in x-direction). Default is <code>'coord'</code>. </td></tr>
    <tr><td class="paramname">xtol</td><td>Tolerance in curve parameter value for the search. Default is <code>1e-8</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are used in case of <code>algo==proper_x_dist</code> and are supplied to the <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a3301e4a4e9697771e4d19b9b03b87db1" title="Return the proper length of a coordinate line from the curve to the z-axis.">x_distance()</a> method calls. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afea218e8051c9c6b433fc008c252d9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea218e8051c9c6b433fc008c252d9b1">&#9670;&nbsp;</a></span>get_area_integrand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_area_integrand </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a callable evaluating the sqrt(det(q)), i.e. </p>
<p>the area element. </p>

</div>
</div>
<a id="a466e295d1bb8750fa1df2b746a0524a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a466e295d1bb8750fa1df2b746a0524a4">&#9670;&nbsp;</a></span>get_calc_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_calc_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create or reuse a calculator object for a given parameter value. </p>
<p>In case the current cache/calculator already belongs to the given parameter value, it is reused and returned instead of a new one being created each time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>(float) Parameter of the curve for which to construct the cache/calculator object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d5f7aa93ad9cf41e64aa493710e7ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d5f7aa93ad9cf41e64aa493710e7ac7">&#9670;&nbsp;</a></span>get_det_q_func()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_det_q_func </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cached</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a function to evaluate det(q). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cached</td><td>If <code>True</code>, cache every evaluation of the returned callable. Default is <code>False</code>. Note that a new cache is created for each created function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12e142fbf691a6c614554fea33624c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e142fbf691a6c614554fea33624c1e">&#9670;&nbsp;</a></span>get_distance_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def get_distance_function </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Ns</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xatol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>mp_finish</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dps</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>minima_to_check</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a callable computing the distance between this and another curve. </p>
<p>The computed distance is the coordinate distance between a point of this curve to the closest point on another curve.</p>
<p>The returned callable will take one mandatory argument: the parameter at which to evaluate the current curve. The resulting point is then taken and the given <code>other_curve</code> searched for the point closest to that point. The distance to this function is then returned.</p>
<p>A second optional parameter of the returned function determines whether only the distance (<code>False</code>, default) or the distance and the parameter on the other curve is returned (if <code>True</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>The curve to which the distance should be computed in the returned function. </td></tr>
    <tr><td class="paramname">Ns</td><td>Number of points to take on <code>other_curve</code> for finding the initial guess for the minimum search. Default is to take the resolution of <code>other_curve</code>. </td></tr>
    <tr><td class="paramname">xatol</td><td>In case <code>mp_finish==False</code>, use this tolerance in the SciPy <code>minimize_scalar()</code> call. Default is <code>1e-12</code>. </td></tr>
    <tr><td class="paramname">mp_finish</td><td>If <code>True</code> (default), evaluate some terms using arbitrary precision mpmath arithmetics and find the minimum with a robust but slow golden section search. This allows finding minima <em>much</em> closer to the actual minimum. In general, with <code>mp_finish==False</code>, we are usually limited by approximately <code>1e-8</code>, while with <code>mp_finish==True</code>, we can get to around <code>1e-15</code> (e.g. if <code>other_curve</code> is this curve). </td></tr>
    <tr><td class="paramname">dps</td><td>Decimal places for mpmath computations. Default is <code>50</code>. </td></tr>
    <tr><td class="paramname">minima_to_check</td><td>Number of local minima to check for a global minimum. Default is <code>1</code>, which means we search just around the smallest distance from the initial grid of points. Higher values may help locate the correct minimum especially in cases of self-intersecting curves. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af121af077346547f69460bdda05c371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af121af077346547f69460bdda05c371d">&#9670;&nbsp;</a></span>horizon_function_changed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def horizon_function_changed </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Notify this curve that the underlying horizon function has changed. </p>
<p>Since we cache the calculation object for efficiency, changes to the horizon function will not affect results if evaluating the expansion at the exact same point. This method invalidates any cached evaluators and calculation objects to produce newly computed results in the next computation call. </p>

</div>
</div>
<a id="a321e36a1dbf23d671dda1f83832d8d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321e36a1dbf23d671dda1f83832d8d07">&#9670;&nbsp;</a></span>horizon_radius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def horizon_radius </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the horizon radius. </p>
<p>The horizon radius is defined as (cf. [1]) </p><p class="formulaDsp">
\[ R := \sqrt{A/4\pi}, \]
</p>
<p> where <code>A</code> is the horizon's area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Optional area for which to compute the horizon radius. By default, the area of the axisymmetric surface represented by this curve is computed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Ashtekar, Abhay, and Badri Krishnan. "Isolated and dynamical
     horizons and their applications." Living Reviews in Relativity 7.1 (2004): 10. </p>

</div>
</div>
<a id="af77698b57e38c511c95a15de2c9165d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af77698b57e38c511c95a15de2c9165d3">&#9670;&nbsp;</a></span>inner_x_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inner_x_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>'zero'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the x-distance of two points of this and another curve. </p>
<p>Similar to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#aa9b7e93bceac5de451c3941cb4d38dad" title="Compute the z-distance of two points of this and another curve.">inner_z_distance()</a>, this method does <em>not</em> compute how close two surfaces approach each other (which would return zero for intersecting surfaces). Instead, it computes one possible measure for how close the two surfaces are from being identical, i.e. it computes the distance of two corresponding points.</p>
<p>In this function, we measure the distance on a straight coordinate line in x-direction connecting either two points on the x-axis itself (i.e. for <code>x==0</code>) or on a line in x-direction starting at the point of largest coordinate distance to the z-axis (i.e. for largest x value).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to which to compute the distance. </td></tr>
    <tr><td class="paramname">where</td><td>One of <code>'zero', 'max'</code>. Default is <code>'zero'</code>. Where to take the points on both surfaces. Here, <code>'max'</code> means to take the point of largest distance to the z-axis of this curve. Hence, the result will not be symmetric w.r.t. switching the two curves. </td></tr>
    <tr><td class="paramname">metric</td><td>Which metric to use for integrating along the connecting line of the two points. By default, takes the current metric stored in this curve. Explicitely specify <code>None</code> to get the coordinate distance. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7" title="Compute the length of this curve w.r.t. a given metric.">arc_length_using_metric()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9b7e93bceac5de451c3941cb4d38dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b7e93bceac5de451c3941cb4d38dad">&#9670;&nbsp;</a></span>inner_z_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def inner_z_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>where</em> = <code>'top'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the z-distance of two points of this and another curve. </p>
<p>In contrast to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad2053028a7c722407c3e0156724d8969" title="Compute the z-distance to another curve or the origin.">z_distance()</a>, this method does <em>not</em> compute how close two surfaces approach each other. Instead, it computes one possible measure for how close the two surfaces are from being identical, i.e. it computes the distance of two corresponding points.</p>
<p>In this function, we take either the top or bottom points of both surfaces on the z-axis and compute their distance. The distance will have negative sign if this curve is in the <em>interior</em> of the <code>other_curve</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to which to compute the distance. </td></tr>
    <tr><td class="paramname">where</td><td>One of <code>'top', 'bottom'</code>. Default is <code>'top'</code>. Where to take the points on both surfaces. </td></tr>
    <tr><td class="paramname">metric</td><td>Which metric to use for integrating along the connecting line of the two points. By default, takes the current metric stored in this curve. Explicitely specify <code>None</code> to get the coordinate distance. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the computed result and an estimation of the error. Otherwise (default), just return the result. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a0bf941a618b577b673e4d897bca584d7" title="Compute the length of this curve w.r.t. a given metric.">arc_length_using_metric()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38053ffe9e087b496b35cdbbc6327d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38053ffe9e087b496b35cdbbc6327d8b">&#9670;&nbsp;</a></span>integrate_tev_divergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def integrate_tev_divergence </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tev_args</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>unity_b</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integrate the divergence of the time evolution vector (TEV). </p>
<p>This computes the integral of the divergence of the time evolution vector (TEV) over the MOTS. We compute the integrand via </p><p class="formulaDsp">
\[ q^{\mu\nu} \nabla_\mu V_\nu = q^{\mu\nu} \nabla_\mu (b \ell_\nu + c k_\nu) = c q^{\mu\nu} \nabla_\mu k_\nu = c \Theta_{(k)} \,. \]
</p>
<p>Note that the ingoing expansion is computed with the convention \(\ell^\mu k_\mu = -2\). To convert the result to the other often used convention \(\ell^\mu k_\mu = -1\), simply divide the integration result by \(\sqrt{2}\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. </td></tr>
    <tr><td class="paramname">tev_args</td><td>Optional further arguments for the <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4ad4da6539184472b914b8be8af13791" title="Compute the time evolution 4D vector.">time_evolution_vector()</a> call. </td></tr>
    <tr><td class="paramname">n</td><td>Order of the fixed quadrature integration (roughly equal to the number of points at which the integrand is evaluated). The default <code>"auto"</code> will use twice the current curve's resolution, but at least 30 points. </td></tr>
    <tr><td class="paramname">unity_b</td><td>If <code>True</code>, expand the TEV as \(V = \ell + c k\), effectively transforming <code>c</code> to <code>c/b</code>. If <code>False</code> (default), use the usual scaling (with unity time component of the TEV). </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the computed value of the integral and a list of <code>n</code> <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1TimeVectorData.html" title="MOTT time evolution vector.">TimeVectorData</a> objects created while evaluating the integrand. Default is <code>False</code>, i.e. to only return the value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea5c33ef11a8f6531a62f65777be3a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea5c33ef11a8f6531a62f65777be3a34">&#9670;&nbsp;</a></span>irreducible_mass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def irreducible_mass </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>area</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the irreducible mass. </p>
<p>The irreducible mass of a horizon is (see e.g. [1]) </p><p class="formulaDsp">
\[ M := \sqrt{A/16\pi}, \]
</p>
<p> where <code>A</code> is the horizon's area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">area</td><td>Optional area for which to compute the mass. By default, the area of the axisymmetric surface represented by this curve is computed.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Chu, Tony, Harald P. Pfeiffer, and Michael I. Cohen. "Horizon
     dynamics of distorted rotating black holes." Physical Review D 83.10 (2011): 104018. </p>

</div>
</div>
<a id="a287674a9252dd9228d16780a17670129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287674a9252dd9228d16780a17670129">&#9670;&nbsp;</a></span>linearized_equation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def linearized_equation </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>target_expansion</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pool</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return linearized equation as operator and inhomogeneity on a grid. </p>
<p>This form is suitable to be processed by the pseudospectral solver <a class="el" href="namespacemotsfinder_1_1ndsolve_1_1solver.html#aa9b143582d20b970c4f3001cad8fa3b5" title="Numerically solve a linear differential equation.">ndsolve.solver.ndsolve()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Points at which to evaluate the equation terms. Should be the collocation points for a pseudospectral solver. </td></tr>
    <tr><td class="paramname">target_expansion</td><td>Optional float indicating the desired expansion of the surface to find. Default is <code>0.0</code> (i.e. a MOTS). </td></tr>
    <tr><td class="paramname">parallel</td><td>Whether to evaluate the equation using multiple processes in parallel. If <code>True</code>, uses all available threads. If an integer, uses that many threads. Default is <code>False</code>, i.e. don't compute in parallel. </td></tr>
    <tr><td class="paramname">pool</td><td>Optional processing pool to re-use. If not given, a new pool is created and then destroyed after the computation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdb06f51cca9db99704ae9fe5eac6a26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb06f51cca9db99704ae9fe5eac6a26">&#9670;&nbsp;</a></span>locate_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def locate_intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>1e-8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain1</em> = <code>(0,&#160;np.pi)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain2</em> = <code>(0,&#160;np.pi)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict1</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>strict2</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N1</em> = <code>20</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>N2</em> = <code>20</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate one point at which this curve intersects another curve. </p>
<dl class="section return"><dt>Returns</dt><dd>Tuple <code>(param1, param2)</code>, where <code>param1</code> is the parameter value of this curve and <code>param2</code> the parameter value of the <code>other_curve</code> at which the two curves have the same location. If no intersection is found, returns <code>(None, None)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to find the intersection with. </td></tr>
    <tr><td class="paramname">xtol</td><td>Tolerance in curve parameter values for the search. Default is <code>1e-8</code>. </td></tr>
    <tr><td class="paramname">domain1,domain2</td><td>Optional interval of the curves to consider. Default is the full curve, i.e. <code>(0, pi)</code> for both. </td></tr>
    <tr><td class="paramname">strict1,strict2</td><td>Whether to only allow solutions in the given domains <code>domain1</code>, <code>domain2</code>, respectively (default). If either is <code>False</code>, the respective domain is used just for the initial coarse check to find a starting point. Setting e.g. <code>N1=1</code> and <code>strict1=False</code> allows specifying a starting point on this (first) curve. </td></tr>
    <tr><td class="paramname">N1,N2</td><td>Number of equally spaced rough samples to check for a good starting point. To avoid running into some local minimal distance (e.g. at the curve ends), this number should be high enough. Alternatively (or additionally), one may specify a smaller domain if there is prior knowledge about the curve shapes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca1e6cd728f86908a070a06765d59ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca1e6cd728f86908a070a06765d59ae">&#9670;&nbsp;</a></span>locate_self_intersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def locate_self_intersection </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>neck</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xtol</em> = <code>1e-8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locate a <em>loop</em> in the MOTS around its neck. </p>
<dl class="section return"><dt>Returns</dt><dd>Two parameter values <code>(param1, param2)</code> where the curve has the same location in the x-z-plane. If not loop is found, returns <code>(None, None)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">neck</td><td>Parameter where the neck is located. If not given, finds the neck using default arguments of <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#ad4da563d8d0d36fb22f95b39c26a5a4a" title="Try to locate a &#39;neck&#39; of this curve.">find_neck()</a>. </td></tr>
    <tr><td class="paramname">xtol</td><td>Tolerance in curve parameter values for the search. Default is <code>1e-8</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f9369f0ebb256c0239aaea0e8df62a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9369f0ebb256c0239aaea0e8df62a9">&#9670;&nbsp;</a></span>multipoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def multipoles </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_n</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_n</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>det_q_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ricci_scalar_function</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeta</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the multipoles I_n of the horizon. </p>
<p>This is based on the considerations in [1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_n,max_n</td><td>Integers specifying the minimum and maximum number <code>n</code> (inclusive) up to which the moments \(I_n\) should be computed. By default, we compute for <code>n=0,...,10</code>. </td></tr>
    <tr><td class="paramname">num</td><td>Resolution for the pseudospectral solution of the invariant coordinate \(\zeta\). Default is to use the current curve's resolution, but at least 100. </td></tr>
    <tr><td class="paramname">det_q_function,ricci_scalar_function,zeta</td><td>Optional callables evaluating \(\det q\), the Ricci scalar, and the invariant angle \(\zeta(\lambda)\), respectively. Can be used to supply cached or previously generated versions of these functions. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to return an <a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html" title="Represents a sequence of multiple integration results.">numutils.IntegrationResults</a> object containing all values with their errors and any warnings. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">disp</td><td>Raise an error in case of an integration warning. </td></tr>
    <tr><td class="paramname">**kw</td><td>Additional keyword arguments are supplied to the <code>scipy.integrate.quad</code> call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A list of computed moments \(I_n\) for <code>n=0,1,..,max_n</code>.</dd></dl>
<p><b>References</b> </p>
<p>[1] Ashtekar, Abhay, et al. "Multipole moments of isolated horizons." Classical and Quantum Gravity 21.11 (2004): 2549. </p>

</div>
</div>
<a id="a0b50656b2043eb74fa8321e6c2419238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b50656b2043eb74fa8321e6c2419238">&#9670;&nbsp;</a></span>plot_coeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def plot_coeffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>r&quot;\gamma&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>figsize</em> = <code>(5,&#160;3)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to plot the horizon function's spectral coefficients. </p>
<p>This may help in quickly judging convergence based on exponential decay. </p>

</div>
</div>
<a id="a4417b4ffab13d47bbcb986cc844ae2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4417b4ffab13d47bbcb986cc844ae2f7">&#9670;&nbsp;</a></span>plot_expansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def plot_expansion </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>c</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>name</em> = <code>r&quot;\gamma&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>figsize</em> = <code>(5,&#160;3)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ingoing</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function to plot the expansion along the curve. </p>
<p>This may help in quickly judging convergence. The parameter <code>c</code> is subtracted from the values, which is useful to analyse constant expansion surfaces. </p>

</div>
</div>
<a id="a0e237fcc955d9e464d5c32fc84a840f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e237fcc955d9e464d5c32fc84a840f9">&#9670;&nbsp;</a></span>resample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def resample </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>new_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the number of DOFs of the horizon function. </p>
<p>Other algorithms may use this number to implement modification of the horizon function for a search for e.g. MOTSs.</p>
<p>This function returns the curve object itself to allow for chaining. </p>

</div>
</div>
<a id="a05b59585b2daf3036737fe2e3a3a9f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b59585b2daf3036737fe2e3a3a9f80">&#9670;&nbsp;</a></span>ricci_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ricci_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the Ricci scalar of the surface at the given parameter. </p>
<p>See <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcalc_1_1ExpansionCalc.html#ae5dcd5322e3a34af3c21ae93ace09e22" title="Compute the Ricci scalar of the surface represented by the curve.">expcalc.ExpansionCalc.ricci_scalar()</a> for details. </p>

</div>
</div>
<a id="a92b72eda23af6809e3e8fe0efc629bea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b72eda23af6809e3e8fe0efc629bea">&#9670;&nbsp;</a></span>shear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def shear </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the shear of the MOTS at a point. </p>
<p>See ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1stabcalc_1_1StabilityCalc.html#a95aef4b087204edef098d169b16893e8" title="Compute the shear tensor in coordinates on the surface.">stabcalc.StabilityCalc.compute_shear()</a> for more information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Point on the MOTS to compute the shear at. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the shear (2,2)-tensor and its square \(\sigma_{AB}\sigma^{AB}\). Default is <code>False</code>, i.e. only return the shear tensor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa641f4b2dd3163ce333e948970884a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa641f4b2dd3163ce333e948970884a7c">&#9670;&nbsp;</a></span>shear_scalar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def shear_scalar </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the complex shear scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">param</td><td>Point on the MOTS to compute the shear scalar at. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the shear scalar, the shear tensor, and the square of the shear. Default is <code>False</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>Given two orthonormal spacelike tangents \(e_1\), \(e_2\) to the MOTS, we define a null tetrad \((\ell, k, m, \bar m)\), where \(m^\mu = \frac{1}{\sqrt{2}}(e_1 + i e_2)\). Here, \(\ell^\mu, k^\mu\) are the outgoing and ingoing future pointing null normals to the MOTS, respectively, with the scaling condition \(\ell^\mu k_\mu = -1\) (notice that this is different than our usual scaling condition, see also ..<a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1stabcalc_1_1StabilityCalc.html#a95aef4b087204edef098d169b16893e8" title="Compute the shear tensor in coordinates on the surface.">stabcalc.StabilityCalc.compute_shear()</a>). Then, the shear scalar is defined as </p><p class="formulaDsp">
\[ \sigma_{(\ell)} = m^\mu m^\nu \nabla_\mu \ell_\nu = \frac{1}{2} \left( \frac{\sigma_{\lambda\lambda}}{q_{\lambda\lambda}} - \frac{\sigma_{\varphi\varphi}}{q_{\varphi\varphi}} \right) + i \frac{\sigma_{\lambda\varphi}} {\sqrt{q_{\lambda\lambda}q_{\varphi\varphi}}} \,, \]
</p>
<p> where we have used \(e_1 = \frac{\partial_\lambda}{\sqrt{q_{\lambda\lambda}}}\) and \(e_2 = \frac{\partial_\varphi}{\sqrt{q_{\varphi\varphi}}}\). </p>

</div>
</div>
<a id="a380a3fc19ab9398c2ac5a30068553444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380a3fc19ab9398c2ac5a30068553444">&#9670;&nbsp;</a></span>shear_square_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def shear_square_integral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integral of the shear squared. </p>
<p>This computes the integral </p><p class="formulaDsp">
\[ \int_\mathcal{S} \sigma_{AB}\sigma^{AB}\ dV = 2\pi \int_0^\pi \sigma_{AB}\sigma^{AB} \sqrt{q}\ d\lambda\,. \]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Order of the fixed quadrature integration (which is equal to the number of points at which the integrand is evaluated). The default <code>"auto"</code> will use twice the current curve's resolution, but at least 30 points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac59f67e49be52dc9c8a6d1a5ff846fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac59f67e49be52dc9c8a6d1a5ff846fc">&#9670;&nbsp;</a></span>signature_quantities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def signature_quantities </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the MOTS tube signature along points of this MOTS. </p>
<p>This method takes a list of points and evaluates the signature of the MOTT, i.e. the hypersurface consisting of stacking the MOTSs at different times to build a world-tube. This surface may be space-like (the usual case for a dynamical horizon) or null (in the static case, e.g. Schwarzschild), timelike, or even of mixed signature.</p>
<p>The signature is computed using a list of curves representing this MOTS at different time steps. We collect a given number of such curves before and after the time slice of this current MOTS and interpolate along the time direction in order to evaluate the coordinate derivative vector.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1SignatureQuantities.html" title="Class storing quantities allowing visualization of signature.">SignatureQuantities</a> objects, one for each point in <code>pts</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>The points along the MOTS at which to evaluate the signature. Should be a sequence of values in the open interval <code>(0, pi)</code>. Interpretation of these values is subject to <code>proper</code>. </td></tr>
    <tr><td class="paramname">curves</td><td>Additional curves for different times in order to interpolate and compute the time derivative. The current MOTS (i.e. this object) may or may not be part of this list and their order does not matter. This list needs to have at least one other MOTS that is not the current object. </td></tr>
    <tr><td class="paramname">proper</td><td>Whether to interpret the values in <code>pts</code> as fraction of the proper length (scaled by <code>pi</code>) or as simple curve parameter. Default is <code>True</code>. If the parameterization of the other curves in <code>curves</code> does not vary slowly in time, taking the 'simple' parameter values produces non-differentiable world lines of constant curve parameter and hence very inaccurate signature evaluations. Since smooth parameterization can not be guaranteed in most cases, it is highly recommended to take the proper parameterizations. Note that in both cases, the values of <code>pts</code> should lie in <code>(0, pi)</code>. <b>NOTE:</b> All curves (the current one and those in <code>curves</code>) should have <code>'length_maps'</code> data in <code>user_data</code>. This can be obtained using the methods in ..<a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html" title="Functions to compute and store physical properties of MOTS curves.">trackmots.props</a>. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>Let \(\mathcal{H}\) be the MOTT foliated by the MOTSs given in the <code>curves</code> parameter and \(N\) a normal of \(\mathcal{H}\). Then, at a point \(p \in \mathcal{H}\) we have</p><ul>
<li>\(\mathcal{H}\) spacelike at \(p\) iff \(g(N_p, N_p) &lt; 0\),</li>
<li>\(\mathcal{H}\) timelike at \(p\) iff \(g(N_p, N_p) &gt; 0\),</li>
<li>\(\mathcal{H}\) null at \(p\) iff \(g(N_p, N_p) = 0\).</li>
</ul>
<p>Let \(k^\mu\) and \(\ell^\mu\) span the (2D) space of normals to the current MOTS in spacetime \(M\), with the scaling fixed such that \(k^\mu \ell_\mu = -2\). Then, \(N\) will be of the form \(N = c_1 \ell + c_2 k\) and hence \(g(N,N) = -4c_1c_2\). This follows from the fact that a normal to the MOTT is also a normal to the MOTS. The condition for \(N\) to be normal to \(\mathcal{H}\) now becomes </p><p class="formulaDsp">
\[ g(N, \partial_\tau) = 0 \qquad \Leftrightarrow \qquad \frac{c_1}{c_2} = -\frac{k\cdot\partial_\tau}{\ell\cdot\partial_\tau}\,, \]
</p>
<p> where \(\tau\) is a coordinate along \(\mathcal{H}\) and \(\partial_\tau\) a tangent to \(\mathcal{H}\) (which is not necessarily normal to the MOTS). We choose \(\tau(p) = t\) iff \(p \in \mathcal{S}_t\), where \(\mathcal{S}_t\) is the MOTS in the slice with coordinate time \(t\). We get the coordinate line of \(\tau\) by fixing the other coordinates on the MOTSs. As explained above, we do not fix the parameter \(\lambda\) of our MOTS representation. Instead, we use a fraction of the proper length as coordinate, which ensures a smooth coordinate line when varying just \(\tau\).</p>
<p>The sign of \(g(N,N) = -4c_1c_2\) is the same as that of \(-\frac{c_1}{c_2}\), which is the same as that of \(f_{sig}:=(k\cdot\partial_\tau)(\ell\cdot\partial_\tau)\). We then have</p><ul>
<li>\(\mathcal{H}\) spacelike iff \(f_{sig} &lt; 0\),</li>
<li>\(\mathcal{H}\) timelike iff \(f_{sig} &gt; 0\),</li>
<li>\(\mathcal{H}\) null iff \(f_{sig} = 0\). </li>
</ul>

</div>
</div>
<a id="a621b9f8de00dfe38f3462427775d876d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621b9f8de00dfe38f3462427775d876d">&#9670;&nbsp;</a></span>stability_parameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def stability_parameter </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>num</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_max</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>m_terminate_index</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>compute_eigenfunctions</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>slice_normal</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>transform_torsion</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>force_general</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>zeta</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>basis_cls</em> = <code>ChebyBasis</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the stability parameter. </p>
<p>The stability parameter is defined in [1] as the principal eigenvalue of the stability operator. We use the normal vector in the slice and use the axisymmetry to simplify the analytical task.</p>
<p>According to Proposition 5.1 in [1], the MOTS represented by this curve is stably outermost iff the stability parameter is greater or equal to zero and strictly stably outermost iff it is greater than zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>Pseudospectral resolution of the discretization of the operator. By default, uses the resolution of the curve representation itself. </td></tr>
    <tr><td class="paramname">m_max</td><td>Maximum angular mode to consider. Default is to use <code>num-1</code>. </td></tr>
    <tr><td class="paramname">m_terminate_index</td><td>Index of the eigenvalue of the <code>m=0</code> mode to use to as stopping criterion for the angular mode. If the real part of the thus specified <code>m=0</code> eigenvalue is less or equal to the (real part of the) smallest eigenvalue of the current <code>m</code>, then no higher <code>m</code> modes are considered. This effectively gives the number of <code>m=0</code> eigenvalues of which we want to determine the multiplicity. Default is <code>30</code>. Set explicitly to <code>None</code> to not stop based on this criterion. </td></tr>
    <tr><td class="paramname">rtol</td><td>Tolerance for reality check. The principal eigenvalue is shown in [1] to be real. If it has a non-zero imaginary part greater than <code>rtol * |real_part|</code>, then a <code>RuntimeError</code> is raised. Default is <code>1e-12</code>. </td></tr>
    <tr><td class="paramname">compute_eigenfunctions</td><td>Whether to compute the eigenfunction for each eigenvalue. Default is <code>False</code>. The eigenfunctions will be accessible from the StabilitySpectrum object via the <code>spectrum.get_eigenfunction()</code> method. Note that the method for computing the eigenvalues is a different one in this case and hence the numerical values (and even the accuracy) may differ from the case <code>compute_eigenfunctions=False</code>. </td></tr>
    <tr><td class="paramname">slice_normal</td><td>Whether to consider the stability operator w.r.t. the outward normal in the spatial slice (default). If <code>False</code>, consider the operator w.r.t. the past-pointing outward null normal \(-k^\mu\). </td></tr>
    <tr><td class="paramname">transform_torsion</td><td>Apply a transformation to the lightlike null vectors <code>k</code> and <code>l</code> such that the rotation 1-form \(s_A\) (torsion of <code>l</code>) becomes divergence free. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">force_general</td><td>Use the general equation even for time-symmetric initial data. </td></tr>
    <tr><td class="paramname">zeta</td><td>Optional invariant angle zeta as function of curve parameter. If not supplied, will generate it when needed (i.e. when eigenfunctions are requested). </td></tr>
    <tr><td class="paramname">basis_cls</td><td>Class to expand the operator in for computing the stability spectrum. Default is to use Chebyshev polynomials. Can be either a basis suitable for <code>ndsolve()</code> or a string indicating the basis to choose. Possible values are <code>"Cheby"</code>, <code>"Sine"</code>, <code>"Cosine"</code>, <code>"Fourier"</code>. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return all eigenvalues in addition to the principal eigenvalue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The principal eigenvalue as a float (i.e. the real part, ignoring any spurious imaginary part). If <code>full_output==True</code>, returns a StabilitySpectrum object as second element containing all found eigenvalues.</dd></dl>
<p><b>Notes</b> </p>
<p>If the MOTS \(\mathcal{S}\) is contained in a time-symmetric slice \(\Sigma\) of spacetime, and we compute the stability w.r.t. the outward pointing normal \(\nu\) of \(\mathcal{S}\) in \(\Sigma\), then the stability operator simplifies greatly to </p><p class="formulaDsp">
\[ L_\nu \zeta = -\Delta_\mathcal{S} \zeta - (R_{ij}\nu^i\nu^j + \mathcal{K}_{AB}\mathcal{K}^{AB}) \zeta, \]
</p>
<p> where \(R_{ij}\) is the Ricci tensor of \((\Sigma, g)\), \(\mathcal{K}_{AB}\) is the extrinsic curvature of \(\mathcal{S}\), \(\Delta_\mathcal{S} = q^{AB}\,D_A\,D_B\) is the Laplacian on \((\mathcal{S}, q)\), <code>g</code> is the 3-metric on the slice and <code>q</code> the induced 2-metric on the MOTS.</p>
<p>Without time symmetry, the full operator (in vacuum) reads </p><p class="formulaDsp">
\[ L_\nu \zeta = -\Delta_\mathcal{S} \zeta + 2 s^A D_A \zeta + \big( \frac{1}{2} \mathcal{R} - s_A s^A + D_A s^A - \frac{1}{2} q^{AC} q^{BD} K^\mu_{AB} K^\nu_{CD} \ell_\mu \ell_\nu \big). \]
</p>
<p> Here, \(\mathcal{R}\) is the Ricci scalar of \(\mathcal{S}\), \(s_A = -\frac{1}{2} k_\mu \nabla_A \ell^\mu\) and \(K^\mu_{AB}\ell_\mu = -\nabla_A \ell_B\). Note that \(\nabla\) refers to the covariant derivative compatible with the spacetime 4-metric and \(k^\mu\) and \(\ell^\mu\) are the future pointing ingoing and outgoing null normals to \(\mathcal{S}\), respectively.</p>
<p>To find the principal eigenvalue of \(L_\nu\), first note that due to the axisymmetry, the \(\varphi\)-dependence of \(\zeta\) can be expressed as </p><p class="formulaDsp">
\[ \zeta(\lambda, \varphi) = \sum_{m=-\infty}^\infty \zeta_m(\lambda) e^{im\varphi}. \]
</p>
<p> Since the \(e^{im\varphi}\) are linearly independent, the spectrum will consist of the union of spectra of the \(\zeta_m\). When taking the union, we label the eigenvalues by their <code>m</code>-mode to be able to count their multiplicity.</p>
<p>The effect of applying \(L\) to \(\zeta_m e^{im\varphi}\) can in axisymmetry be reduced to a 1D problem of acting on just \(\zeta_m\) via (no summation here, \(m\) is the angular mode, not an index) </p><p class="formulaDsp">
\[ L^m \zeta_m = (L + 2 i m s^\varphi + m^2 q^{\varphi\varphi}) \zeta_m. \]
</p>
<p>The eigenvalues themselves are found using <a class="el" href="classmotsfinder_1_1ndsolve_1_1solver_1_1NDSolver.html#a280cc9d8aeddcb741338cfc65fe9cf52" title="Compute the eigenvalues of the operator.">motsfinder.ndsolve.solver.NDSolver.eigenvalues()</a>, which means we just need to provide the coefficient functions defining the one-dimensional operator \(L^m\) acting on \(\zeta_m\). The Laplacian acting on \(\zeta_m\) reads </p><p class="formulaDsp">
\begin{eqnarray*} \Delta_\sigma \zeta_m &amp;=&amp; \frac{1}{\sqrt{q}} \partial_A (\sqrt{q} q^{AB} \partial_B \zeta_m) = \left( \frac{1}{2} q^{AB} q^{C\lambda} \partial_C q_{AB} + \partial_A q^{A\lambda} \right) \zeta_m&#39; + q^{\lambda\lambda} \zeta_m&#39;&#39; \\ &amp;=&amp; \left( \frac{1}{2} q^{AB} q^{C\lambda} - q^{AC} q^{B\lambda} \right) (\partial_C q_{AB}) \zeta_m&#39; + q^{\lambda\lambda} \zeta_m&#39;&#39;. \end{eqnarray*}
</p>
<p><b>References</b> </p>
<p>[1] Andersson, Lars, Marc Mars, and Walter Simon. "Stability of marginally outer trapped surfaces and existence of marginally outer trapped tubes." arXiv preprint arXiv:0704.2889 (2007). </p>

</div>
</div>
<a id="adf576f119b60fc790caa871324a88dca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf576f119b60fc790caa871324a88dca">&#9670;&nbsp;</a></span>surface_gravity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def surface_gravity </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>wrt</em> = <code>&quot;ell&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tevs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a (slicing dependent) surface gravity. </p>
<p>This computes the surface gravity according to eq. (19) in Ref. [1], i.e. </p><p class="formulaDsp">
\[ \kappa = - k_\mu X^\nu \nabla_\nu \ell^\mu \,, \]
</p>
<p> where \(X^\mu = \ell^\mu\) by default. However, we use a different (slicing dependent) scaling of the null normals. In particular, we choose </p><p class="formulaDsp">
\[ \ell^\mu = \frac{1}{\sqrt{2}} (n^\mu + v^\mu) \,, \qquad k^\mu = \frac{1}{\sqrt{2}} (n^\mu - v^\mu) \,, \]
</p>
<p> where \(\ell^\mu\) and \(k^\mu\) are the future pointing outgoing and ingoing null normals, respectively. Here, \(n^\mu\) is the timelike future pointing normal on the spatial slice and \(v^\mu\) the outward normal of the MOTS within the slice. The above choice leads to a cross-normalization of \(\ell^\mu k_\mu = -1\).</p>
<p>Note that this cross-normalization does not fix the scaling of the null normals. If \(f\) is an arbitrary positive function, then \(\tilde\ell^\mu := f\ell^\mu\) and \(\tilde k^\mu := fk^\mu\) satisfy the same condition but will result in different values for the surface gravity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>Points at which to compute the surface gravity. Values should be the pi-normalized proper lengths, i.e. <code>0</code> is at the north pole, <code>pi</code> at the south pole, and <code>pi/2</code> at <code>50%</code> proper length. </td></tr>
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. This parameter is needed to numerically estimate the time derivative of the normal to the MOTS in the slice. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">wrt</td><td>Vector with respect to which to compute the surface gravity. Possible values are <code>"ell"</code> (default) and <code>"tev"</code>. </td></tr>
    <tr><td class="paramname">tevs</td><td>In case you use the time evolution vector (<code>"tev"</code>) option for the <code>wrt</code> parameter, you may optionally supply a list of these vectors (objects) here, in case they are already precomputed. These should correspond to the points in <code>pts</code>.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Pielahn, Mathias, Gabor Kunstatter, and Alex B. Nielsen. "Dynamical surface gravity in spherically symmetric black hole
     formation." Physical Review D 84.10 (2011): 104008. </p>

</div>
</div>
<a id="a63fc2ab7c97360b53459877417ba7213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63fc2ab7c97360b53459877417ba7213">&#9670;&nbsp;</a></span>suspend_calc_obj()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def suspend_calc_obj </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context manager to temporarily ignore the current calculator. </p>
<p>When leaving the with-scope, the current calculator is restored. This may be useful during evaluation of expansions for perturbed curves in finite difference approximations of functional derivatives of the expansion. </p>

</div>
</div>
<a id="a474b5d328f851a167e5a83cb99f7ed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474b5d328f851a167e5a83cb99f7ed25">&#9670;&nbsp;</a></span>temp_metric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def temp_metric </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>metric</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context manager to temporarily replace the used metric. </p>
<p>When leaving the with-scope, the previous metric is restored. </p>

</div>
</div>
<a id="a4ad4da6539184472b914b8be8af13791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad4da6539184472b914b8be8af13791">&#9670;&nbsp;</a></span>time_evolution_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def time_evolution_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>search_step</em> = <code>1e-3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>search_dist_increase</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_increases</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Ns</em> = <code>400</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the time evolution 4D vector. </p>
<p>Stacking the MOTSs at different times produces a 3-dimensional manifold, the marginally outer trapped tube (MOTT) foliated by the MOTSs. At any given point of a MOTS, we can find a normal in spacetime pointing tangent to the MOTT. This will be a linear combination of the ingoing and outgoing null normals \(k\) and \(\ell\), since these span the 2D space of normals to the MOTS.</p>
<p><b>NOTE 1:</b> This method is currently limited to MOTSs with vanishing spin (i.e. where the ingoing and outgoing null normals to the MOTS have no <code>y</code> component).</p>
<p><b>NOTE 2:</b> All curves (the current one and those in <code>curves</code>) should have <code>'length_maps'</code> data in <code>user_data</code>. This can be obtained using the methods in ..<a class="el" href="namespacemotsfinder_1_1axisym_1_1trackmots_1_1props.html" title="Functions to compute and store physical properties of MOTS curves.">trackmots.props</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>For each value in <code>pts</code>, a 4-vector <code>V</code> pointing along the MOTT. If <code>full_output==True</code>, return a <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1TimeVectorData.html" title="MOTT time evolution vector.">TimeVectorData</a> object for each such value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>The points along the MOTS at which to evaluate the signature. Should be a sequence of values in the open interval <code>(0, pi)</code>. Note that these are not the intrinsic parameters (called <code>lambda</code> or <code>param</code> in this code) but the <code>pi</code>-normalized proper length parameters. For example, a value <code>pi/2</code> is the point splitting the curve into two parts of equal proper length. </td></tr>
    <tr><td class="paramname">curves</td><td>Additional curves for different times in order to interpolate and compute the time derivative. The current MOTS (i.e. this object) may or may not be part of this list and their order does not matter. This list needs to have at least one other MOTS that is not the current object. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">search_step</td><td>Initial step for optimizing the tilting parameter (see below). Default is <code>1e-3</code>. </td></tr>
    <tr><td class="paramname">search_dist_increase</td><td>Factor by which the searched region for the tilting parameter is increased in each trial. Default is <code>10</code>. </td></tr>
    <tr><td class="paramname">max_increases</td><td>Maximum number of times the search region for the tilting parameter is increased by <code>search_dist_increase</code>. Default is <code>4</code>. </td></tr>
    <tr><td class="paramname">Ns</td><td>Number of sample points for the <code>scipy.optimize.brute()</code> searches done after the search region is increased. </td></tr>
    <tr><td class="paramname">tol</td><td>Tolerance for the error. If the error drops below <code>tol</code>, we define the current tilting parameter as converged and return the resulting time evolution vector. </td></tr>
    <tr><td class="paramname">full_output</td><td>Wether to output a list of <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1TimeVectorData.html" title="MOTT time evolution vector.">TimeVectorData</a> object (if <code>True</code>) or a list of 4D numpy vectors (default).</td></tr>
  </table>
  </dd>
</dl>
<p><b>Notes</b> </p>
<p>The time vector is found using a numerical minimization strategy as follows. For each MOTS we take one point at the same relative proper length (say <code>25%</code> of the curve's total length) and interpolate a curve through these points. The curve parameter will be the simulation time. The tangent to this curve is a candidate for the 4D time evolution vector of the MOTT. However, in general it will be slightly off the plane of normals from the MOTS (it points along the MOTT, but not orthogonal to the MOTS). We project this vector onto the plane spanned by \(k\) and \(\ell\) and compute the sum of the squares of coordinate changes this induces. This is the error we wish to minimize. We then tilt the vector by building a new time interpolation curve. The tilting is achieved by not taking the same relative proper length parameter for each MOTS. Instead, we move away from this parameter linearly in coordinate time. The "speed" for this moving is then numerically optimized to minimize the error. We call this speed the tilting parameter.</p>
<p>The optimization is first performed using Brent's method, starting from the same tilting parameter that was successful for the previous point. Near the poles, the tilting is guaranteed to be small. Having a large number of points in <code>pts</code> hence leads to faster convergence per point, given the points are ordered and somewhat evenly distributed. If the search converges in a local minimum (given tolerance is not reached), we do a brute search on a grid of points in a larger region around the previously successful tilting parameter. The best match is then used as starting point for another search using Brent's method. </p>

</div>
</div>
<a id="a5d3480e378bb9d98fdbe4b6a8a18f5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3480e378bb9d98fdbe4b6a8a18f5bf">&#9670;&nbsp;</a></span>time_interpolators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def time_interpolators </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>points</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>eps</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a set of functions interpolating along a MOTT. </p>
<dl class="section return"><dt>Returns</dt><dd>A list of callables with signature <code>f(x, nu=0)</code>, where <code>x</code> is the time <code>t</code> at which to evaluate and <code>nu</code> the time derivative. There will be one such function per point in <code>points</code> (see below). Each function will return a 3-element array with the coordinates of the intersection of the tube with the <code>t=const</code> slice. The coordinates will correspond to the same point on the respective curve for each <code>t</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. </td></tr>
    <tr><td class="paramname">points</td><td>List of points each being a number in <code>[0, pi]</code>. Alternatively, this can be an integer specifying how many of such points should be created. They will be equally spaced and exclude the boundary. Default is to take the current curve's resolution <code>self.num</code>. </td></tr>
    <tr><td class="paramname">proper</td><td>Whether to take the points at the pi-normalized proper length or at the curves current parameterization. It is strongly recommended to take the proper length, which is also the default. Otherwise, the worldlines are most likely not differentiable (i.e. the interpolation may be very poor). </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves before and after this current curve to consider for interpolation. Default is <code>3</code>. Set to <code>None</code> to use all curves as-is. The current curve then has to be in <code>curves</code>. </td></tr>
    <tr><td class="paramname">eps</td><td>Parameterized deviation from the "equal-parameter" rule. If nonzero, the surrounding curves are not evaluated at the same (possibly proper-length) parameter <code>u</code> as this curve but instead at <code>u + eps*(t-t0)</code>, where <code>t0</code> is the time of the slice this curve lives in. Default is <code>0.0</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a124738aa04c429c1e8b3622ea2b47044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124738aa04c429c1e8b3622ea2b47044">&#9670;&nbsp;</a></span>time_shift_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def time_shift_params </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>next_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transport a list of parameters in time. </p>
<p>This takes a set of parameter values (i.e. points along the MOTS) and computes the parameters of points on a future (or past) MOTS obtained by transporting the points along the evolution vector field on the dynamical horizon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Sequence of parameter values specifying the points on the MOTS to transport. </td></tr>
    <tr><td class="paramname">tevs</td><td>List of time evolution vectors along the current MOTS. These will be interpolated to the given <code>params</code> to obtain the direction into which to transport the points. </td></tr>
    <tr><td class="paramname">next_curve</td><td>The MOTS to transport the points to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40079c05732aedfe1bc8544e7a5d2014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40079c05732aedfe1bc8544e7a5d2014">&#9670;&nbsp;</a></span>timescale_T2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def timescale_T2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tevs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square of the timescale <code>T</code>. </p>
<p>This computes </p><p class="formulaDsp">
\[ T^2 := \left( \frac{1}{A} \int_{\mathcal{S}} \sigma^{(V)}_{AB}\sigma^{(\tau)\,AB}\ dA \right)^{-1} \,, \]
</p>
<p> where <code>A</code> is the MOTS's surface area, <code>V</code> is the time evolution vector (scaled to have unity time component) with </p><p class="formulaDsp">
\[ V^\mu = b \ell^\mu + c k^\mu \,. \]
</p>
<p> Then, \(\tau^\mu = b \ell^\mu - c k^\mu\). \(\ell\) and \(k\) are the outgoing and ingoing null normals with scaling \(\ell \cdot k = -1\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tevs</td><td>List of <code>n</code> time evolution vector objects at the Gaussian quadrature points for an integral of order <code>n</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa857530befbb8273056ab18d5f588fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa857530befbb8273056ab18d5f588fd">&#9670;&nbsp;</a></span>timescale_tau2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def timescale_tau2 </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tevs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kappas_tev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>proper_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>option</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the square of the timescale <code>tau</code>. </p>
<p>This computes </p><p class="formulaDsp">
\[ \tau^2 := \left( \frac{1}{A} \int_{\mathcal{S}} \kappa^{(V)} \Theta_{(V)}\ dA \right)^{-1} \,, \]
</p>
<p> where <code>A</code> is the MOTS's surface area, \(\kappa^{(V)} = - k^\mu V^\nu \nabla_\nu \ell_\mu\) is the surface gravity with respect to the time evolution vector <code>V</code> (with unit time component) and \(\ell\) and \(k\) are the outgoing and ingoing null normals with scaling \(\ell \cdot k = -1\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tevs</td><td>List of <code>n</code> time evolution vector objects at the Gaussian quadrature points for an integral of order <code>n</code>. </td></tr>
    <tr><td class="paramname">kappas_tev</td><td>List of values of the surface gravity w.r.t. the time evolution vectors. </td></tr>
    <tr><td class="paramname">proper_pts</td><td>List of proper parameter values (in <code>[0, pi]</code>) at which the <code>kappas_tev</code> are computed. Only used to verify that all quantities are evaluated at the correct points. </td></tr>
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. This parameter is needed to numerically estimate the time derivative of the <code>c</code> coefficient of the time evolution vectors (used only in option 4, see below). </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">option</td><td>For debugging/exploration purposes. Use different definitions of \(\tau\) to experiment with. The options are (<b>note</b> that for option 2 we return \(\tau\) instead of \(\tau^2\)):<ul>
<li>option 0: default, the one given in the above equation</li>
<li>option 1: use \(1/\tau^2 = \frac{1}{A} \int_{\mathcal{S}} \Theta_{(V)}^2\ dA\)</li>
<li>option 2: use \(1/\tau = \frac{1}{A} \int_{\mathcal{S}} \Theta_{(V)}\ dA\)</li>
<li>option 3: use \(1/\tau^2 = \frac{1}{A} \int_{\mathcal{S}} [\kappa^{(V)} \Theta_{(V)} - \frac12 \Theta_{(V)}^2] \ dA\)</li>
<li>option 4: use \(1/\tau^2 = \frac{1}{A} \int_{\mathcal{S}} [\kappa^{(V)} \Theta_{(V)} - \frac12 \Theta_{(V)}^2 - \Theta_{(V)} \frac{d}{dt} \ln c] \ dA\) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e1dca9e2b825bc59677a54a64a07b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1dca9e2b825bc59677a54a64a07b7c">&#9670;&nbsp;</a></span>xi_square_integral()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def xi_square_integral </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em> = <code>&quot;auto&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the integral of the square of the xi vector. </p>
<p>We compute \(\int_\mathcal{S} \xi^A \xi_A d^2V\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">n</td><td>Order of the fixed quadrature integration (equal to the number of points at which the integrand is evaluated). The default <code>"auto"</code> will use twice the current curve's resolution, but at least 30 points. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f5c782f8ffdf59548daf2e6d39666e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5c782f8ffdf59548daf2e6d39666e8">&#9670;&nbsp;</a></span>xi_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def xi_vector </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>steps</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>r_hat</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>get_tevs</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tevs</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the xi vector. </p>
<p>The quantity computed here is called \(\zeta^A\) in eq. (3.10) in Ref. [1], see also eq. (3.19) in Ref. [2]. We compute </p><p class="formulaDsp">
\[ \xi^A := q^{AB} \hat r^\mu \nabla_\mu \ell_B \,, \]
</p>
<p> where \(\hat r^\mu\) is the normalized time evolution vector (see <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html#a4ad4da6539184472b914b8be8af13791" title="Compute the time evolution 4D vector.">time_evolution_vector()</a>), \(q^{AB}\) the inverse 2-metric on the MOTS, and \(\ell^\mu\) the future pointing outgoing null normal to the MOTS. Note that we use the scaling \(k^\mu \ell_\mu = -1\) here, where \(k^\mu\) is the future pointing ingoing null normal.</p>
<p><b>Note:</b> This quantity depends on the scaling of the null normals. We construct the null normals in a slicing dependent way using </p><p class="formulaDsp">
\[ \ell^\mu = \frac{1}{\sqrt{2}} (n^\mu + v^\mu) \,, \qquad k^\mu = \frac{1}{\sqrt{2}} (n^\mu - v^\mu) \,, \]
</p>
<p> where \(n^\mu\) is the future pointing normal on the slice and \(v^\mu\) the outward normal of the MOTS within the slice. This choice leads to \(\ell^\mu k_\mu = -1\). However, you can scale both null normals by an arbitrary function in a way to keep the condition \(\ell^\mu k_\mu = -1\). In Ref. [2], a different choice is made, namely </p><p class="formulaDsp">
\[ \ell^\mu = \hat\tau^\mu + \hat r^\mu \,, \]
</p>
<p> where \(\hat\tau^\mu\) is the normalized outward normal to the MOTT (i.e. a timelike vector for spacelike surfaces like dynamical horizons) and \(\hat r^\mu\) the time evolution vector, i.e. the tangent to the MOTT which is also a normal to the MOTS. Hence, quantitative results presented in [2] will not hold for the vector computed here.</p>
<dl class="section return"><dt>Returns</dt><dd>Components of \(\xi^A\) as a 2-element array. If <code>full_output=True</code>, return \(\xi^A\), \(\xi_A\), \(|\xi|^2\), \(\xi_{(\ell)}\), where \(\xi_{(\ell)} := \overline{m}^A \xi_A\). Here \(\overline{m}^\mu\) is one of the components of the complex null tetrad \((\ell,k,m,\overline{m})\).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>Proper length parameters at which to compute the results. Each point should be in the range <code>(0, pi)</code>, where a value of e.g. <code>pi/2</code> refers to a point on the MOTS dividing the curve into two parts of equal proper length. </td></tr>
    <tr><td class="paramname">curves</td><td>List of curves that build up the tube. The current object (<code>self</code>) may or may not be in that list. Each curve needs to have a metric with a <code>time</code> attribute. They do not need to be sorted. This parameter is needed to numerically estimate the time derivative of the normal to the MOTS in the slice. </td></tr>
    <tr><td class="paramname">steps</td><td>How many curves in the future and past of this curve to consider from <code>curves</code>. Default is <code>3</code>. </td></tr>
    <tr><td class="paramname">r_hat</td><td>Whether to compute \(\xi^A\) with the normalized vector \(\hat r^\mu := V^\mu/|V|\) or with the slicing-adapted evolution vector \(\mathcal{V}^\mu\) (see .curve.expcurve.TimeVectorData() for the difference). Default is <code>True</code>, i.e. to use the normalized vector. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to return just the contravariant components of the xi vector or also the covariant, the square, and the complex scalar. See above for details. Default is <code>False</code>. </td></tr>
    <tr><td class="paramname">get_tevs</td><td>Add the time evolution vectors at the requested points as list to the output. </td></tr>
    <tr><td class="paramname">tevs</td><td>Optional sequence of evolution vectors corresponding to the points given in <code>pts</code>. If not specified, will compute them.</td></tr>
  </table>
  </dd>
</dl>
<p><b>References</b> </p>
<p>[1] Ashtekar, Abhay, Miguel Campiglia, and Samir Shah. "Dynamical black holes:
     Approach to the final state." Physical Review D 88.6 (2013): 064045.</p>
<p>[2] Ashtekar, Abhay, and Badri Krishnan. "Dynamical horizons and their
     properties." Physical Review D 68.10 (2003): 104030. </p>

</div>
</div>
<a id="ad2053028a7c722407c3e0156724d8969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2053028a7c722407c3e0156724d8969">&#9670;&nbsp;</a></span>z_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def z_distance </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other_curve</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>atol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>rtol</em> = <code>1e-12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>limit</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_intersection</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the z-distance to another curve or the origin. </p>
<p>Curves in axisymmetry represent surfaces. These, by construction, have two intersections with the <code>z</code>-axis, which itself is a geodesic for any axisymmetric metric. This function computes the length of the geodesic along the <code>z</code>-axis connecting this curve with the given other curve. If no other curve is specified, computes the distance to the origin.</p>
<p>If the surfaces intersect or one is enclosed in the other, we define their distance as zero. Otherwise, the distance is computed via </p><p class="formulaDsp">
\[ \mathrm{dist} = \left| \int_a^b \sqrt{g_{zz}}\ dz \right|, \]
</p>
<p> where <code>a</code> and <code>b</code> are the respective intersections of the two curves with the <code>z</code>-axis lying closest to each other.</p>
<p>Curves that only live in coordinate space (for example <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1parametriccurve_1_1ParametricCurve.html" title="Parametric curve in the x-z-plane.">parametriccurve.ParametricCurve</a>) use the flat Euclidean metric instead (i.e. they return <code>|z|</code>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_curve</td><td>Curve to which to compute the distance. By default, computes the distance to the origin. </td></tr>
    <tr><td class="paramname">atol</td><td>Absolute tolerance used in the <code>scipy.integrate.quad</code> call. Default is <code>1e-12</code>. </td></tr>
    <tr><td class="paramname">rtol</td><td>Relative tolerance used in the <code>scipy.integrate.quad</code> call. Default is <code>1e-12</code>. </td></tr>
    <tr><td class="paramname">limit</td><td>Maximum number of subdivisions in the adaptive integration routine. Default is <code>100</code>. </td></tr>
    <tr><td class="paramname">allow_intersection</td><td>If <code>False</code> (default), surfaces that intersect are defined to have zero distance. If <code>True</code>, the distance of the points intersecting the z-axis is still computed and returned as negative number. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the computed result and an estimation of the error. Otherwise (default), just return the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Computed distance. If <code>full_output==True</code>, returns a pair <code>(dist, err)</code>, where <code>dist</code> is the computed distance and <code>err</code> the estimated error.</dd></dl>
<p><b>Notes</b> </p>
<p>Child classes that know their metric should override this method and supply the metric to <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#a1beed94746c44987d8fce97cc3173d24" title="Compute z-distance to another curve w.r.t. a given metric.">z_distance_using_metric()</a>. </p>

<p>Reimplemented from <a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1basecurve_1_1BaseCurve.html#ad2053028a7c722407c3e0156724d8969">BaseCurve</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>motsfinder/axisym/curve/expcurve.py</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym.html">axisym</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1curve.html">curve</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1axisym_1_1curve_1_1expcurve.html">expcurve</a></li><li class="navelem"><a class="el" href="classmotsfinder_1_1axisym_1_1curve_1_1expcurve_1_1ExpansionCurve.html">ExpansionCurve</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
