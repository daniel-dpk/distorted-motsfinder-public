<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MOTS Finder: motsfinder.numutils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxystyle_tweaks.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MOTS Finder
   &#160;<span id="projectnumber">v1.4-4-g8c2eec1</span>
   </div>
   <div id="projectbrief">Find non-star-shaped MOTSs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemotsfinder_1_1numutils.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">motsfinder.numutils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Miscellaneous numerical utilities and helpers.  
<a href="namespacemotsfinder_1_1numutils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1numutils_1_1NumericalError.html">NumericalError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception raised for problems with numerical evaluation.  <a href="classmotsfinder_1_1numutils_1_1NumericalError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1numutils_1_1__BinomialCoeffs.html">_BinomialCoeffs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to simply cache the coefficient lists.  <a href="classmotsfinder_1_1numutils_1_1__BinomialCoeffs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResults.html">IntegrationResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sequence of multiple integration results.  <a href="classmotsfinder_1_1numutils_1_1IntegrationResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmotsfinder_1_1numutils_1_1IntegrationResult.html">IntegrationResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of the <code>full_output</code> of a <code>quad()</code> call.  <a href="classmotsfinder_1_1numutils_1_1IntegrationResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a62d955bcc07efc721a2ddc88c474b7ca"><td class="memItemLeft" align="right" valign="top"><a id="a62d955bcc07efc721a2ddc88c474b7ca"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a62d955bcc07efc721a2ddc88c474b7ca">nan_mat</a> (shape)</td></tr>
<tr class="memdesc:a62d955bcc07efc721a2ddc88c474b7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a matrix of NaN values. <br /></td></tr>
<tr class="separator:a62d955bcc07efc721a2ddc88c474b7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bb6306a5375d7582871cee03b725ec"><td class="memItemLeft" align="right" valign="top"><a id="a24bb6306a5375d7582871cee03b725ec"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a24bb6306a5375d7582871cee03b725ec">clip</a> (x, x_min, x_max)</td></tr>
<tr class="memdesc:a24bb6306a5375d7582871cee03b725ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confine a value to an interval. <br /></td></tr>
<tr class="separator:a24bb6306a5375d7582871cee03b725ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae207d4f6ef9507499ec3d4c329b9d458"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#ae207d4f6ef9507499ec3d4c329b9d458">linear_interp</a> (x, x1, x2, y1, y2, extrapolate=True)</td></tr>
<tr class="memdesc:ae207d4f6ef9507499ec3d4c329b9d458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly interpolate between two numbers.  <a href="namespacemotsfinder_1_1numutils.html#ae207d4f6ef9507499ec3d4c329b9d458">More...</a><br /></td></tr>
<tr class="separator:ae207d4f6ef9507499ec3d4c329b9d458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef050490c8d7a03e344e9f5d915e1610"><td class="memItemLeft" align="right" valign="top"><a id="aef050490c8d7a03e344e9f5d915e1610"></a>
def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#aef050490c8d7a03e344e9f5d915e1610">binomial</a> (n, k)</td></tr>
<tr class="memdesc:aef050490c8d7a03e344e9f5d915e1610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the binomial coefficient n choose k. <br /></td></tr>
<tr class="separator:aef050490c8d7a03e344e9f5d915e1610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40e8a7c57156a8cd59d647d6d73f9bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#ae40e8a7c57156a8cd59d647d6d73f9bb">binomial_coeffs</a> (n)</td></tr>
<tr class="memdesc:ae40e8a7c57156a8cd59d647d6d73f9bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute all binomial coefficients n choose k for 0 &lt;= k &lt;= n.  <a href="namespacemotsfinder_1_1numutils.html#ae40e8a7c57156a8cd59d647d6d73f9bb">More...</a><br /></td></tr>
<tr class="separator:ae40e8a7c57156a8cd59d647d6d73f9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b97c44db7e45216d0cc0b32acfa54a9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a4b97c44db7e45216d0cc0b32acfa54a9">inf_norm1d</a> (f1, f2=None, domain=None, Ns=50, xatol=1e-12)</td></tr>
<tr class="memdesc:a4b97c44db7e45216d0cc0b32acfa54a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L^inf norm of f1-f2.  <a href="namespacemotsfinder_1_1numutils.html#a4b97c44db7e45216d0cc0b32acfa54a9">More...</a><br /></td></tr>
<tr class="separator:a4b97c44db7e45216d0cc0b32acfa54a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e1cf75c3f5096d5de83995cfdd60a0"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#ae8e1cf75c3f5096d5de83995cfdd60a0">try_quad_tolerances</a> (func, args=(), kwargs=None, tol_min=1e-11, tol_max=1e-2, tol_steps=None, verbose=False)</td></tr>
<tr class="memdesc:ae8e1cf75c3f5096d5de83995cfdd60a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to run a given function with increasing tolerance until integration succeeds.  <a href="namespacemotsfinder_1_1numutils.html#ae8e1cf75c3f5096d5de83995cfdd60a0">More...</a><br /></td></tr>
<tr class="separator:ae8e1cf75c3f5096d5de83995cfdd60a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24489f5e58131c2fa6ad0ef9d36c732b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a24489f5e58131c2fa6ad0ef9d36c732b">inverse_2x2_matrix_derivative</a> (A, dA=None, ddA=None, diff=1)</td></tr>
<tr class="memdesc:a24489f5e58131c2fa6ad0ef9d36c732b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute derivatives of the inverse of a 2x2 matrix.  <a href="namespacemotsfinder_1_1numutils.html#a24489f5e58131c2fa6ad0ef9d36c732b">More...</a><br /></td></tr>
<tr class="separator:a24489f5e58131c2fa6ad0ef9d36c732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af61314d950493e3347758e9aa35570"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a0af61314d950493e3347758e9aa35570">bracket_root</a> (f, x0, step, domain=(float(&quot;-inf&quot;), float(&quot;+inf&quot;)), max_steps=10000, full_output=False, disp=False)</td></tr>
<tr class="memdesc:a0af61314d950493e3347758e9aa35570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple (naive) sign change finder to bracket a root.  <a href="namespacemotsfinder_1_1numutils.html#a0af61314d950493e3347758e9aa35570">More...</a><br /></td></tr>
<tr class="separator:a0af61314d950493e3347758e9aa35570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfc6e7f8c879fdc9b75b1ad15a39e06"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a5cfc6e7f8c879fdc9b75b1ad15a39e06">find_root</a> (f, x0, step, max_steps=10000, **kw)</td></tr>
<tr class="memdesc:a5cfc6e7f8c879fdc9b75b1ad15a39e06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a root of a function using Brent's method.  <a href="namespacemotsfinder_1_1numutils.html#a5cfc6e7f8c879fdc9b75b1ad15a39e06">More...</a><br /></td></tr>
<tr class="separator:a5cfc6e7f8c879fdc9b75b1ad15a39e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15fc56d129d00740db5b509ad31b60b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#ad15fc56d129d00740db5b509ad31b60b">find_all_roots</a> (xs, ys, func=None, full_output=False)</td></tr>
<tr class="memdesc:ad15fc56d129d00740db5b509ad31b60b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find all roots of a sampled function.  <a href="namespacemotsfinder_1_1numutils.html#ad15fc56d129d00740db5b509ad31b60b">More...</a><br /></td></tr>
<tr class="separator:ad15fc56d129d00740db5b509ad31b60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb6e610eeb52758e1e0fd5dca193976"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#abdb6e610eeb52758e1e0fd5dca193976">interpolate_root</a> (xs, ys, guess, step, kind=&quot;cubic&quot;, full_output=False)</td></tr>
<tr class="memdesc:abdb6e610eeb52758e1e0fd5dca193976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolate data to estimate a root.  <a href="namespacemotsfinder_1_1numutils.html#abdb6e610eeb52758e1e0fd5dca193976">More...</a><br /></td></tr>
<tr class="separator:abdb6e610eeb52758e1e0fd5dca193976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d2dd405310be63acd4b5ac7749280"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#adc5d2dd405310be63acd4b5ac7749280">extrapolate_root</a> (xs, ys, guess=None, at_end=True, kind=&quot;cubic&quot;, full_output=False)</td></tr>
<tr class="memdesc:adc5d2dd405310be63acd4b5ac7749280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extrapolate data to estimate a root.  <a href="namespacemotsfinder_1_1numutils.html#adc5d2dd405310be63acd4b5ac7749280">More...</a><br /></td></tr>
<tr class="separator:adc5d2dd405310be63acd4b5ac7749280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cadc676be1d52ada1c5861818b1c17"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#aa5cadc676be1d52ada1c5861818b1c17">_fixed_quad_abscissas</a> (a, b, n)</td></tr>
<tr class="memdesc:aa5cadc676be1d52ada1c5861818b1c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the abscissas of the Gaussian quadrature of order <code>n</code>.  <a href="namespacemotsfinder_1_1numutils.html#aa5cadc676be1d52ada1c5861818b1c17">More...</a><br /></td></tr>
<tr class="separator:aa5cadc676be1d52ada1c5861818b1c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac868c5e19f2ee60925565a02ab957e90"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#ac868c5e19f2ee60925565a02ab957e90">_fixed_quad</a> (func, a, b, n, full_domain=None, min_n=30)</td></tr>
<tr class="memdesc:ac868c5e19f2ee60925565a02ab957e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a function using fixed order Gaussian quadrature.  <a href="namespacemotsfinder_1_1numutils.html#ac868c5e19f2ee60925565a02ab957e90">More...</a><br /></td></tr>
<tr class="separator:ac868c5e19f2ee60925565a02ab957e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037496c5c59fcf131f27ee81af4d8636"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemotsfinder_1_1numutils.html#a037496c5c59fcf131f27ee81af4d8636">raise_all_warnings</a> ()</td></tr>
<tr class="memdesc:a037496c5c59fcf131f27ee81af4d8636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Context manager for turning numpy and native warnings into exceptions.  <a href="namespacemotsfinder_1_1numutils.html#a037496c5c59fcf131f27ee81af4d8636">More...</a><br /></td></tr>
<tr class="separator:a037496c5c59fcf131f27ee81af4d8636"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a0868e23c71d4c0138a1d30bb6c0fa630"><td class="memItemLeft" align="right" valign="top"><a id="a0868e23c71d4c0138a1d30bb6c0fa630"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>_golden</b></td></tr>
<tr class="separator:a0868e23c71d4c0138a1d30bb6c0fa630"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Miscellaneous numerical utilities and helpers. </p>
<p><b>Examples</b> </p>
<div class="fragment"><div class="line">&gt;&gt;&gt; binomial(5, 3)</div>
<div class="line">10</div>
</div><!-- fragment --> </div><h2 class="groupheader">Function Documentation</h2>
<a id="ac868c5e19f2ee60925565a02ab957e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac868c5e19f2ee60925565a02ab957e90">&#9670;&nbsp;</a></span>_fixed_quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils._fixed_quad </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_domain</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>min_n</em> = <code>30</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Integrate a function using fixed order Gaussian quadrature. </p>
<p>This is a wrapper for <code>scipy.integrate.fixed_quad()</code>. Given a full domain to integrate, it uses the information of the current sub-domain to choose less than the full set of <code>n</code> points such that integrating the full domain in several intervals, the total number of evaluations is approximately <code>n</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function taking a list of values and returning a list of results. </td></tr>
    <tr><td class="paramname">a,b</td><td>Interval to integrate over. </td></tr>
    <tr><td class="paramname">n</td><td>Order of the Gaussian quadrature for the <code>full_domain</code>. </td></tr>
    <tr><td class="paramname">full_domain</td><td>Full domain to eventually integrate over. If not given, <code>a,b</code> is taken to be the full domain, i.e. no reduction of quadrature order is done. </td></tr>
    <tr><td class="paramname">min_n</td><td>Minimum quadrature order for very small sub-domains. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5cadc676be1d52ada1c5861818b1c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cadc676be1d52ada1c5861818b1c17">&#9670;&nbsp;</a></span>_fixed_quad_abscissas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils._fixed_quad_abscissas </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the abscissas of the Gaussian quadrature of order <code>n</code>. </p>
<p>These are the exact points at which an integrand will be evaluated by <code>scipy.integrate.fixed_quad(..., a, b, n)</code>. Note that this will hold for <a class="el" href="namespacemotsfinder_1_1numutils.html#ac868c5e19f2ee60925565a02ab957e90" title="Integrate a function using fixed order Gaussian quadrature.">_fixed_quad()</a> <em>only</em> if no <code>full_domain</code> is given (or it is equal to the integration interval). </p>

</div>
</div>
<a id="ae40e8a7c57156a8cd59d647d6d73f9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40e8a7c57156a8cd59d647d6d73f9bb">&#9670;&nbsp;</a></span>binomial_coeffs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.binomial_coeffs </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute all binomial coefficients n choose k for 0 &lt;= k &lt;= n. </p>
<p>The result is a list of integers </p><p class="formulaDsp">
\[ {n \choose 0}, {n \choose 1}, \ldots, {n \choose n}. \]
</p>
 
</div>
</div>
<a id="a0af61314d950493e3347758e9aa35570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af61314d950493e3347758e9aa35570">&#9670;&nbsp;</a></span>bracket_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.bracket_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>(float(&quot;-inf&quot;),&#160;float(&quot;+inf&quot;))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_steps</em> = <code>10000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>disp</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple (naive) sign change finder to bracket a root. </p>
<p>Starting from an initial position (<code>x0</code>), this takes repeated steps until the function changes sign. The two x-values before and after the sign change are then returned (in undefined order) as a bracket. For any step taken, the step size is increased by the "golden ratio".</p>
<p>If the function's absolute value increases, we continue to walk in the other direction. The step size is still increased, so that there is a chance to escape a local minimum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function to bracket a root of. </td></tr>
    <tr><td class="paramname">x0</td><td>Where to start walking. </td></tr>
    <tr><td class="paramname">step</td><td>Initial step length. </td></tr>
    <tr><td class="paramname">domain</td><td>Where to look for a sign change. If the search hits one of these boundaries, we either return the current (boundary) position or raise an error, depending on the <code>disp</code> parameter. Default is to not impose a boundary. </td></tr>
    <tr><td class="paramname">max_steps</td><td>Maximum number of steps to try. Default is <code>10000</code>. </td></tr>
    <tr><td class="paramname">full_output</td><td>If <code>True</code>, return the bracket and the two corresponding function values as <code>a, b, f(a), f(b)</code>. Default is <code>False</code>, i.e. only return the bracket. </td></tr>
    <tr><td class="paramname">disp</td><td>If <code>True</code> and we get stuck at a domain boundary, raise a <a class="el" href="classmotsfinder_1_1numutils_1_1NumericalError.html" title="Exception raised for problems with numerical evaluation.">NumericalError</a>. Default is <code>False</code>, i.e. return the boundary position as <code>a, a, f(a), f(a)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc5d2dd405310be63acd4b5ac7749280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d2dd405310be63acd4b5ac7749280">&#9670;&nbsp;</a></span>extrapolate_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.extrapolate_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>guess</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>at_end</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>&quot;cubic&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extrapolate data to estimate a root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>The data points (x- and y-values). These need not have a sign change. </td></tr>
    <tr><td class="paramname">guess</td><td>The point to start searching for a root in the interpolant. If not given, take the last x-interval as first guess. </td></tr>
    <tr><td class="paramname">at_end</td><td>If <code>True</code> (default), try to find a root <em>after</em> the data. Else, try to find it <em>before</em> the data. </td></tr>
    <tr><td class="paramname">kind</td><td>Interpolation kind. Default is <code>"cubic"</code>. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to output the root only (<code>False</code>, default) or the root and interpolating function (<code>True</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad15fc56d129d00740db5b509ad31b60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15fc56d129d00740db5b509ad31b60b">&#9670;&nbsp;</a></span>find_all_roots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.find_all_roots </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find all roots of a sampled function. </p>
<p>This is used for functions that are already sampled at a grid of points <code>xs</code> with function values <code>ys</code>. It is assumed that this grid is dense enough such that all roots appear as sign changes in consecutive values in <code>ys</code> (and hence that the roots all have odd multiplicity).</p>
<dl class="section return"><dt>Returns</dt><dd>List of roots. Empty list if no sign change occurs in <code>ys</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>Precomputed abscissas and ordinates of <code>func</code>. </td></tr>
    <tr><td class="paramname">func</td><td>Callable for fine-tuning the root search. If not specified, an interpolating function will be generated from the <code>xs</code> and <code>ys</code> data. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to output the roots only (<code>False</code>, default) or the roots and interpolating function (<code>True</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cfc6e7f8c879fdc9b75b1ad15a39e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfc6e7f8c879fdc9b75b1ad15a39e06">&#9670;&nbsp;</a></span>find_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.find_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>max_steps</em> = <code>10000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">**&#160;</td>
          <td class="paramname"><em>kw</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a root of a function using Brent's method. </p>
<p>This is a simple wrapper around <code>scipy.optimize.brentq()</code>, which first tries to automatically find a bracket required for the <code>brentq()</code> call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Function (callable) to find a root of. </td></tr>
    <tr><td class="paramname">x0</td><td>Point to start searching for a sign change. </td></tr>
    <tr><td class="paramname">step</td><td>First step for the sign change search. </td></tr>
    <tr><td class="paramname">max_steps</td><td>Number of steps to take before givin up. Default is <code>10000</code>. </td></tr>
    <tr><td class="paramname">**kw</td><td>Further keyword arguments are passed to the <code>brentq()</code> call. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b97c44db7e45216d0cc0b32acfa54a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b97c44db7e45216d0cc0b32acfa54a9">&#9670;&nbsp;</a></span>inf_norm1d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.inf_norm1d </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>f2</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>domain</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>Ns</em> = <code>50</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xatol</em> = <code>1e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the L^inf norm of f1-f2. </p>
<p>The <code>scipy.optimize.brute</code> method is used to find a candidate close to the global maximum difference. This is then taken as starting point for a search for the local maximum difference. Setting the number of samples <code>Ns</code> high enough should lead to the global maximum difference being found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f1</td><td>First function. May also be a <code>NumericExpression</code>. </td></tr>
    <tr><td class="paramname">f2</td><td>Second function. May also be a <code>NumericExpression</code>. If not given, simply finds the maximum absolute value of <code>f1</code>. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain <code>[a, b]</code> inside which to search for the maximum difference. By default, <code>f1</code> is queried for the domain. </td></tr>
    <tr><td class="paramname">Ns</td><td>Number of initial samples for the <code>scipy.optimize.brute</code> call. In case <code>Ns &lt;= 2</code>, the <code>brute()</code> step is skipped an a local extremum is found inside the given <code>domain</code>. Default is <code>50</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pair <code>(x, delta)</code>, where <code>x</code> is the point at which the maximum difference was found and <code>delta</code> is the difference at that point. </dd></dl>

</div>
</div>
<a id="abdb6e610eeb52758e1e0fd5dca193976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdb6e610eeb52758e1e0fd5dca193976">&#9670;&nbsp;</a></span>interpolate_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.interpolate_root </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>xs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kind</em> = <code>&quot;cubic&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>full_output</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolate data to estimate a root. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xs,ys</td><td>The data points (x- and y-values). The y-values need to change sign. </td></tr>
    <tr><td class="paramname">guess</td><td>The point to start searching for a root. </td></tr>
    <tr><td class="paramname">step</td><td>The first step size for searching for a root. </td></tr>
    <tr><td class="paramname">kind</td><td>Interpolation kind. Default is <code>"cubic"</code>. </td></tr>
    <tr><td class="paramname">full_output</td><td>Whether to output the root only (<code>False</code>, default) or the root and interpolating function (<code>True</code>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24489f5e58131c2fa6ad0ef9d36c732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24489f5e58131c2fa6ad0ef9d36c732b">&#9670;&nbsp;</a></span>inverse_2x2_matrix_derivative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.inverse_2x2_matrix_derivative </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>dA</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>ddA</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>diff</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute derivatives of the inverse of a 2x2 matrix. </p>
<p>Given an invertible 2x2 matrix <code>A</code> with elements \(a_{ij}\) and any needed derivatives w.r.t. two different variables, this returns the derivatives of the inverse of <code>A</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The original matrix to compute the inverse of. </td></tr>
    <tr><td class="paramname">dA</td><td>Nested list or NumPy array with three indices where <code>dA[i][j][k]</code> contains the value of \(\partial_i a_{jk}\). </td></tr>
    <tr><td class="paramname">ddA</td><td>Nested list or NumPy array with four indices where <code>dA[i][j][k][l]</code> contains the value of \(\partial_i \partial_j a_{kl}\). </td></tr>
    <tr><td class="paramname">diff</td><td>Derivative order of the inverse matrix. If <code>diff==0</code>, the inverse of <code>A</code> is returned and <code>dA</code> and <code>ddA</code> are not needed. <code>dA</code> is needed if <code>diff &gt; 0</code> and <code>ddA</code> for <code>diff &gt; 1</code>. Default is <code>1</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NumPy array with two, three, or four axes depending on <code>diff</code>. The meaning of the indices such that <code>result[i1,i2,...,k,l]</code> contains the value \(\partial_{i_1} \partial_{i_2} \ldots (B)_{kl}\), where <code>B</code> is the inverse \(B = A^{-1}\).</dd></dl>
<p><b>Notes</b> </p>
<p>Consider the matrix </p><p class="formulaDsp">
\[ A = \left(\begin{array}{@{}cc@{}} a &amp; b\\ c &amp; d \end{array}\right). \]
</p>
<p> The inverse is then given by </p><p class="formulaDsp">
\[ B := A^{-1} = \frac{1}{\det A} \left(\begin{array}{@{}cc@{}} b &amp; -b\\ -c &amp; a \end{array}\right), \]
</p>
<p> where \(\det A = ad-bc\). The derivatives are easily computed using the chain and Leibniz' rule, which result in (using the shorthand notation \(a_i := \partial_i a\) and \(a_{ij} := \partial_i \partial_j a\)) </p><p class="formulaDsp">
\[ \partial_i B = - \frac{\partial_i \det A}{(\det A)^2} \left(\begin{array}{@{}cc@{}} d &amp; -b\\ -c &amp; a \end{array}\right) + \frac{1}{\det A} \left(\begin{array}{@{}cc@{}} d_i &amp; -b_i\\ -c_i &amp; a_i \end{array}\right) \]
</p>
<p> and </p><p class="formulaDsp">
\begin{eqnarray*} \partial_i \partial_j B &amp;=&amp; \left( -\frac{\partial_i\partial_j\det A}{(\det A)^2} + 2 \frac{(\partial_i\det A)(\partial_j\det A)}{(\det A)^3} \right) \left(\begin{array}{@{}cc@{}} d &amp; -b\\ -c &amp; a \end{array}\right) \\&amp;&amp; - \frac{\partial_i\det A}{(\det A)^2} \left(\begin{array}{@{}cc@{}} d_j &amp; -b_j\\ -c_j &amp; a_j \end{array}\right) - \frac{\partial_j\det A}{(\det A)^2} \left(\begin{array}{@{}cc@{}} d_i &amp; -b_i\\ -c_i &amp; a_i \end{array}\right) \\&amp;&amp; + \frac{1}{\det A} \left(\begin{array}{@{}cc@{}} d_{ij} &amp; -b_{ij}\\ -c_{ij} &amp; a_{ij} \end{array}\right), \end{eqnarray*}
</p>
<p> where </p><p class="formulaDsp">
\begin{eqnarray*} \partial_i \det A &amp;=&amp; a_i d + a d_i - b_i c - b c_i, \\ \partial_i \partial_j \det A &amp;=&amp; a_{ij} d + a_i d_j + a_j d_i + a d_{ij} - b_{ij} c - b_i c_j - b_j c_i - b c_{ij}. \end{eqnarray*}
</p>
 
</div>
</div>
<a id="ae207d4f6ef9507499ec3d4c329b9d458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae207d4f6ef9507499ec3d4c329b9d458">&#9670;&nbsp;</a></span>linear_interp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.linear_interp </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extrapolate</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linearly interpolate between two numbers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Abscissa to interpolate to. </td></tr>
    <tr><td class="paramname">x1,x2</td><td>Abscissas of the two data points to interpolate between. </td></tr>
    <tr><td class="paramname">y1,y2</td><td>Ordinates of the two data points to interpolate between. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a037496c5c59fcf131f27ee81af4d8636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037496c5c59fcf131f27ee81af4d8636">&#9670;&nbsp;</a></span>raise_all_warnings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.raise_all_warnings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Context manager for turning numpy and native warnings into exceptions. </p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">with</span> raise_all_warnings():</div>
<div class="line">    np.pi / np.linspace(0, 1, 10)</div>
</div><!-- fragment --><p> Without the <code><a class="el" href="namespacemotsfinder_1_1numutils.html#a037496c5c59fcf131f27ee81af4d8636" title="Context manager for turning numpy and native warnings into exceptions.">raise_all_warnings()</a></code> context, the above code would just issue a warning but otherwise run fine. This allows catching the exception to act upon it, e.g. </p><div class="fragment"><div class="line"><span class="keyword">with</span> raise_all_warnings():</div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        np.pi / np.linspace(0, 1, 10)</div>
<div class="line">    <span class="keywordflow">except</span> FloatingPointError:</div>
<div class="line">        print(<span class="stringliteral">&quot;Could not compute.&quot;</span>)</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae8e1cf75c3f5096d5de83995cfdd60a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e1cf75c3f5096d5de83995cfdd60a0">&#9670;&nbsp;</a></span>try_quad_tolerances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def motsfinder.numutils.try_quad_tolerances </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>args</em> = <code>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>kwargs</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol_min</em> = <code>1e-11</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol_max</em> = <code>1e-2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>tol_steps</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to run a given function with increasing tolerance until integration succeeds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Callable performing the integration. This should issue or raise an <code>IntegrationWarning</code> for too low tolerances. It is called as <code>func(tol, *args, **kwargs)</code>. </td></tr>
    <tr><td class="paramname">args</td><td>Optional additional positional arguments for <code>func</code>. </td></tr>
    <tr><td class="paramname">kwargs</td><td>Optional additional keyword arguments for <code>func</code>. </td></tr>
    <tr><td class="paramname">tol_min</td><td>Minimal tolerance to try first. Default is <code>1e-11</code>. </td></tr>
    <tr><td class="paramname">tol_max</td><td>Maximum tolerance to allow. If <code>func</code> fails for this tolerance, no more trials are done and the <code>IntegrationWarning</code> warning is raised. Default is <code>1e-2</code>. </td></tr>
    <tr><td class="paramname">tol_steps</td><td>How many steps to try when going from <code>tol_min</code> to <code>tol_max</code>. Should be at least two. Default is to go roughly through each order of magnitude. </td></tr>
    <tr><td class="paramname">verbose</td><td>If <code>True</code>, print the tolerances as they are tried out. Default is <code>False</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemotsfinder.html">motsfinder</a></li><li class="navelem"><a class="el" href="namespacemotsfinder_1_1numutils.html">numutils</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
